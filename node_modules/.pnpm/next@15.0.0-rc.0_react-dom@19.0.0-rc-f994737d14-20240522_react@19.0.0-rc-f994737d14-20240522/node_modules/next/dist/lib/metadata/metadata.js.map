{"version":3,"sources":["../../../src/lib/metadata/metadata.tsx"],"sourcesContent":["import type { ParsedUrlQuery } from 'querystring'\nimport type { GetDynamicParamFromSegment } from '../../server/app-render/app-render'\nimport type { LoaderTree } from '../../server/lib/app-dir-module'\n\nimport React from 'react'\nimport {\n  AppleWebAppMeta,\n  FormatDetectionMeta,\n  ItunesMeta,\n  BasicMeta,\n  ViewportMeta,\n  VerificationMeta,\n} from './generate/basic'\nimport { AlternatesMetadata } from './generate/alternate'\nimport {\n  OpenGraphMetadata,\n  TwitterMetadata,\n  AppLinksMeta,\n} from './generate/opengraph'\nimport { IconsMetadata } from './generate/icons'\nimport { resolveMetadata } from './resolve-metadata'\nimport { MetaFilter } from './generate/meta'\nimport type {\n  ResolvedMetadata,\n  ResolvedViewport,\n} from './types/metadata-interface'\nimport {\n  createDefaultMetadata,\n  createDefaultViewport,\n} from './default-metadata'\nimport { isNotFoundError } from '../../client/components/not-found'\n\n// Use a promise to share the status of the metadata resolving,\n// returning two components `MetadataTree` and `MetadataOutlet`\n// `MetadataTree` is the one that will be rendered at first in the content sequence for metadata tags.\n// `MetadataOutlet` is the one that will be rendered under error boundaries for metadata resolving errors.\n// In this way we can let the metadata tags always render successfully,\n// and the error will be caught by the error boundary and trigger fallbacks.\nexport function createMetadataComponents({\n  tree,\n  pathname,\n  trailingSlash,\n  query,\n  getDynamicParamFromSegment,\n  appUsingSizeAdjustment,\n  errorType,\n  createDynamicallyTrackedSearchParams,\n}: {\n  tree: LoaderTree\n  pathname: string\n  trailingSlash: boolean\n  query: ParsedUrlQuery\n  getDynamicParamFromSegment: GetDynamicParamFromSegment\n  appUsingSizeAdjustment: boolean\n  errorType?: 'not-found' | 'redirect'\n  createDynamicallyTrackedSearchParams: (\n    searchParams: ParsedUrlQuery\n  ) => ParsedUrlQuery\n}): [React.ComponentType, React.ComponentType] {\n  const metadataContext = {\n    // Make sure the pathname without query string\n    pathname: pathname.split('?')[0],\n    trailingSlash,\n  }\n\n  let resolve: (value: Error | undefined) => void | undefined\n  // Only use promise.resolve here to avoid unhandled rejections\n  const metadataErrorResolving = new Promise<Error | undefined>((res) => {\n    resolve = res\n  })\n\n  async function MetadataTree() {\n    const defaultMetadata = createDefaultMetadata()\n    const defaultViewport = createDefaultViewport()\n    let metadata: ResolvedMetadata | undefined = defaultMetadata\n    let viewport: ResolvedViewport | undefined = defaultViewport\n    let error: any\n    const errorMetadataItem: [null, null, null] = [null, null, null]\n    const errorConvention = errorType === 'redirect' ? undefined : errorType\n    const searchParams = createDynamicallyTrackedSearchParams(query)\n\n    const [resolvedError, resolvedMetadata, resolvedViewport] =\n      await resolveMetadata({\n        tree,\n        parentParams: {},\n        metadataItems: [],\n        errorMetadataItem,\n        searchParams,\n        getDynamicParamFromSegment,\n        errorConvention,\n        metadataContext,\n      })\n    if (!resolvedError) {\n      viewport = resolvedViewport\n      metadata = resolvedMetadata\n      resolve(undefined)\n    } else {\n      error = resolvedError\n      // If a not-found error is triggered during metadata resolution, we want to capture the metadata\n      // for the not-found route instead of whatever triggered the error. For all error types, we resolve an\n      // error, which will cause the outlet to throw it so it'll be handled by an error boundary\n      // (either an actual error, or an internal error that renders UI such as the NotFoundBoundary).\n      if (!errorType && isNotFoundError(resolvedError)) {\n        const [notFoundMetadataError, notFoundMetadata, notFoundViewport] =\n          await resolveMetadata({\n            tree,\n            parentParams: {},\n            metadataItems: [],\n            errorMetadataItem,\n            searchParams,\n            getDynamicParamFromSegment,\n            errorConvention: 'not-found',\n            metadataContext,\n          })\n        viewport = notFoundViewport\n        metadata = notFoundMetadata\n        error = notFoundMetadataError || error\n      }\n      resolve(error)\n    }\n\n    const elements = MetaFilter([\n      ViewportMeta({ viewport: viewport }),\n      BasicMeta({ metadata }),\n      AlternatesMetadata({ alternates: metadata.alternates }),\n      ItunesMeta({ itunes: metadata.itunes }),\n      FormatDetectionMeta({ formatDetection: metadata.formatDetection }),\n      VerificationMeta({ verification: metadata.verification }),\n      AppleWebAppMeta({ appleWebApp: metadata.appleWebApp }),\n      OpenGraphMetadata({ openGraph: metadata.openGraph }),\n      TwitterMetadata({ twitter: metadata.twitter }),\n      AppLinksMeta({ appLinks: metadata.appLinks }),\n      IconsMetadata({ icons: metadata.icons }),\n    ])\n\n    if (appUsingSizeAdjustment) elements.push(<meta name=\"next-size-adjust\" />)\n\n    return (\n      <>\n        {elements.map((el, index) => {\n          return React.cloneElement(el as React.ReactElement, { key: index })\n        })}\n      </>\n    )\n  }\n\n  async function MetadataOutlet() {\n    const error = await metadataErrorResolving\n    if (error) {\n      throw error\n    }\n    return null\n  }\n\n  return [MetadataTree, MetadataOutlet]\n}\n"],"names":["createMetadataComponents","tree","pathname","trailingSlash","query","getDynamicParamFromSegment","appUsingSizeAdjustment","errorType","createDynamicallyTrackedSearchParams","metadataContext","split","resolve","metadataErrorResolving","Promise","res","MetadataTree","defaultMetadata","createDefaultMetadata","defaultViewport","createDefaultViewport","metadata","viewport","error","errorMetadataItem","errorConvention","undefined","searchParams","resolvedError","resolvedMetadata","resolvedViewport","resolveMetadata","parentParams","metadataItems","isNotFoundError","notFoundMetadataError","notFoundMetadata","notFoundViewport","elements","MetaFilter","ViewportMeta","BasicMeta","AlternatesMetadata","alternates","ItunesMeta","itunes","FormatDetectionMeta","formatDetection","VerificationMeta","verification","AppleWebAppMeta","appleWebApp","OpenGraphMetadata","openGraph","TwitterMetadata","twitter","AppLinksMeta","appLinks","IconsMetadata","icons","push","meta","name","map","el","index","React","cloneElement","key","MetadataOutlet"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}