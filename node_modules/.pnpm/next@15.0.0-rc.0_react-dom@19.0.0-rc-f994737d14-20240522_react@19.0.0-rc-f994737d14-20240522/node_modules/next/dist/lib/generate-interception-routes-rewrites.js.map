{"version":3,"sources":["../../src/lib/generate-interception-routes-rewrites.ts"],"sourcesContent":["import { pathToRegexp } from 'next/dist/compiled/path-to-regexp'\nimport { NEXT_URL } from '../client/components/app-router-headers'\nimport {\n  INTERCEPTION_ROUTE_MARKERS,\n  extractInterceptionRouteInformation,\n  isInterceptionRouteAppPath,\n} from '../server/future/helpers/interception-routes'\nimport type { Rewrite } from './load-custom-routes'\n\n// a function that converts normalised paths (e.g. /foo/[bar]/[baz]) to the format expected by pathToRegexp (e.g. /foo/:bar/:baz)\nfunction toPathToRegexpPath(path: string): string {\n  return path.replace(/\\[\\[?([^\\]]+)\\]\\]?/g, (_, capture) => {\n    // path-to-regexp only supports word characters, so we replace any non-word characters with underscores\n    const paramName = capture.replace(/\\W+/g, '_')\n\n    // handle catch-all segments (e.g. /foo/bar/[...baz] or /foo/bar/[[...baz]])\n    if (paramName.startsWith('...')) {\n      return `:${paramName.slice(3)}*`\n    }\n    return ':' + paramName\n  })\n}\n\n// for interception routes we don't have access to the dynamic segments from the\n// referrer route so we mark them as noop for the app renderer so that it\n// can retrieve them from the router state later on. This also allows us to\n// compile the route properly with path-to-regexp, otherwise it will throw\nfunction voidParamsBeforeInterceptionMarker(path: string): string {\n  let newPath = []\n\n  let foundInterceptionMarker = false\n  for (const segment of path.split('/')) {\n    if (\n      INTERCEPTION_ROUTE_MARKERS.find((marker) => segment.startsWith(marker))\n    ) {\n      foundInterceptionMarker = true\n    }\n\n    if (segment.startsWith(':') && !foundInterceptionMarker) {\n      newPath.push('__NEXT_EMPTY_PARAM__')\n    } else {\n      newPath.push(segment)\n    }\n  }\n\n  return newPath.join('/')\n}\n\nexport function generateInterceptionRoutesRewrites(\n  appPaths: string[],\n  basePath = ''\n): Rewrite[] {\n  const rewrites: Rewrite[] = []\n\n  for (const appPath of appPaths) {\n    if (isInterceptionRouteAppPath(appPath)) {\n      const { interceptingRoute, interceptedRoute } =\n        extractInterceptionRouteInformation(appPath)\n\n      const normalizedInterceptingRoute = `${\n        interceptingRoute !== '/' ? toPathToRegexpPath(interceptingRoute) : ''\n      }/(.*)?`\n\n      const normalizedInterceptedRoute = toPathToRegexpPath(interceptedRoute)\n      const normalizedAppPath = voidParamsBeforeInterceptionMarker(\n        toPathToRegexpPath(appPath)\n      )\n\n      // pathToRegexp returns a regex that matches the path, but we need to\n      // convert it to a string that can be used in a header value\n      // to the format that Next/the proxy expects\n      let interceptingRouteRegex = pathToRegexp(normalizedInterceptingRoute)\n        .toString()\n        .slice(2, -3)\n\n      rewrites.push({\n        source: `${basePath}${normalizedInterceptedRoute}`,\n        destination: `${basePath}${normalizedAppPath}`,\n        has: [\n          {\n            type: 'header',\n            key: NEXT_URL,\n            value: interceptingRouteRegex,\n          },\n        ],\n      })\n    }\n  }\n\n  return rewrites\n}\n\nexport function isInterceptionRouteRewrite(route: Rewrite) {\n  // When we generate interception rewrites in the above implementation, we always do so with only a single `has` condition.\n  return route.has?.[0]?.key === NEXT_URL\n}\n"],"names":["generateInterceptionRoutesRewrites","isInterceptionRouteRewrite","toPathToRegexpPath","path","replace","_","capture","paramName","startsWith","slice","voidParamsBeforeInterceptionMarker","newPath","foundInterceptionMarker","segment","split","INTERCEPTION_ROUTE_MARKERS","find","marker","push","join","appPaths","basePath","rewrites","appPath","isInterceptionRouteAppPath","interceptingRoute","interceptedRoute","extractInterceptionRouteInformation","normalizedInterceptingRoute","normalizedInterceptedRoute","normalizedAppPath","interceptingRouteRegex","pathToRegexp","toString","source","destination","has","type","key","NEXT_URL","value","route"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":";;;;;;;;;;;;;;;IAgDgBA,kCAAkC;eAAlCA;;IA4CAC,0BAA0B;eAA1BA;;;8BA5Fa;kCACJ;oCAKlB;AAGP,iIAAiI;AACjI,SAASC,mBAAmBC,IAAY;IACtC,OAAOA,KAAKC,OAAO,CAAC,uBAAuB,CAACC,GAAGC;QAC7C,uGAAuG;QACvG,MAAMC,YAAYD,QAAQF,OAAO,CAAC,QAAQ;QAE1C,4EAA4E;QAC5E,IAAIG,UAAUC,UAAU,CAAC,QAAQ;YAC/B,OAAO,CAAC,CAAC,EAAED,UAAUE,KAAK,CAAC,GAAG,CAAC,CAAC;QAClC;QACA,OAAO,MAAMF;IACf;AACF;AAEA,gFAAgF;AAChF,yEAAyE;AACzE,2EAA2E;AAC3E,0EAA0E;AAC1E,SAASG,mCAAmCP,IAAY;IACtD,IAAIQ,UAAU,EAAE;IAEhB,IAAIC,0BAA0B;IAC9B,KAAK,MAAMC,WAAWV,KAAKW,KAAK,CAAC,KAAM;QACrC,IACEC,8CAA0B,CAACC,IAAI,CAAC,CAACC,SAAWJ,QAAQL,UAAU,CAACS,UAC/D;YACAL,0BAA0B;QAC5B;QAEA,IAAIC,QAAQL,UAAU,CAAC,QAAQ,CAACI,yBAAyB;YACvDD,QAAQO,IAAI,CAAC;QACf,OAAO;YACLP,QAAQO,IAAI,CAACL;QACf;IACF;IAEA,OAAOF,QAAQQ,IAAI,CAAC;AACtB;AAEO,SAASnB,mCACdoB,QAAkB,EAClBC,WAAW,EAAE;IAEb,MAAMC,WAAsB,EAAE;IAE9B,KAAK,MAAMC,WAAWH,SAAU;QAC9B,IAAII,IAAAA,8CAA0B,EAACD,UAAU;YACvC,MAAM,EAAEE,iBAAiB,EAAEC,gBAAgB,EAAE,GAC3CC,IAAAA,uDAAmC,EAACJ;YAEtC,MAAMK,8BAA8B,CAAC,EACnCH,sBAAsB,MAAMvB,mBAAmBuB,qBAAqB,GACrE,MAAM,CAAC;YAER,MAAMI,6BAA6B3B,mBAAmBwB;YACtD,MAAMI,oBAAoBpB,mCACxBR,mBAAmBqB;YAGrB,qEAAqE;YACrE,4DAA4D;YAC5D,4CAA4C;YAC5C,IAAIQ,yBAAyBC,IAAAA,0BAAY,EAACJ,6BACvCK,QAAQ,GACRxB,KAAK,CAAC,GAAG,CAAC;YAEba,SAASJ,IAAI,CAAC;gBACZgB,QAAQ,CAAC,EAAEb,SAAS,EAAEQ,2BAA2B,CAAC;gBAClDM,aAAa,CAAC,EAAEd,SAAS,EAAES,kBAAkB,CAAC;gBAC9CM,KAAK;oBACH;wBACEC,MAAM;wBACNC,KAAKC,0BAAQ;wBACbC,OAAOT;oBACT;iBACD;YACH;QACF;IACF;IAEA,OAAOT;AACT;AAEO,SAASrB,2BAA2BwC,KAAc;QAEhDA,aAAAA;IADP,0HAA0H;IAC1H,OAAOA,EAAAA,aAAAA,MAAML,GAAG,sBAATK,cAAAA,UAAW,CAAC,EAAE,qBAAdA,YAAgBH,GAAG,MAAKC,0BAAQ;AACzC"}