{"version":3,"sources":["../../../../src/build/webpack/loaders/next-metadata-route-loader.ts"],"sourcesContent":["import type webpack from 'webpack'\nimport fs from 'fs'\nimport path from 'path'\nimport { imageExtMimeTypeMap } from '../../../lib/mime-type'\nimport { getLoaderModuleNamedExports } from './utils'\n\nfunction errorOnBadHandler(resourcePath: string) {\n  return `\n  if (typeof handler !== 'function') {\n    throw new Error('Default export is missing in ${JSON.stringify(\n      resourcePath\n    )}')\n  }\n  `\n}\n\nconst cacheHeader = {\n  none: 'no-cache, no-store',\n  longCache: 'public, immutable, no-transform, max-age=31536000',\n  revalidate: 'public, max-age=0, must-revalidate',\n}\n\ntype MetadataRouteLoaderOptions = {\n  page: string\n  filePath: string\n  isDynamic: '1' | '0'\n}\n\nexport function getFilenameAndExtension(resourcePath: string) {\n  const filename = path.basename(resourcePath)\n  const [name, ext] = filename.split('.', 2)\n  return { name, ext }\n}\n\nfunction getContentType(resourcePath: string) {\n  let { name, ext } = getFilenameAndExtension(resourcePath)\n  if (ext === 'jpg') ext = 'jpeg'\n\n  if (name === 'favicon' && ext === 'ico') return 'image/x-icon'\n  if (name === 'sitemap') return 'application/xml'\n  if (name === 'robots') return 'text/plain'\n  if (name === 'manifest') return 'application/manifest+json'\n\n  if (ext === 'png' || ext === 'jpeg' || ext === 'ico' || ext === 'svg') {\n    return imageExtMimeTypeMap[ext]\n  }\n  return 'text/plain'\n}\n\nasync function getStaticAssetRouteCode(\n  resourcePath: string,\n  fileBaseName: string\n) {\n  const cache =\n    fileBaseName === 'favicon'\n      ? 'public, max-age=0, must-revalidate'\n      : process.env.NODE_ENV !== 'production'\n        ? cacheHeader.none\n        : cacheHeader.longCache\n  const code = `\\\n/* static asset route */\nimport { NextResponse } from 'next/server'\n\nconst contentType = ${JSON.stringify(getContentType(resourcePath))}\nconst buffer = Buffer.from(${JSON.stringify(\n    (await fs.promises.readFile(resourcePath)).toString('base64')\n  )}, 'base64'\n  )\n\nexport function GET() {\n  return new NextResponse(buffer, {\n    headers: {\n      'Content-Type': contentType,\n      'Cache-Control': ${JSON.stringify(cache)},\n    },\n  })\n}\n\nexport const dynamic = 'force-static'\n`\n  return code\n}\n\nfunction getDynamicTextRouteCode(resourcePath: string) {\n  return `\\\n/* dynamic asset route */\nimport { NextResponse } from 'next/server'\nimport handler from ${JSON.stringify(resourcePath)}\nimport { resolveRouteData } from 'next/dist/build/webpack/loaders/metadata/resolve-route-data'\n\nconst contentType = ${JSON.stringify(getContentType(resourcePath))}\nconst fileType = ${JSON.stringify(getFilenameAndExtension(resourcePath).name)}\n\n${errorOnBadHandler(resourcePath)}\n\nexport async function GET() {\n  const data = await handler()\n  const content = resolveRouteData(data, fileType)\n\n  return new NextResponse(content, {\n    headers: {\n      'Content-Type': contentType,\n      'Cache-Control': ${JSON.stringify(cacheHeader.revalidate)},\n    },\n  })\n}\n`\n}\n\n// <metadata-image>/[id]/route.js\nfunction getDynamicImageRouteCode(resourcePath: string) {\n  return `\\\n/* dynamic image route */\nimport { NextResponse } from 'next/server'\nimport * as userland from ${JSON.stringify(resourcePath)}\n\nconst imageModule = { ...userland }\n\nconst handler = imageModule.default\nconst generateImageMetadata = imageModule.generateImageMetadata\n\n${errorOnBadHandler(resourcePath)}\n\nexport async function GET(_, ctx) {\n  const { __metadata_id__, ...params } = ctx.params || {}\n  const targetId = __metadata_id__?.[0]\n  let id = undefined\n  const imageMetadata = generateImageMetadata ? await generateImageMetadata({ params }) : null\n\n  if (imageMetadata) {\n    id = imageMetadata.find((item) => {\n      if (process.env.NODE_ENV !== 'production') {\n        if (item?.id == null) {\n          throw new Error('id property is required for every item returned from generateImageMetadata')\n        }\n      }\n      return item.id.toString() === targetId\n    })?.id\n    if (id == null) {\n      return new NextResponse('Not Found', {\n        status: 404,\n      })\n    }\n  }\n  return handler({ params: ctx.params ? params : undefined, id })\n}\n`\n}\n\nasync function getDynamicSiteMapRouteCode(\n  resourcePath: string,\n  page: string,\n  loaderContext: webpack.LoaderContext<any>\n) {\n  let staticGenerationCode = ''\n\n  const exportNames = await getLoaderModuleNamedExports(\n    resourcePath,\n    loaderContext\n  )\n  // Re-export configs but avoid conflicted exports\n  const reExportNames = exportNames.filter(\n    (name) => name !== 'default' && name !== 'generateSitemaps'\n  )\n\n  const hasGenerateSiteMaps = exportNames.includes('generateSitemaps')\n  if (\n    process.env.NODE_ENV === 'production' &&\n    hasGenerateSiteMaps &&\n    page.includes('[__metadata_id__]')\n  ) {\n    staticGenerationCode = `\\\n/* dynamic sitemap route */ \nexport async function generateStaticParams() {\n  const sitemaps = generateSitemaps ? await generateSitemaps() : []\n  const params = []\n\n  for (const item of sitemaps) {\n    params.push({ __metadata_id__: item.id.toString() })\n  }\n  return params\n}\n    `\n  }\n\n  const code = `\\\nimport { NextResponse } from 'next/server'\nimport * as userland from ${JSON.stringify(resourcePath)}\nimport { resolveRouteData } from 'next/dist/build/webpack/loaders/metadata/resolve-route-data'\n\nconst sitemapModule = { ...userland }\nconst handler = sitemapModule.default\nconst generateSitemaps = sitemapModule.generateSitemaps\nconst contentType = ${JSON.stringify(getContentType(resourcePath))}\nconst fileType = ${JSON.stringify(getFilenameAndExtension(resourcePath).name)}\n\n${errorOnBadHandler(resourcePath)}\n\n${'' /* re-export the userland route configs */}\n${\n  reExportNames.length > 0\n    ? `export { ${reExportNames.join(', ')} } from ${JSON.stringify(\n        resourcePath\n      )}\\n`\n    : ''\n}\n\nexport async function GET(_, ctx) {\n  const { __metadata_id__, ...params } = ctx.params || {}\n  ${\n    '' /* sitemap will be optimized to [__metadata_id__] from [[..._metadata_id__]] in production */\n  }\n  const targetId = process.env.NODE_ENV !== 'production'\n    ? __metadata_id__?.[0]\n    : __metadata_id__\n\n  let id = undefined\n  const sitemaps = generateSitemaps ? await generateSitemaps() : null\n\n  if (sitemaps) {\n    id = sitemaps.find((item) => {\n      if (process.env.NODE_ENV !== 'production') {\n        if (item?.id == null) {\n          throw new Error('id property is required for every item returned from generateSitemaps')\n        }\n      }\n      let itemID = item.id.toString()\n      return itemID === targetId\n    })?.id\n    if (id == null) {\n      return new NextResponse('Not Found', {\n        status: 404,\n      })\n    }\n  }\n\n  const data = await handler({ id })\n  const content = resolveRouteData(data, fileType)\n\n  return new NextResponse(content, {\n    headers: {\n      'Content-Type': contentType,\n      'Cache-Control': ${JSON.stringify(cacheHeader.revalidate)},\n    },\n  })\n}\n\n${staticGenerationCode}\n`\n  return code\n}\n\n// When it's static route, it could be favicon.ico, sitemap.xml, robots.txt etc.\n// TODO-METADATA: improve the cache control strategy\nconst nextMetadataRouterLoader: webpack.LoaderDefinitionFunction<MetadataRouteLoaderOptions> =\n  async function () {\n    const { page, isDynamic, filePath } = this.getOptions()\n    const { name: fileBaseName } = getFilenameAndExtension(filePath)\n\n    let code = ''\n    if (isDynamic === '1') {\n      if (fileBaseName === 'robots' || fileBaseName === 'manifest') {\n        code = getDynamicTextRouteCode(filePath)\n      } else if (fileBaseName === 'sitemap') {\n        code = await getDynamicSiteMapRouteCode(filePath, page, this)\n      } else {\n        code = getDynamicImageRouteCode(filePath)\n      }\n    } else {\n      code = await getStaticAssetRouteCode(filePath, fileBaseName)\n    }\n\n    return code\n  }\n\nexport default nextMetadataRouterLoader\n"],"names":["getFilenameAndExtension","errorOnBadHandler","resourcePath","JSON","stringify","cacheHeader","none","longCache","revalidate","filename","path","basename","name","ext","split","getContentType","imageExtMimeTypeMap","getStaticAssetRouteCode","fileBaseName","cache","process","env","NODE_ENV","code","fs","promises","readFile","toString","getDynamicTextRouteCode","getDynamicImageRouteCode","getDynamicSiteMapRouteCode","page","loaderContext","staticGenerationCode","exportNames","getLoaderModuleNamedExports","reExportNames","filter","hasGenerateSiteMaps","includes","length","join","nextMetadataRouterLoader","isDynamic","filePath","getOptions"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}