{"version":3,"sources":["../../../../src/experimental/testmode/playwright/next-fixture.ts"],"sourcesContent":["import type { Page, TestInfo } from '@playwright/test'\nimport type { NextWorkerFixture, FetchHandler } from './next-worker-fixture'\nimport type { NextOptions } from './next-options'\nimport type { FetchHandlerResult } from '../proxy'\nimport { handleRoute } from './page-route'\nimport { reportFetch } from './report'\n\nexport interface NextFixture {\n  onFetch: (handler: FetchHandler) => void\n}\n\nclass NextFixtureImpl implements NextFixture {\n  public readonly testId: string\n  private fetchHandlers: FetchHandler[] = []\n\n  constructor(\n    private testInfo: TestInfo,\n    private options: NextOptions,\n    private worker: NextWorkerFixture,\n    private page: Page\n  ) {\n    this.testId = testInfo.testId\n    const testHeaders = {\n      'Next-Test-Proxy-Port': String(worker.proxyPort),\n      'Next-Test-Data': this.testId,\n    }\n    const handleFetch = this.handleFetch.bind(this)\n    worker.onFetch(this.testId, handleFetch)\n    this.page\n      .context()\n      .route('**', (route) =>\n        handleRoute(route, page, testHeaders, handleFetch)\n      )\n  }\n\n  teardown(): void {\n    this.worker.cleanupTest(this.testId)\n  }\n\n  onFetch(handler: FetchHandler): void {\n    this.fetchHandlers.push(handler)\n  }\n\n  private async handleFetch(request: Request): Promise<FetchHandlerResult> {\n    return reportFetch(this.testInfo, request, async (req) => {\n      for (const handler of this.fetchHandlers.slice().reverse()) {\n        const result = await handler(req.clone())\n        if (result) {\n          return result\n        }\n      }\n      if (this.options.fetchLoopback) {\n        return fetch(req.clone())\n      }\n      return undefined\n    })\n  }\n}\n\nexport async function applyNextFixture(\n  use: (fixture: NextFixture) => Promise<void>,\n  {\n    testInfo,\n    nextOptions,\n    nextWorker,\n    page,\n  }: {\n    testInfo: TestInfo\n    nextOptions: NextOptions\n    nextWorker: NextWorkerFixture\n    page: Page\n  }\n): Promise<void> {\n  const fixture = new NextFixtureImpl(testInfo, nextOptions, nextWorker, page)\n\n  await use(fixture)\n\n  fixture.teardown()\n}\n"],"names":["applyNextFixture","NextFixtureImpl","constructor","testInfo","options","worker","page","fetchHandlers","testId","testHeaders","String","proxyPort","handleFetch","bind","onFetch","context","route","handleRoute","teardown","cleanupTest","handler","push","request","reportFetch","req","slice","reverse","result","clone","fetchLoopback","fetch","undefined","use","nextOptions","nextWorker","fixture"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":";;;;+BA2DsBA;;;eAAAA;;;2BAvDM;wBACA;AAM5B,MAAMC;IAIJC,YACE,AAAQC,QAAkB,EAC1B,AAAQC,OAAoB,EAC5B,AAAQC,MAAyB,EACjC,AAAQC,IAAU,CAClB;aAJQH,WAAAA;aACAC,UAAAA;aACAC,SAAAA;aACAC,OAAAA;aANFC,gBAAgC,EAAE;QAQxC,IAAI,CAACC,MAAM,GAAGL,SAASK,MAAM;QAC7B,MAAMC,cAAc;YAClB,wBAAwBC,OAAOL,OAAOM,SAAS;YAC/C,kBAAkB,IAAI,CAACH,MAAM;QAC/B;QACA,MAAMI,cAAc,IAAI,CAACA,WAAW,CAACC,IAAI,CAAC,IAAI;QAC9CR,OAAOS,OAAO,CAAC,IAAI,CAACN,MAAM,EAAEI;QAC5B,IAAI,CAACN,IAAI,CACNS,OAAO,GACPC,KAAK,CAAC,MAAM,CAACA,QACZC,IAAAA,sBAAW,EAACD,OAAOV,MAAMG,aAAaG;IAE5C;IAEAM,WAAiB;QACf,IAAI,CAACb,MAAM,CAACc,WAAW,CAAC,IAAI,CAACX,MAAM;IACrC;IAEAM,QAAQM,OAAqB,EAAQ;QACnC,IAAI,CAACb,aAAa,CAACc,IAAI,CAACD;IAC1B;IAEA,MAAcR,YAAYU,OAAgB,EAA+B;QACvE,OAAOC,IAAAA,mBAAW,EAAC,IAAI,CAACpB,QAAQ,EAAEmB,SAAS,OAAOE;YAChD,KAAK,MAAMJ,WAAW,IAAI,CAACb,aAAa,CAACkB,KAAK,GAAGC,OAAO,GAAI;gBAC1D,MAAMC,SAAS,MAAMP,QAAQI,IAAII,KAAK;gBACtC,IAAID,QAAQ;oBACV,OAAOA;gBACT;YACF;YACA,IAAI,IAAI,CAACvB,OAAO,CAACyB,aAAa,EAAE;gBAC9B,OAAOC,MAAMN,IAAII,KAAK;YACxB;YACA,OAAOG;QACT;IACF;AACF;AAEO,eAAe/B,iBACpBgC,GAA4C,EAC5C,EACE7B,QAAQ,EACR8B,WAAW,EACXC,UAAU,EACV5B,IAAI,EAML;IAED,MAAM6B,UAAU,IAAIlC,gBAAgBE,UAAU8B,aAAaC,YAAY5B;IAEvE,MAAM0B,IAAIG;IAEVA,QAAQjB,QAAQ;AAClB"}