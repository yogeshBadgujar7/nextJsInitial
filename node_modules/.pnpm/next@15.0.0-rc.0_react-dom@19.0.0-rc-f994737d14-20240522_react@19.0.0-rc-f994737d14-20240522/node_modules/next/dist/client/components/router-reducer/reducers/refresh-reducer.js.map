{"version":3,"sources":["../../../../../src/client/components/router-reducer/reducers/refresh-reducer.ts"],"sourcesContent":["import { fetchServerResponse } from '../fetch-server-response'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type {\n  Mutable,\n  ReadonlyReducerState,\n  ReducerState,\n  RefreshAction,\n} from '../router-reducer-types'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { handleMutable } from '../handle-mutable'\nimport type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { fillLazyItemsTillLeafWithHead } from '../fill-lazy-items-till-leaf-with-head'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { handleSegmentMismatch } from '../handle-segment-mismatch'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\nimport { refreshInactiveParallelSegments } from '../refetch-inactive-parallel-segments'\n\nexport function refreshReducer(\n  state: ReadonlyReducerState,\n  action: RefreshAction\n): ReducerState {\n  const { origin } = action\n  const mutable: Mutable = {}\n  const href = state.canonicalUrl\n\n  let currentTree = state.tree\n\n  mutable.preserveCustomHistoryState = false\n\n  const cache: CacheNode = createEmptyCacheNode()\n\n  // If the current tree was intercepted, the nextUrl should be included in the request.\n  // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n  const includeNextUrl = hasInterceptionRouteInCurrentTree(state.tree)\n\n  // TODO-APP: verify that `href` is not an external url.\n  // Fetch data from the root of the tree.\n  cache.lazyData = fetchServerResponse(\n    new URL(href, origin),\n    [currentTree[0], currentTree[1], currentTree[2], 'refetch'],\n    includeNextUrl ? state.nextUrl : null,\n    state.buildId\n  )\n\n  return cache.lazyData.then(\n    async ([flightData, canonicalUrlOverride]) => {\n      // Handle case when navigating to page in `pages` from `app`\n      if (typeof flightData === 'string') {\n        return handleExternalUrl(\n          state,\n          mutable,\n          flightData,\n          state.pushRef.pendingPush\n        )\n      }\n\n      // Remove cache.lazyData as it has been resolved at this point.\n      cache.lazyData = null\n\n      for (const flightDataPath of flightData) {\n        // FlightDataPath with more than two items means unexpected Flight data was returned\n        if (flightDataPath.length !== 3) {\n          // TODO-APP: handle this case better\n          console.log('REFRESH FAILED')\n          return state\n        }\n\n        // Given the path can only have two items the items are only the router state and rsc for the root.\n        const [treePatch] = flightDataPath\n        const newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          [''],\n          currentTree,\n          treePatch,\n          state.canonicalUrl\n        )\n\n        if (newTree === null) {\n          return handleSegmentMismatch(state, action, treePatch)\n        }\n\n        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n          return handleExternalUrl(\n            state,\n            mutable,\n            href,\n            state.pushRef.pendingPush\n          )\n        }\n\n        const canonicalUrlOverrideHref = canonicalUrlOverride\n          ? createHrefFromUrl(canonicalUrlOverride)\n          : undefined\n\n        if (canonicalUrlOverride) {\n          mutable.canonicalUrl = canonicalUrlOverrideHref\n        }\n\n        // The one before last item is the router state tree patch\n        const [cacheNodeSeedData, head] = flightDataPath.slice(-2)\n\n        // Handles case where prefetch only returns the router tree patch without rendered components.\n        if (cacheNodeSeedData !== null) {\n          const rsc = cacheNodeSeedData[2]\n          cache.rsc = rsc\n          cache.prefetchRsc = null\n          fillLazyItemsTillLeafWithHead(\n            cache,\n            // Existing cache is not passed in as `router.refresh()` has to invalidate the entire cache.\n            undefined,\n            treePatch,\n            cacheNodeSeedData,\n            head\n          )\n          mutable.prefetchCache = new Map()\n        }\n\n        await refreshInactiveParallelSegments({\n          state,\n          updatedTree: newTree,\n          updatedCache: cache,\n          includeNextUrl,\n        })\n\n        mutable.cache = cache\n        mutable.patchedTree = newTree\n\n        currentTree = newTree\n      }\n\n      return handleMutable(state, mutable)\n    },\n    () => state\n  )\n}\n"],"names":["refreshReducer","state","action","origin","mutable","href","canonicalUrl","currentTree","tree","preserveCustomHistoryState","cache","createEmptyCacheNode","includeNextUrl","hasInterceptionRouteInCurrentTree","lazyData","fetchServerResponse","URL","nextUrl","buildId","then","flightData","canonicalUrlOverride","handleExternalUrl","pushRef","pendingPush","flightDataPath","length","console","log","treePatch","newTree","applyRouterStatePatchToTree","handleSegmentMismatch","isNavigatingToNewRootLayout","canonicalUrlOverrideHref","createHrefFromUrl","undefined","cacheNodeSeedData","head","slice","rsc","prefetchRsc","fillLazyItemsTillLeafWithHead","prefetchCache","Map","refreshInactiveParallelSegments","updatedTree","updatedCache","patchedTree","handleMutable"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":";;;;+BAmBgBA;;;eAAAA;;;qCAnBoB;mCACF;6CACU;6CACA;iCAOV;+BACJ;+CAEgB;2BACT;uCACC;mDACY;iDACF;AAEzC,SAASA,eACdC,KAA2B,EAC3BC,MAAqB;IAErB,MAAM,EAAEC,MAAM,EAAE,GAAGD;IACnB,MAAME,UAAmB,CAAC;IAC1B,MAAMC,OAAOJ,MAAMK,YAAY;IAE/B,IAAIC,cAAcN,MAAMO,IAAI;IAE5BJ,QAAQK,0BAA0B,GAAG;IAErC,MAAMC,QAAmBC,IAAAA,+BAAoB;IAE7C,sFAAsF;IACtF,sHAAsH;IACtH,MAAMC,iBAAiBC,IAAAA,oEAAiC,EAACZ,MAAMO,IAAI;IAEnE,uDAAuD;IACvD,wCAAwC;IACxCE,MAAMI,QAAQ,GAAGC,IAAAA,wCAAmB,EAClC,IAAIC,IAAIX,MAAMF,SACd;QAACI,WAAW,CAAC,EAAE;QAAEA,WAAW,CAAC,EAAE;QAAEA,WAAW,CAAC,EAAE;QAAE;KAAU,EAC3DK,iBAAiBX,MAAMgB,OAAO,GAAG,MACjChB,MAAMiB,OAAO;IAGf,OAAOR,MAAMI,QAAQ,CAACK,IAAI,CACxB;YAAO,CAACC,YAAYC,qBAAqB;QACvC,4DAA4D;QAC5D,IAAI,OAAOD,eAAe,UAAU;YAClC,OAAOE,IAAAA,kCAAiB,EACtBrB,OACAG,SACAgB,YACAnB,MAAMsB,OAAO,CAACC,WAAW;QAE7B;QAEA,+DAA+D;QAC/Dd,MAAMI,QAAQ,GAAG;QAEjB,KAAK,MAAMW,kBAAkBL,WAAY;YACvC,oFAAoF;YACpF,IAAIK,eAAeC,MAAM,KAAK,GAAG;gBAC/B,oCAAoC;gBACpCC,QAAQC,GAAG,CAAC;gBACZ,OAAO3B;YACT;YAEA,mGAAmG;YACnG,MAAM,CAAC4B,UAAU,GAAGJ;YACpB,MAAMK,UAAUC,IAAAA,wDAA2B,EACzC,sBAAsB;YACtB;gBAAC;aAAG,EACJxB,aACAsB,WACA5B,MAAMK,YAAY;YAGpB,IAAIwB,YAAY,MAAM;gBACpB,OAAOE,IAAAA,4CAAqB,EAAC/B,OAAOC,QAAQ2B;YAC9C;YAEA,IAAII,IAAAA,wDAA2B,EAAC1B,aAAauB,UAAU;gBACrD,OAAOR,IAAAA,kCAAiB,EACtBrB,OACAG,SACAC,MACAJ,MAAMsB,OAAO,CAACC,WAAW;YAE7B;YAEA,MAAMU,2BAA2Bb,uBAC7Bc,IAAAA,oCAAiB,EAACd,wBAClBe;YAEJ,IAAIf,sBAAsB;gBACxBjB,QAAQE,YAAY,GAAG4B;YACzB;YAEA,0DAA0D;YAC1D,MAAM,CAACG,mBAAmBC,KAAK,GAAGb,eAAec,KAAK,CAAC,CAAC;YAExD,8FAA8F;YAC9F,IAAIF,sBAAsB,MAAM;gBAC9B,MAAMG,MAAMH,iBAAiB,CAAC,EAAE;gBAChC3B,MAAM8B,GAAG,GAAGA;gBACZ9B,MAAM+B,WAAW,GAAG;gBACpBC,IAAAA,4DAA6B,EAC3BhC,OACA,4FAA4F;gBAC5F0B,WACAP,WACAQ,mBACAC;gBAEFlC,QAAQuC,aAAa,GAAG,IAAIC;YAC9B;YAEA,MAAMC,IAAAA,gEAA+B,EAAC;gBACpC5C;gBACA6C,aAAahB;gBACbiB,cAAcrC;gBACdE;YACF;YAEAR,QAAQM,KAAK,GAAGA;YAChBN,QAAQ4C,WAAW,GAAGlB;YAEtBvB,cAAcuB;QAChB;QAEA,OAAOmB,IAAAA,4BAAa,EAAChD,OAAOG;IAC9B,GACA,IAAMH;AAEV"}