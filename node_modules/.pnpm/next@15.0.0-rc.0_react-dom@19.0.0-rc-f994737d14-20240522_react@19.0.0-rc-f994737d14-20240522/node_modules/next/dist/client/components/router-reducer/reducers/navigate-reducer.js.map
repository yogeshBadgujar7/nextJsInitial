{"version":3,"sources":["../../../../../src/client/components/router-reducer/reducers/navigate-reducer.ts"],"sourcesContent":["import type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../../server/app-render/types'\nimport { fetchServerResponse } from '../fetch-server-response'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { invalidateCacheBelowFlightSegmentPath } from '../invalidate-cache-below-flight-segmentpath'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { shouldHardNavigate } from '../should-hard-navigate'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport {\n  PrefetchCacheEntryStatus,\n  type Mutable,\n  type NavigateAction,\n  type ReadonlyReducerState,\n  type ReducerState,\n} from '../router-reducer-types'\nimport { handleMutable } from '../handle-mutable'\nimport { applyFlightData } from '../apply-flight-data'\nimport { prefetchQueue } from './prefetch-reducer'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { DEFAULT_SEGMENT_KEY } from '../../../../shared/lib/segment'\nimport {\n  listenForDynamicRequest,\n  updateCacheNodeOnNavigation,\n} from '../ppr-navigations'\nimport {\n  getOrCreatePrefetchCacheEntry,\n  prunePrefetchCache,\n} from '../prefetch-cache-utils'\nimport { clearCacheNodeDataForSegmentPath } from '../clear-cache-node-data-for-segment-path'\n\nexport function handleExternalUrl(\n  state: ReadonlyReducerState,\n  mutable: Mutable,\n  url: string,\n  pendingPush: boolean\n) {\n  mutable.mpaNavigation = true\n  mutable.canonicalUrl = url\n  mutable.pendingPush = pendingPush\n  mutable.scrollableSegments = undefined\n\n  return handleMutable(state, mutable)\n}\n\nfunction generateSegmentsFromPatch(\n  flightRouterPatch: FlightRouterState\n): FlightSegmentPath[] {\n  const segments: FlightSegmentPath[] = []\n  const [segment, parallelRoutes] = flightRouterPatch\n\n  if (Object.keys(parallelRoutes).length === 0) {\n    return [[segment]]\n  }\n\n  for (const [parallelRouteKey, parallelRoute] of Object.entries(\n    parallelRoutes\n  )) {\n    for (const childSegment of generateSegmentsFromPatch(parallelRoute)) {\n      // If the segment is empty, it means we are at the root of the tree\n      if (segment === '') {\n        segments.push([parallelRouteKey, ...childSegment])\n      } else {\n        segments.push([segment, parallelRouteKey, ...childSegment])\n      }\n    }\n  }\n\n  return segments\n}\n\nfunction triggerLazyFetchForLeafSegments(\n  newCache: CacheNode,\n  currentCache: CacheNode,\n  flightSegmentPath: FlightSegmentPath,\n  treePatch: FlightRouterState\n) {\n  let appliedPatch = false\n\n  newCache.rsc = currentCache.rsc\n  newCache.prefetchRsc = currentCache.prefetchRsc\n  newCache.loading = currentCache.loading\n  newCache.parallelRoutes = new Map(currentCache.parallelRoutes)\n\n  const segmentPathsToFill = generateSegmentsFromPatch(treePatch).map(\n    (segment) => [...flightSegmentPath, ...segment]\n  )\n\n  for (const segmentPaths of segmentPathsToFill) {\n    clearCacheNodeDataForSegmentPath(newCache, currentCache, segmentPaths)\n\n    appliedPatch = true\n  }\n\n  return appliedPatch\n}\n\n// These implementations are expected to diverge significantly, so I've forked\n// the entire function. The one that's disabled should be dead code eliminated\n// because the check here is statically inlined at build time.\nexport const navigateReducer = process.env.__NEXT_PPR\n  ? navigateReducer_PPR\n  : navigateReducer_noPPR\n\n// This is the implementation when PPR is disabled. We can assume its behavior\n// is relatively stable because it's been running in production for a while.\nfunction navigateReducer_noPPR(\n  state: ReadonlyReducerState,\n  action: NavigateAction\n): ReducerState {\n  const { url, isExternalUrl, navigateType, shouldScroll } = action\n  const mutable: Mutable = {}\n  const { hash } = url\n  const href = createHrefFromUrl(url)\n  const pendingPush = navigateType === 'push'\n  // we want to prune the prefetch cache on every navigation to avoid it growing too large\n  prunePrefetchCache(state.prefetchCache)\n\n  mutable.preserveCustomHistoryState = false\n\n  if (isExternalUrl) {\n    return handleExternalUrl(state, mutable, url.toString(), pendingPush)\n  }\n\n  const prefetchValues = getOrCreatePrefetchCacheEntry({\n    url,\n    nextUrl: state.nextUrl,\n    tree: state.tree,\n    buildId: state.buildId,\n    prefetchCache: state.prefetchCache,\n  })\n  const { treeAtTimeOfPrefetch, data } = prefetchValues\n\n  prefetchQueue.bump(data)\n\n  return data.then(\n    ([flightData, canonicalUrlOverride]) => {\n      let isFirstRead = false\n      // we only want to mark this once\n      if (!prefetchValues.lastUsedTime) {\n        // important: we should only mark the cache node as dirty after we unsuspend from the call above\n        prefetchValues.lastUsedTime = Date.now()\n        isFirstRead = true\n      }\n\n      // Handle case when navigating to page in `pages` from `app`\n      if (typeof flightData === 'string') {\n        return handleExternalUrl(state, mutable, flightData, pendingPush)\n      }\n\n      // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n      // which will trigger an MPA navigation.\n      if (document.getElementById('__next-page-redirect')) {\n        return handleExternalUrl(state, mutable, href, pendingPush)\n      }\n\n      let currentTree = state.tree\n      const currentCache = state.cache\n      let scrollableSegments: FlightSegmentPath[] = []\n      for (const flightDataPath of flightData) {\n        const flightSegmentPath = flightDataPath.slice(\n          0,\n          -4\n        ) as unknown as FlightSegmentPath\n        // The one before last item is the router state tree patch\n        const treePatch = flightDataPath.slice(-3)[0] as FlightRouterState\n\n        // TODO-APP: remove ''\n        const flightSegmentPathWithLeadingEmpty = ['', ...flightSegmentPath]\n\n        // Create new tree based on the flightSegmentPath and router state patch\n        let newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          flightSegmentPathWithLeadingEmpty,\n          currentTree,\n          treePatch,\n          href\n        )\n\n        // If the tree patch can't be applied to the current tree then we use the tree at time of prefetch\n        // TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.\n        if (newTree === null) {\n          newTree = applyRouterStatePatchToTree(\n            // TODO-APP: remove ''\n            flightSegmentPathWithLeadingEmpty,\n            treeAtTimeOfPrefetch,\n            treePatch,\n            href\n          )\n        }\n\n        if (newTree !== null) {\n          if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n            return handleExternalUrl(state, mutable, href, pendingPush)\n          }\n\n          const cache: CacheNode = createEmptyCacheNode()\n          let applied = false\n\n          if (\n            prefetchValues.status === PrefetchCacheEntryStatus.stale &&\n            !isFirstRead\n          ) {\n            // When we have a stale prefetch entry, we only want to re-use the loading state of the route we're navigating to, to support instant loading navigations\n            // this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,\n            // while copying over the `loading` for the segment that contains the page data.\n            // We only do this on subsequent reads, as otherwise there'd be no loading data to re-use.\n            applied = triggerLazyFetchForLeafSegments(\n              cache,\n              currentCache,\n              flightSegmentPath,\n              treePatch\n            )\n            // since we re-used the stale cache's loading state & refreshed the data,\n            // update the `lastUsedTime` so that it can continue to be re-used for the next 30s\n            prefetchValues.lastUsedTime = Date.now()\n          } else {\n            applied = applyFlightData(\n              currentCache,\n              cache,\n              flightDataPath,\n              prefetchValues\n            )\n          }\n\n          const hardNavigate = shouldHardNavigate(\n            // TODO-APP: remove ''\n            flightSegmentPathWithLeadingEmpty,\n            currentTree\n          )\n\n          if (hardNavigate) {\n            // Copy rsc for the root node of the cache.\n            cache.rsc = currentCache.rsc\n            cache.prefetchRsc = currentCache.prefetchRsc\n\n            invalidateCacheBelowFlightSegmentPath(\n              cache,\n              currentCache,\n              flightSegmentPath\n            )\n            // Ensure the existing cache value is used when the cache was not invalidated.\n            mutable.cache = cache\n          } else if (applied) {\n            mutable.cache = cache\n          }\n\n          currentTree = newTree\n\n          for (const subSegment of generateSegmentsFromPatch(treePatch)) {\n            const scrollableSegmentPath = [...flightSegmentPath, ...subSegment]\n            // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.\n            if (\n              scrollableSegmentPath[scrollableSegmentPath.length - 1] !==\n              DEFAULT_SEGMENT_KEY\n            ) {\n              scrollableSegments.push(scrollableSegmentPath)\n            }\n          }\n        }\n      }\n\n      mutable.patchedTree = currentTree\n      mutable.canonicalUrl = canonicalUrlOverride\n        ? createHrefFromUrl(canonicalUrlOverride)\n        : href\n      mutable.pendingPush = pendingPush\n      mutable.scrollableSegments = scrollableSegments\n      mutable.hashFragment = hash\n      mutable.shouldScroll = shouldScroll\n\n      return handleMutable(state, mutable)\n    },\n    () => state\n  )\n}\n\n// This is the experimental PPR implementation. It's closer to the behavior we\n// want, but is likelier to include accidental regressions because it rewrites\n// existing functionality.\nfunction navigateReducer_PPR(\n  state: ReadonlyReducerState,\n  action: NavigateAction\n): ReducerState {\n  const { url, isExternalUrl, navigateType, shouldScroll } = action\n  const mutable: Mutable = {}\n  const { hash } = url\n  const href = createHrefFromUrl(url)\n  const pendingPush = navigateType === 'push'\n  // we want to prune the prefetch cache on every navigation to avoid it growing too large\n  prunePrefetchCache(state.prefetchCache)\n\n  mutable.preserveCustomHistoryState = false\n\n  if (isExternalUrl) {\n    return handleExternalUrl(state, mutable, url.toString(), pendingPush)\n  }\n\n  const prefetchValues = getOrCreatePrefetchCacheEntry({\n    url,\n    nextUrl: state.nextUrl,\n    tree: state.tree,\n    buildId: state.buildId,\n    prefetchCache: state.prefetchCache,\n  })\n  const { treeAtTimeOfPrefetch, data } = prefetchValues\n\n  prefetchQueue.bump(data)\n\n  return data.then(\n    ([flightData, canonicalUrlOverride, _postponed]) => {\n      let isFirstRead = false\n      // we only want to mark this once\n      if (!prefetchValues.lastUsedTime) {\n        // important: we should only mark the cache node as dirty after we unsuspend from the call above\n        prefetchValues.lastUsedTime = Date.now()\n        isFirstRead = true\n      }\n\n      // Handle case when navigating to page in `pages` from `app`\n      if (typeof flightData === 'string') {\n        return handleExternalUrl(state, mutable, flightData, pendingPush)\n      }\n\n      // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n      // which will trigger an MPA navigation.\n      if (document.getElementById('__next-page-redirect')) {\n        return handleExternalUrl(state, mutable, href, pendingPush)\n      }\n\n      let currentTree = state.tree\n      const currentCache = state.cache\n      let scrollableSegments: FlightSegmentPath[] = []\n      // TODO: In practice, this is always a single item array. We probably\n      // aren't going to every send multiple segments, at least not in this\n      // format. So we could remove the extra wrapper for now until\n      // that settles.\n      for (const flightDataPath of flightData) {\n        const flightSegmentPath = flightDataPath.slice(\n          0,\n          -4\n        ) as unknown as FlightSegmentPath\n        // The one before last item is the router state tree patch\n        const treePatch = flightDataPath.slice(-3)[0] as FlightRouterState\n\n        // TODO-APP: remove ''\n        const flightSegmentPathWithLeadingEmpty = ['', ...flightSegmentPath]\n\n        // Create new tree based on the flightSegmentPath and router state patch\n        let newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          flightSegmentPathWithLeadingEmpty,\n          currentTree,\n          treePatch,\n          href\n        )\n\n        // If the tree patch can't be applied to the current tree then we use the tree at time of prefetch\n        // TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.\n        if (newTree === null) {\n          newTree = applyRouterStatePatchToTree(\n            // TODO-APP: remove ''\n            flightSegmentPathWithLeadingEmpty,\n            treeAtTimeOfPrefetch,\n            treePatch,\n            href\n          )\n        }\n\n        if (newTree !== null) {\n          if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n            return handleExternalUrl(state, mutable, href, pendingPush)\n          }\n\n          if (\n            // This is just a paranoid check. When PPR is enabled, the server\n            // will always send back a static response that's rendered from\n            // the root. If for some reason it doesn't, we fall back to the\n            // non-PPR implementation.\n            // TODO: We should get rid of the else branch and do all navigations\n            // via updateCacheNodeOnNavigation. The current structure is just\n            // an incremental step.\n            flightDataPath.length === 3\n          ) {\n            const prefetchedTree: FlightRouterState = flightDataPath[0]\n            const seedData = flightDataPath[1]\n            const head = flightDataPath[2]\n\n            const task = updateCacheNodeOnNavigation(\n              currentCache,\n              currentTree,\n              prefetchedTree,\n              seedData,\n              head\n            )\n            if (task !== null && task.node !== null) {\n              // We've created a new Cache Node tree that contains a prefetched\n              // version of the next page. This can be rendered instantly.\n\n              // Use the tree computed by updateCacheNodeOnNavigation instead\n              // of the one computed by applyRouterStatePatchToTree.\n              // TODO: We should remove applyRouterStatePatchToTree\n              // from the PPR path entirely.\n              const patchedRouterState: FlightRouterState = task.route\n              newTree = patchedRouterState\n\n              const newCache = task.node\n\n              // The prefetched tree has dynamic holes in it. We initiate a\n              // dynamic request to fill them in.\n              //\n              // Do not block on the result. We'll immediately render the Cache\n              // Node tree and suspend on the dynamic parts. When the request\n              // comes in, we'll fill in missing data and ping React to\n              // re-render. Unlike the lazy fetching model in the non-PPR\n              // implementation, this is modeled as a single React update +\n              // streaming, rather than multiple top-level updates. (However,\n              // even in the new model, we'll still need to sometimes update the\n              // root multiple times per navigation, like if the server sends us\n              // a different response than we expected. For now, we revert back\n              // to the lazy fetching mechanism in that case.)\n              listenForDynamicRequest(\n                task,\n                fetchServerResponse(\n                  url,\n                  currentTree,\n                  state.nextUrl,\n                  state.buildId\n                )\n              )\n\n              mutable.cache = newCache\n            } else {\n              // Nothing changed, so reuse the old cache.\n              // TODO: What if the head changed but not any of the segment data?\n              // Is that possible? If so, we should clone the whole tree and\n              // update the head.\n              newTree = prefetchedTree\n            }\n          } else {\n            // The static response does not include any dynamic holes, so\n            // there's no need to do a second request.\n            // TODO: As an incremental step this just reverts back to the\n            // non-PPR implementation. We can simplify this branch further,\n            // given that PPR prefetches are always static and return the whole\n            // tree. Or in the meantime we could factor it out into a\n            // separate function.\n            const cache: CacheNode = createEmptyCacheNode()\n            let applied = false\n\n            if (\n              prefetchValues.status === PrefetchCacheEntryStatus.stale &&\n              !isFirstRead\n            ) {\n              // When we have a stale prefetch entry, we only want to re-use the loading state of the route we're navigating to, to support instant loading navigations\n              // this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,\n              // while copying over the `loading` for the segment that contains the page data.\n              // We only do this on subsequent reads, as otherwise there'd be no loading data to re-use.\n              applied = triggerLazyFetchForLeafSegments(\n                cache,\n                currentCache,\n                flightSegmentPath,\n                treePatch\n              )\n              // since we re-used the stale cache's loading state & refreshed the data,\n              // update the `lastUsedTime` so that it can continue to be re-used for the next 30s\n              prefetchValues.lastUsedTime = Date.now()\n            } else {\n              applied = applyFlightData(\n                currentCache,\n                cache,\n                flightDataPath,\n                prefetchValues\n              )\n            }\n\n            const hardNavigate = shouldHardNavigate(\n              // TODO-APP: remove ''\n              flightSegmentPathWithLeadingEmpty,\n              currentTree\n            )\n\n            if (hardNavigate) {\n              // Copy rsc for the root node of the cache.\n              cache.rsc = currentCache.rsc\n              cache.prefetchRsc = currentCache.prefetchRsc\n\n              invalidateCacheBelowFlightSegmentPath(\n                cache,\n                currentCache,\n                flightSegmentPath\n              )\n              // Ensure the existing cache value is used when the cache was not invalidated.\n              mutable.cache = cache\n            } else if (applied) {\n              mutable.cache = cache\n            }\n          }\n\n          currentTree = newTree\n\n          for (const subSegment of generateSegmentsFromPatch(treePatch)) {\n            const scrollableSegmentPath = [...flightSegmentPath, ...subSegment]\n            // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.\n            if (\n              scrollableSegmentPath[scrollableSegmentPath.length - 1] !==\n              DEFAULT_SEGMENT_KEY\n            ) {\n              scrollableSegments.push(scrollableSegmentPath)\n            }\n          }\n        }\n      }\n\n      mutable.patchedTree = currentTree\n      mutable.canonicalUrl = canonicalUrlOverride\n        ? createHrefFromUrl(canonicalUrlOverride)\n        : href\n      mutable.pendingPush = pendingPush\n      mutable.scrollableSegments = scrollableSegments\n      mutable.hashFragment = hash\n      mutable.shouldScroll = shouldScroll\n\n      return handleMutable(state, mutable)\n    },\n    () => state\n  )\n}\n"],"names":["handleExternalUrl","navigateReducer","state","mutable","url","pendingPush","mpaNavigation","canonicalUrl","scrollableSegments","undefined","handleMutable","generateSegmentsFromPatch","flightRouterPatch","segments","segment","parallelRoutes","Object","keys","length","parallelRouteKey","parallelRoute","entries","childSegment","push","triggerLazyFetchForLeafSegments","newCache","currentCache","flightSegmentPath","treePatch","appliedPatch","rsc","prefetchRsc","loading","Map","segmentPathsToFill","map","segmentPaths","clearCacheNodeDataForSegmentPath","process","env","__NEXT_PPR","navigateReducer_PPR","navigateReducer_noPPR","action","isExternalUrl","navigateType","shouldScroll","hash","href","createHrefFromUrl","prunePrefetchCache","prefetchCache","preserveCustomHistoryState","toString","prefetchValues","getOrCreatePrefetchCacheEntry","nextUrl","tree","buildId","treeAtTimeOfPrefetch","data","prefetchQueue","bump","then","flightData","canonicalUrlOverride","isFirstRead","lastUsedTime","Date","now","document","getElementById","currentTree","cache","flightDataPath","slice","flightSegmentPathWithLeadingEmpty","newTree","applyRouterStatePatchToTree","isNavigatingToNewRootLayout","createEmptyCacheNode","applied","status","PrefetchCacheEntryStatus","stale","applyFlightData","hardNavigate","shouldHardNavigate","invalidateCacheBelowFlightSegmentPath","subSegment","scrollableSegmentPath","DEFAULT_SEGMENT_KEY","patchedTree","hashFragment","_postponed","prefetchedTree","seedData","head","task","updateCacheNodeOnNavigation","node","patchedRouterState","route","listenForDynamicRequest","fetchServerResponse"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}