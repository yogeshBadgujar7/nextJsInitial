{"version":3,"sources":["../../../../src/server/lib/server-ipc/index.ts"],"sourcesContent":["import type NextServer from '../../next-server'\nimport { errorToJSON } from '../../render'\nimport crypto from 'crypto'\nimport isError from '../../../lib/is-error'\nimport { deserializeErr } from './request-utils'\n\n// we can't use process.send as jest-worker relies on\n// it already and can cause unexpected message errors\n// so we create an IPC server for communicating\nexport async function createIpcServer(\n  server: InstanceType<typeof NextServer>\n): Promise<{\n  ipcPort: number\n  ipcServer: import('http').Server\n  ipcValidationKey: string\n}> {\n  // Generate a random key in memory to validate messages from other processes.\n  // This is just a simple guard against other processes attempting to send\n  // traffic to the IPC server.\n  const ipcValidationKey = crypto.randomBytes(32).toString('hex')\n\n  const ipcServer = (require('http') as typeof import('http')).createServer(\n    async (req, res) => {\n      try {\n        const url = new URL(req.url || '/', 'http://n')\n        const key = url.searchParams.get('key')\n\n        if (key !== ipcValidationKey) {\n          return res.end()\n        }\n\n        const method = url.searchParams.get('method')\n        let body = await new Promise<string>((resolve, reject) => {\n          let str = ''\n          req.on('data', (chunk) => {\n            str += chunk\n          })\n          req.on('end', () => {\n            resolve(str)\n          })\n          req.on('error', (err) => {\n            reject(err)\n          })\n          res.on('close', function () {\n            let aborted = !res.writableFinished\n            if (aborted) {\n              reject(new Error('ipc request aborted'))\n            }\n          })\n        })\n        const args: any[] = JSON.parse(body || '[]')\n\n        if (!method || !Array.isArray(args)) {\n          return res.end()\n        }\n\n        if (typeof (server as any)[method] === 'function') {\n          if (method === 'logErrorWithOriginalStack' && args[0]?.stack) {\n            args[0] = deserializeErr(args[0])\n          }\n          let result = await (server as any)[method](...args)\n\n          if (result && typeof result === 'object' && result.stack) {\n            result = errorToJSON(result)\n          }\n          res.end(JSON.stringify(result || ''))\n        }\n      } catch (err: any) {\n        if (isError(err) && err.code !== 'ENOENT') {\n          console.error(err)\n        }\n        res.end(\n          JSON.stringify({\n            err: { name: err.name, message: err.message, stack: err.stack },\n          })\n        )\n      }\n    }\n  )\n\n  const ipcPort = await new Promise<number>((resolveIpc) => {\n    ipcServer.listen(0, server.hostname, () => {\n      const addr = ipcServer.address()\n\n      if (addr && typeof addr === 'object') {\n        resolveIpc(addr.port)\n      }\n    })\n  })\n\n  return {\n    ipcPort,\n    ipcServer,\n    ipcValidationKey,\n  }\n}\n"],"names":["errorToJSON","crypto","isError","deserializeErr","createIpcServer","server","ipcValidationKey","randomBytes","toString","ipcServer","require","createServer","req","res","url","URL","key","searchParams","get","end","method","body","Promise","resolve","reject","str","on","chunk","err","aborted","writableFinished","Error","args","JSON","parse","Array","isArray","stack","result","stringify","code","console","error","name","message","ipcPort","resolveIpc","listen","hostname","addr","address","port"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"AACA,SAASA,WAAW,QAAQ,eAAc;AAC1C,OAAOC,YAAY,SAAQ;AAC3B,OAAOC,aAAa,wBAAuB;AAC3C,SAASC,cAAc,QAAQ,kBAAiB;AAEhD,qDAAqD;AACrD,qDAAqD;AACrD,+CAA+C;AAC/C,OAAO,eAAeC,gBACpBC,MAAuC;IAMvC,6EAA6E;IAC7E,yEAAyE;IACzE,6BAA6B;IAC7B,MAAMC,mBAAmBL,OAAOM,WAAW,CAAC,IAAIC,QAAQ,CAAC;IAEzD,MAAMC,YAAY,AAACC,QAAQ,QAAkCC,YAAY,CACvE,OAAOC,KAAKC;QACV,IAAI;YACF,MAAMC,MAAM,IAAIC,IAAIH,IAAIE,GAAG,IAAI,KAAK;YACpC,MAAME,MAAMF,IAAIG,YAAY,CAACC,GAAG,CAAC;YAEjC,IAAIF,QAAQV,kBAAkB;gBAC5B,OAAOO,IAAIM,GAAG;YAChB;YAEA,MAAMC,SAASN,IAAIG,YAAY,CAACC,GAAG,CAAC;YACpC,IAAIG,OAAO,MAAM,IAAIC,QAAgB,CAACC,SAASC;gBAC7C,IAAIC,MAAM;gBACVb,IAAIc,EAAE,CAAC,QAAQ,CAACC;oBACdF,OAAOE;gBACT;gBACAf,IAAIc,EAAE,CAAC,OAAO;oBACZH,QAAQE;gBACV;gBACAb,IAAIc,EAAE,CAAC,SAAS,CAACE;oBACfJ,OAAOI;gBACT;gBACAf,IAAIa,EAAE,CAAC,SAAS;oBACd,IAAIG,UAAU,CAAChB,IAAIiB,gBAAgB;oBACnC,IAAID,SAAS;wBACXL,OAAO,IAAIO,MAAM;oBACnB;gBACF;YACF;YACA,MAAMC,OAAcC,KAAKC,KAAK,CAACb,QAAQ;YAEvC,IAAI,CAACD,UAAU,CAACe,MAAMC,OAAO,CAACJ,OAAO;gBACnC,OAAOnB,IAAIM,GAAG;YAChB;YAEA,IAAI,OAAO,AAACd,MAAc,CAACe,OAAO,KAAK,YAAY;oBACHY;gBAA9C,IAAIZ,WAAW,iCAA+BY,SAAAA,IAAI,CAAC,EAAE,qBAAPA,OAASK,KAAK,GAAE;oBAC5DL,IAAI,CAAC,EAAE,GAAG7B,eAAe6B,IAAI,CAAC,EAAE;gBAClC;gBACA,IAAIM,SAAS,MAAM,AAACjC,MAAc,CAACe,OAAO,IAAIY;gBAE9C,IAAIM,UAAU,OAAOA,WAAW,YAAYA,OAAOD,KAAK,EAAE;oBACxDC,SAAStC,YAAYsC;gBACvB;gBACAzB,IAAIM,GAAG,CAACc,KAAKM,SAAS,CAACD,UAAU;YACnC;QACF,EAAE,OAAOV,KAAU;YACjB,IAAI1B,QAAQ0B,QAAQA,IAAIY,IAAI,KAAK,UAAU;gBACzCC,QAAQC,KAAK,CAACd;YAChB;YACAf,IAAIM,GAAG,CACLc,KAAKM,SAAS,CAAC;gBACbX,KAAK;oBAAEe,MAAMf,IAAIe,IAAI;oBAAEC,SAAShB,IAAIgB,OAAO;oBAAEP,OAAOT,IAAIS,KAAK;gBAAC;YAChE;QAEJ;IACF;IAGF,MAAMQ,UAAU,MAAM,IAAIvB,QAAgB,CAACwB;QACzCrC,UAAUsC,MAAM,CAAC,GAAG1C,OAAO2C,QAAQ,EAAE;YACnC,MAAMC,OAAOxC,UAAUyC,OAAO;YAE9B,IAAID,QAAQ,OAAOA,SAAS,UAAU;gBACpCH,WAAWG,KAAKE,IAAI;YACtB;QACF;IACF;IAEA,OAAO;QACLN;QACApC;QACAH;IACF;AACF"}