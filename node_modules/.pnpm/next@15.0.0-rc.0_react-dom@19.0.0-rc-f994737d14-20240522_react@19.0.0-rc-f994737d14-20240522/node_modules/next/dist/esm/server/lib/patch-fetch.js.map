{"version":3,"sources":["../../../src/server/lib/patch-fetch.ts"],"sourcesContent":["import type {\n  StaticGenerationAsyncStorage,\n  StaticGenerationStore,\n} from '../../client/components/static-generation-async-storage.external'\nimport type * as ServerHooks from '../../client/components/hooks-server-context'\n\nimport { AppRenderSpan, NextNodeServerSpan } from './trace/constants'\nimport { getTracer, SpanKind } from './trace/tracer'\nimport {\n  CACHE_ONE_YEAR,\n  NEXT_CACHE_IMPLICIT_TAG_ID,\n  NEXT_CACHE_TAG_MAX_ITEMS,\n  NEXT_CACHE_TAG_MAX_LENGTH,\n} from '../../lib/constants'\nimport * as Log from '../../build/output/log'\nimport { trackDynamicFetch } from '../app-render/dynamic-rendering'\nimport type { FetchMetric } from '../base-http'\n\nconst isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n\ntype Fetcher = typeof fetch\n\ntype PatchedFetcher = Fetcher & {\n  readonly __nextPatched: true\n  readonly __nextGetStaticStore: () => StaticGenerationAsyncStorage\n  readonly _nextOriginalFetch: Fetcher\n}\n\nfunction isPatchedFetch(\n  fetch: Fetcher | PatchedFetcher\n): fetch is PatchedFetcher {\n  return '__nextPatched' in fetch && fetch.__nextPatched === true\n}\n\nexport function validateRevalidate(\n  revalidateVal: unknown,\n  pathname: string\n): undefined | number | false {\n  try {\n    let normalizedRevalidate: false | number | undefined = undefined\n\n    if (revalidateVal === false) {\n      normalizedRevalidate = revalidateVal\n    } else if (\n      typeof revalidateVal === 'number' &&\n      !isNaN(revalidateVal) &&\n      revalidateVal > -1\n    ) {\n      normalizedRevalidate = revalidateVal\n    } else if (typeof revalidateVal !== 'undefined') {\n      throw new Error(\n        `Invalid revalidate value \"${revalidateVal}\" on \"${pathname}\", must be a non-negative number or \"false\"`\n      )\n    }\n    return normalizedRevalidate\n  } catch (err: any) {\n    // handle client component error from attempting to check revalidate value\n    if (err instanceof Error && err.message.includes('Invalid revalidate')) {\n      throw err\n    }\n    return undefined\n  }\n}\n\nexport function validateTags(tags: any[], description: string) {\n  const validTags: string[] = []\n  const invalidTags: Array<{\n    tag: any\n    reason: string\n  }> = []\n\n  for (let i = 0; i < tags.length; i++) {\n    const tag = tags[i]\n\n    if (typeof tag !== 'string') {\n      invalidTags.push({ tag, reason: 'invalid type, must be a string' })\n    } else if (tag.length > NEXT_CACHE_TAG_MAX_LENGTH) {\n      invalidTags.push({\n        tag,\n        reason: `exceeded max length of ${NEXT_CACHE_TAG_MAX_LENGTH}`,\n      })\n    } else {\n      validTags.push(tag)\n    }\n\n    if (validTags.length > NEXT_CACHE_TAG_MAX_ITEMS) {\n      console.warn(\n        `Warning: exceeded max tag count for ${description}, dropped tags:`,\n        tags.slice(i).join(', ')\n      )\n      break\n    }\n  }\n\n  if (invalidTags.length > 0) {\n    console.warn(`Warning: invalid tags passed to ${description}: `)\n\n    for (const { tag, reason } of invalidTags) {\n      console.log(`tag: \"${tag}\" ${reason}`)\n    }\n  }\n  return validTags\n}\n\nconst getDerivedTags = (pathname: string): string[] => {\n  const derivedTags: string[] = [`/layout`]\n\n  // we automatically add the current path segments as tags\n  // for revalidatePath handling\n  if (pathname.startsWith('/')) {\n    const pathnameParts = pathname.split('/')\n\n    for (let i = 1; i < pathnameParts.length + 1; i++) {\n      let curPathname = pathnameParts.slice(0, i).join('/')\n\n      if (curPathname) {\n        // all derived tags other than the page are layout tags\n        if (!curPathname.endsWith('/page') && !curPathname.endsWith('/route')) {\n          curPathname = `${curPathname}${\n            !curPathname.endsWith('/') ? '/' : ''\n          }layout`\n        }\n        derivedTags.push(curPathname)\n      }\n    }\n  }\n  return derivedTags\n}\n\nexport function addImplicitTags(staticGenerationStore: StaticGenerationStore) {\n  const newTags: string[] = []\n  const { pagePath, urlPathname } = staticGenerationStore\n\n  if (!Array.isArray(staticGenerationStore.tags)) {\n    staticGenerationStore.tags = []\n  }\n\n  if (pagePath) {\n    const derivedTags = getDerivedTags(pagePath)\n\n    for (let tag of derivedTags) {\n      tag = `${NEXT_CACHE_IMPLICIT_TAG_ID}${tag}`\n      if (!staticGenerationStore.tags?.includes(tag)) {\n        staticGenerationStore.tags.push(tag)\n      }\n      newTags.push(tag)\n    }\n  }\n\n  if (urlPathname) {\n    const parsedPathname = new URL(urlPathname, 'http://n').pathname\n\n    const tag = `${NEXT_CACHE_IMPLICIT_TAG_ID}${parsedPathname}`\n    if (!staticGenerationStore.tags?.includes(tag)) {\n      staticGenerationStore.tags.push(tag)\n    }\n    newTags.push(tag)\n  }\n  return newTags\n}\n\nfunction trackFetchMetric(\n  staticGenerationStore: StaticGenerationStore,\n  ctx: Omit<FetchMetric, 'end' | 'idx'>\n) {\n  if (\n    !staticGenerationStore ||\n    staticGenerationStore.requestEndedState?.ended ||\n    process.env.NODE_ENV !== 'development'\n  ) {\n    return\n  }\n  staticGenerationStore.fetchMetrics ??= []\n\n  const dedupeFields = ['url', 'status', 'method'] as const\n\n  // don't add metric if one already exists for the fetch\n  if (\n    staticGenerationStore.fetchMetrics.some((metric) =>\n      dedupeFields.every((field) => metric[field] === ctx[field])\n    )\n  ) {\n    return\n  }\n  staticGenerationStore.fetchMetrics.push({\n    ...ctx,\n    end: Date.now(),\n    idx: staticGenerationStore.nextFetchId || 0,\n  })\n\n  // only store top 10 metrics to avoid storing too many\n  if (staticGenerationStore.fetchMetrics.length > 10) {\n    // sort slowest first as these should be highlighted\n    staticGenerationStore.fetchMetrics.sort((a, b) => {\n      const aDur = a.end - a.start\n      const bDur = b.end - b.start\n\n      if (aDur < bDur) {\n        return 1\n      } else if (aDur > bDur) {\n        return -1\n      }\n      return 0\n    })\n    // now grab top 10\n    staticGenerationStore.fetchMetrics =\n      staticGenerationStore.fetchMetrics.slice(0, 10)\n  }\n}\n\ninterface PatchableModule {\n  serverHooks: typeof ServerHooks\n  staticGenerationAsyncStorage: StaticGenerationAsyncStorage\n}\n\nfunction createPatchedFetcher(\n  originFetch: Fetcher,\n  {\n    serverHooks: { DynamicServerError },\n    staticGenerationAsyncStorage,\n  }: PatchableModule\n): PatchedFetcher {\n  // Create the patched fetch function. We don't set the type here, as it's\n  // verified as the return value of this function.\n  const patched = async (\n    input: RequestInfo | URL,\n    init: RequestInit | undefined\n  ) => {\n    let url: URL | undefined\n    try {\n      url = new URL(input instanceof Request ? input.url : input)\n      url.username = ''\n      url.password = ''\n    } catch {\n      // Error caused by malformed URL should be handled by native fetch\n      url = undefined\n    }\n    const fetchUrl = url?.href ?? ''\n    const fetchStart = Date.now()\n    const method = init?.method?.toUpperCase() || 'GET'\n\n    // Do create a new span trace for internal fetches in the\n    // non-verbose mode.\n    const isInternal = (init?.next as any)?.internal === true\n    const hideSpan = process.env.NEXT_OTEL_FETCH_DISABLED === '1'\n\n    return getTracer().trace(\n      isInternal ? NextNodeServerSpan.internalFetch : AppRenderSpan.fetch,\n      {\n        hideSpan,\n        kind: SpanKind.CLIENT,\n        spanName: ['fetch', method, fetchUrl].filter(Boolean).join(' '),\n        attributes: {\n          'http.url': fetchUrl,\n          'http.method': method,\n          'net.peer.name': url?.hostname,\n          'net.peer.port': url?.port || undefined,\n        },\n      },\n      async () => {\n        // If this is an internal fetch, we should not do any special treatment.\n        if (isInternal) {\n          return originFetch(input, init)\n        }\n\n        const staticGenerationStore = staticGenerationAsyncStorage.getStore()\n\n        // If the staticGenerationStore is not available, we can't do any\n        // special treatment of fetch, therefore fallback to the original\n        // fetch implementation.\n        if (!staticGenerationStore) {\n          return originFetch(input, init)\n        }\n\n        // We should also fallback to the original fetch implementation if we\n        // are in draft mode, it does not constitute a static generation.\n        if (staticGenerationStore.isDraftMode) {\n          return originFetch(input, init)\n        }\n\n        const isRequestInput =\n          input &&\n          typeof input === 'object' &&\n          typeof (input as Request).method === 'string'\n\n        const getRequestMeta = (field: string) => {\n          // If request input is present but init is not, retrieve from input first.\n          const value = (init as any)?.[field]\n          return value || (isRequestInput ? (input as any)[field] : null)\n        }\n\n        let finalRevalidate: number | undefined | false = undefined\n        const getNextField = (field: 'revalidate' | 'tags') => {\n          return typeof init?.next?.[field] !== 'undefined'\n            ? init?.next?.[field]\n            : isRequestInput\n              ? (input as any).next?.[field]\n              : undefined\n        }\n        // RequestInit doesn't keep extra fields e.g. next so it's\n        // only available if init is used separate\n        let currentFetchRevalidate = getNextField('revalidate')\n        const tags: string[] = validateTags(\n          getNextField('tags') || [],\n          `fetch ${input.toString()}`\n        )\n\n        if (Array.isArray(tags)) {\n          if (!staticGenerationStore.tags) {\n            staticGenerationStore.tags = []\n          }\n          for (const tag of tags) {\n            if (!staticGenerationStore.tags.includes(tag)) {\n              staticGenerationStore.tags.push(tag)\n            }\n          }\n        }\n        const implicitTags = addImplicitTags(staticGenerationStore)\n\n        const pageFetchCacheMode = staticGenerationStore.fetchCache\n        const isUsingNoStore = !!staticGenerationStore.isUnstableNoStore\n\n        let currentFetchCacheConfig = getRequestMeta('cache')\n        let cacheReason = ''\n\n        if (\n          typeof currentFetchCacheConfig === 'string' &&\n          typeof currentFetchRevalidate !== 'undefined'\n        ) {\n          // when providing fetch with a Request input, it'll automatically set a cache value of 'default'\n          // we only want to warn if the user is explicitly setting a cache value\n          if (!(isRequestInput && currentFetchCacheConfig === 'default')) {\n            Log.warn(\n              `fetch for ${fetchUrl} on ${staticGenerationStore.urlPathname} specified \"cache: ${currentFetchCacheConfig}\" and \"revalidate: ${currentFetchRevalidate}\", only one should be specified.`\n            )\n          }\n          currentFetchCacheConfig = undefined\n        }\n\n        if (currentFetchCacheConfig === 'force-cache') {\n          currentFetchRevalidate = false\n        } else if (\n          currentFetchCacheConfig === 'no-cache' ||\n          currentFetchCacheConfig === 'no-store' ||\n          pageFetchCacheMode === 'force-no-store' ||\n          pageFetchCacheMode === 'only-no-store' ||\n          // If no explicit fetch cache mode is set, but dynamic = `force-dynamic` is set,\n          // we shouldn't consider caching the fetch. This is because the `dynamic` cache\n          // is considered a \"top-level\" cache mode, whereas something like `fetchCache` is more\n          // fine-grained. Top-level modes are responsible for setting reasonable defaults for the\n          // other configurations.\n          (!pageFetchCacheMode && staticGenerationStore.forceDynamic)\n        ) {\n          currentFetchRevalidate = 0\n        }\n\n        if (\n          currentFetchCacheConfig === 'no-cache' ||\n          currentFetchCacheConfig === 'no-store'\n        ) {\n          cacheReason = `cache: ${currentFetchCacheConfig}`\n        }\n\n        finalRevalidate = validateRevalidate(\n          currentFetchRevalidate,\n          staticGenerationStore.urlPathname\n        )\n\n        const _headers = getRequestMeta('headers')\n        const initHeaders: Headers =\n          typeof _headers?.get === 'function'\n            ? _headers\n            : new Headers(_headers || {})\n\n        const hasUnCacheableHeader =\n          initHeaders.get('authorization') || initHeaders.get('cookie')\n\n        const isUnCacheableMethod = !['get', 'head'].includes(\n          getRequestMeta('method')?.toLowerCase() || 'get'\n        )\n\n        // if there are authorized headers or a POST method and\n        // dynamic data usage was present above the tree we bail\n        // e.g. if cookies() is used before an authed/POST fetch\n        // or no user provided fetch cache config or revalidate\n        // is provided we don't cache\n        const autoNoCache =\n          // this condition is hit for null/undefined\n          // eslint-disable-next-line eqeqeq\n          (pageFetchCacheMode == undefined &&\n            // eslint-disable-next-line eqeqeq\n            currentFetchCacheConfig == undefined &&\n            // eslint-disable-next-line eqeqeq\n            currentFetchRevalidate == undefined) ||\n          ((hasUnCacheableHeader || isUnCacheableMethod) &&\n            staticGenerationStore.revalidate === 0)\n\n        switch (pageFetchCacheMode) {\n          case 'force-no-store': {\n            cacheReason = 'fetchCache = force-no-store'\n            break\n          }\n          case 'only-no-store': {\n            if (\n              currentFetchCacheConfig === 'force-cache' ||\n              (typeof finalRevalidate !== 'undefined' &&\n                (finalRevalidate === false || finalRevalidate > 0))\n            ) {\n              throw new Error(\n                `cache: 'force-cache' used on fetch for ${fetchUrl} with 'export const fetchCache = 'only-no-store'`\n              )\n            }\n            cacheReason = 'fetchCache = only-no-store'\n            break\n          }\n          case 'only-cache': {\n            if (currentFetchCacheConfig === 'no-store') {\n              throw new Error(\n                `cache: 'no-store' used on fetch for ${fetchUrl} with 'export const fetchCache = 'only-cache'`\n              )\n            }\n            break\n          }\n          case 'force-cache': {\n            if (\n              typeof currentFetchRevalidate === 'undefined' ||\n              currentFetchRevalidate === 0\n            ) {\n              cacheReason = 'fetchCache = force-cache'\n              finalRevalidate = false\n            }\n            break\n          }\n          default:\n          // sometimes we won't match the above cases. the reason we don't move\n          // everything to this switch is the use of autoNoCache which is not a fetchCacheMode\n          // I suspect this could be unified with fetchCacheMode however in which case we could\n          // simplify the switch case and ensure we have an exhaustive switch handling all modes\n        }\n\n        if (typeof finalRevalidate === 'undefined') {\n          if (pageFetchCacheMode === 'default-cache' && !isUsingNoStore) {\n            finalRevalidate = false\n            cacheReason = 'fetchCache = default-cache'\n          } else if (pageFetchCacheMode === 'default-no-store') {\n            finalRevalidate = 0\n            cacheReason = 'fetchCache = default-no-store'\n          } else if (isUsingNoStore) {\n            finalRevalidate = 0\n            cacheReason = 'noStore call'\n          } else if (autoNoCache) {\n            finalRevalidate = 0\n            cacheReason = 'auto no cache'\n          } else {\n            // TODO: should we consider this case an invariant?\n            cacheReason = 'auto cache'\n            finalRevalidate =\n              typeof staticGenerationStore.revalidate === 'boolean' ||\n              typeof staticGenerationStore.revalidate === 'undefined'\n                ? false\n                : staticGenerationStore.revalidate\n          }\n        } else if (!cacheReason) {\n          cacheReason = `revalidate: ${finalRevalidate}`\n        }\n\n        if (\n          // when force static is configured we don't bail from\n          // `revalidate: 0` values\n          !(staticGenerationStore.forceStatic && finalRevalidate === 0) &&\n          // we don't consider autoNoCache to switch to dynamic for ISR\n          !autoNoCache &&\n          // If the revalidate value isn't currently set or the value is less\n          // than the current revalidate value, we should update the revalidate\n          // value.\n          (typeof staticGenerationStore.revalidate === 'undefined' ||\n            (typeof finalRevalidate === 'number' &&\n              (staticGenerationStore.revalidate === false ||\n                (typeof staticGenerationStore.revalidate === 'number' &&\n                  finalRevalidate < staticGenerationStore.revalidate))))\n        ) {\n          // If we were setting the revalidate value to 0, we should try to\n          // postpone instead first.\n          if (finalRevalidate === 0) {\n            trackDynamicFetch(staticGenerationStore, 'revalidate: 0')\n          }\n\n          staticGenerationStore.revalidate = finalRevalidate\n        }\n\n        const isCacheableRevalidate =\n          (typeof finalRevalidate === 'number' && finalRevalidate > 0) ||\n          finalRevalidate === false\n\n        let cacheKey: string | undefined\n        if (staticGenerationStore.incrementalCache && isCacheableRevalidate) {\n          try {\n            cacheKey =\n              await staticGenerationStore.incrementalCache.fetchCacheKey(\n                fetchUrl,\n                isRequestInput ? (input as RequestInit) : init\n              )\n          } catch (err) {\n            console.error(`Failed to generate cache key for`, input)\n          }\n        }\n\n        const fetchIdx = staticGenerationStore.nextFetchId ?? 1\n        staticGenerationStore.nextFetchId = fetchIdx + 1\n\n        const normalizedRevalidate =\n          typeof finalRevalidate !== 'number' ? CACHE_ONE_YEAR : finalRevalidate\n\n        const doOriginalFetch = async (\n          isStale?: boolean,\n          cacheReasonOverride?: string\n        ) => {\n          const requestInputFields = [\n            'cache',\n            'credentials',\n            'headers',\n            'integrity',\n            'keepalive',\n            'method',\n            'mode',\n            'redirect',\n            'referrer',\n            'referrerPolicy',\n            'window',\n            'duplex',\n\n            // don't pass through signal when revalidating\n            ...(isStale ? [] : ['signal']),\n          ]\n\n          if (isRequestInput) {\n            const reqInput: Request = input as any\n            const reqOptions: RequestInit = {\n              body: (reqInput as any)._ogBody || reqInput.body,\n            }\n\n            for (const field of requestInputFields) {\n              // @ts-expect-error custom fields\n              reqOptions[field] = reqInput[field]\n            }\n            input = new Request(reqInput.url, reqOptions)\n          } else if (init) {\n            const { _ogBody, body, signal, ...otherInput } =\n              init as RequestInit & { _ogBody?: any }\n            init = {\n              ...otherInput,\n              body: _ogBody || body,\n              signal: isStale ? undefined : signal,\n            }\n          }\n\n          // add metadata to init without editing the original\n          const clonedInit = {\n            ...init,\n            next: { ...init?.next, fetchType: 'origin', fetchIdx },\n          }\n\n          return originFetch(input, clonedInit).then(async (res) => {\n            if (!isStale) {\n              trackFetchMetric(staticGenerationStore, {\n                start: fetchStart,\n                url: fetchUrl,\n                cacheReason: cacheReasonOverride || cacheReason,\n                cacheStatus:\n                  finalRevalidate === 0 || cacheReasonOverride\n                    ? 'skip'\n                    : 'miss',\n                status: res.status,\n                method: clonedInit.method || 'GET',\n              })\n            }\n            if (\n              res.status === 200 &&\n              staticGenerationStore.incrementalCache &&\n              cacheKey &&\n              isCacheableRevalidate\n            ) {\n              const bodyBuffer = Buffer.from(await res.arrayBuffer())\n\n              try {\n                await staticGenerationStore.incrementalCache.set(\n                  cacheKey,\n                  {\n                    kind: 'FETCH',\n                    data: {\n                      headers: Object.fromEntries(res.headers.entries()),\n                      body: bodyBuffer.toString('base64'),\n                      status: res.status,\n                      url: res.url,\n                    },\n                    revalidate: normalizedRevalidate,\n                  },\n                  {\n                    fetchCache: true,\n                    revalidate: finalRevalidate,\n                    fetchUrl,\n                    fetchIdx,\n                    tags,\n                  }\n                )\n              } catch (err) {\n                console.warn(`Failed to set fetch cache`, input, err)\n              }\n\n              const response = new Response(bodyBuffer, {\n                headers: new Headers(res.headers),\n                status: res.status,\n              })\n              Object.defineProperty(response, 'url', { value: res.url })\n              return response\n            }\n            return res\n          })\n        }\n\n        let handleUnlock = () => Promise.resolve()\n        let cacheReasonOverride\n        let isForegroundRevalidate = false\n\n        if (cacheKey && staticGenerationStore.incrementalCache) {\n          handleUnlock =\n            await staticGenerationStore.incrementalCache.lock(cacheKey)\n\n          const entry = staticGenerationStore.isOnDemandRevalidate\n            ? null\n            : await staticGenerationStore.incrementalCache.get(cacheKey, {\n                kindHint: 'fetch',\n                revalidate: finalRevalidate,\n                fetchUrl,\n                fetchIdx,\n                tags,\n                softTags: implicitTags,\n              })\n\n          if (entry) {\n            await handleUnlock()\n          } else {\n            // in dev, incremental cache response will be null in case the browser adds `cache-control: no-cache` in the request headers\n            cacheReasonOverride = 'cache-control: no-cache (hard refresh)'\n          }\n\n          if (entry?.value && entry.value.kind === 'FETCH') {\n            // when stale and is revalidating we wait for fresh data\n            // so the revalidated entry has the updated data\n            if (staticGenerationStore.isRevalidate && entry.isStale) {\n              isForegroundRevalidate = true\n            } else {\n              if (entry.isStale) {\n                staticGenerationStore.pendingRevalidates ??= {}\n                if (!staticGenerationStore.pendingRevalidates[cacheKey]) {\n                  staticGenerationStore.pendingRevalidates[cacheKey] =\n                    doOriginalFetch(true)\n                      .catch(console.error)\n                      .finally(() => {\n                        staticGenerationStore.pendingRevalidates ??= {}\n                        delete staticGenerationStore.pendingRevalidates[\n                          cacheKey || ''\n                        ]\n                      })\n                }\n              }\n              const resData = entry.value.data\n\n              trackFetchMetric(staticGenerationStore, {\n                start: fetchStart,\n                url: fetchUrl,\n                cacheReason,\n                cacheStatus: 'hit',\n                status: resData.status || 200,\n                method: init?.method || 'GET',\n              })\n\n              const response = new Response(\n                Buffer.from(resData.body, 'base64'),\n                {\n                  headers: resData.headers,\n                  status: resData.status,\n                }\n              )\n              Object.defineProperty(response, 'url', {\n                value: entry.value.data.url,\n              })\n              return response\n            }\n          }\n        }\n\n        if (\n          staticGenerationStore.isStaticGeneration &&\n          init &&\n          typeof init === 'object'\n        ) {\n          const { cache } = init\n\n          // Delete `cache` property as Cloudflare Workers will throw an error\n          if (isEdgeRuntime) delete init.cache\n\n          if (!staticGenerationStore.forceStatic && cache === 'no-store') {\n            const dynamicUsageReason = `no-store fetch ${input}${\n              staticGenerationStore.urlPathname\n                ? ` ${staticGenerationStore.urlPathname}`\n                : ''\n            }`\n\n            // If enabled, we should bail out of static generation.\n            trackDynamicFetch(staticGenerationStore, dynamicUsageReason)\n\n            // If partial prerendering is not enabled, then we should throw an\n            // error to indicate that this fetch is dynamic.\n            if (!staticGenerationStore.prerenderState) {\n              // PPR is not enabled, or React postpone is not available, we\n              // should set the revalidate to 0.\n              staticGenerationStore.revalidate = 0\n\n              const err = new DynamicServerError(dynamicUsageReason)\n              staticGenerationStore.dynamicUsageErr = err\n              staticGenerationStore.dynamicUsageDescription = dynamicUsageReason\n              throw err\n            }\n          }\n\n          const hasNextConfig = 'next' in init\n          const { next = {} } = init\n          if (\n            typeof next.revalidate === 'number' &&\n            (typeof staticGenerationStore.revalidate === 'undefined' ||\n              (typeof staticGenerationStore.revalidate === 'number' &&\n                next.revalidate < staticGenerationStore.revalidate))\n          ) {\n            if (\n              !staticGenerationStore.forceDynamic &&\n              !staticGenerationStore.forceStatic &&\n              next.revalidate === 0\n            ) {\n              const dynamicUsageReason = `revalidate: 0 fetch ${input}${\n                staticGenerationStore.urlPathname\n                  ? ` ${staticGenerationStore.urlPathname}`\n                  : ''\n              }`\n\n              // If enabled, we should bail out of static generation.\n              trackDynamicFetch(staticGenerationStore, dynamicUsageReason)\n\n              // If partial prerendering is not enabled, then we should throw an\n              // error to indicate that this fetch is dynamic.\n              if (!staticGenerationStore.prerenderState) {\n                const err = new DynamicServerError(dynamicUsageReason)\n                staticGenerationStore.dynamicUsageErr = err\n                staticGenerationStore.dynamicUsageDescription =\n                  dynamicUsageReason\n                throw err\n              }\n            }\n\n            if (!staticGenerationStore.forceStatic || next.revalidate !== 0) {\n              staticGenerationStore.revalidate = next.revalidate\n            }\n          }\n          if (hasNextConfig) delete init.next\n        }\n\n        // if we are revalidating the whole page via time or on-demand and\n        // the fetch cache entry is stale we should still de-dupe the\n        // origin hit if it's a cache-able entry\n        if (cacheKey && isForegroundRevalidate) {\n          staticGenerationStore.pendingRevalidates ??= {}\n          const pendingRevalidate =\n            staticGenerationStore.pendingRevalidates[cacheKey]\n\n          if (pendingRevalidate) {\n            const res: Response = await pendingRevalidate\n            return res.clone()\n          }\n          return (staticGenerationStore.pendingRevalidates[cacheKey] =\n            doOriginalFetch(true, cacheReasonOverride).finally(async () => {\n              staticGenerationStore.pendingRevalidates ??= {}\n              delete staticGenerationStore.pendingRevalidates[cacheKey || '']\n              await handleUnlock()\n            }))\n        } else {\n          return doOriginalFetch(false, cacheReasonOverride).finally(\n            handleUnlock\n          )\n        }\n      }\n    )\n  }\n\n  // Attach the necessary properties to the patched fetch function.\n  patched.__nextPatched = true as const\n  patched.__nextGetStaticStore = () => staticGenerationAsyncStorage\n  patched._nextOriginalFetch = originFetch\n\n  return patched\n}\n\n// we patch fetch to collect cache information used for\n// determining if a page is static or not\nexport function patchFetch(options: PatchableModule) {\n  // If we've already patched fetch, we should not patch it again.\n  if (isPatchedFetch(globalThis.fetch)) return\n\n  // Grab the original fetch function. We'll attach this so we can use it in\n  // the patched fetch function.\n  const original = globalThis.fetch\n\n  // Set the global fetch to the patched fetch.\n  globalThis.fetch = createPatchedFetcher(original, options)\n}\n"],"names":["AppRenderSpan","NextNodeServerSpan","getTracer","SpanKind","CACHE_ONE_YEAR","NEXT_CACHE_IMPLICIT_TAG_ID","NEXT_CACHE_TAG_MAX_ITEMS","NEXT_CACHE_TAG_MAX_LENGTH","Log","trackDynamicFetch","isEdgeRuntime","process","env","NEXT_RUNTIME","isPatchedFetch","fetch","__nextPatched","validateRevalidate","revalidateVal","pathname","normalizedRevalidate","undefined","isNaN","Error","err","message","includes","validateTags","tags","description","validTags","invalidTags","i","length","tag","push","reason","console","warn","slice","join","log","getDerivedTags","derivedTags","startsWith","pathnameParts","split","curPathname","endsWith","addImplicitTags","staticGenerationStore","newTags","pagePath","urlPathname","Array","isArray","parsedPathname","URL","trackFetchMetric","ctx","requestEndedState","ended","NODE_ENV","fetchMetrics","dedupeFields","some","metric","every","field","end","Date","now","idx","nextFetchId","sort","a","b","aDur","start","bDur","createPatchedFetcher","originFetch","serverHooks","DynamicServerError","staticGenerationAsyncStorage","patched","input","init","url","Request","username","password","fetchUrl","href","fetchStart","method","toUpperCase","isInternal","next","internal","hideSpan","NEXT_OTEL_FETCH_DISABLED","trace","internalFetch","kind","CLIENT","spanName","filter","Boolean","attributes","hostname","port","getRequestMeta","getStore","isDraftMode","isRequestInput","value","finalRevalidate","getNextField","currentFetchRevalidate","toString","implicitTags","pageFetchCacheMode","fetchCache","isUsingNoStore","isUnstableNoStore","currentFetchCacheConfig","cacheReason","forceDynamic","_headers","initHeaders","get","Headers","hasUnCacheableHeader","isUnCacheableMethod","toLowerCase","autoNoCache","revalidate","forceStatic","isCacheableRevalidate","cacheKey","incrementalCache","fetchCacheKey","error","fetchIdx","doOriginalFetch","isStale","cacheReasonOverride","requestInputFields","reqInput","reqOptions","body","_ogBody","signal","otherInput","clonedInit","fetchType","then","res","cacheStatus","status","bodyBuffer","Buffer","from","arrayBuffer","set","data","headers","Object","fromEntries","entries","response","Response","defineProperty","handleUnlock","Promise","resolve","isForegroundRevalidate","lock","entry","isOnDemandRevalidate","kindHint","softTags","isRevalidate","pendingRevalidates","catch","finally","resData","isStaticGeneration","cache","dynamicUsageReason","prerenderState","dynamicUsageErr","dynamicUsageDescription","hasNextConfig","pendingRevalidate","clone","__nextGetStaticStore","_nextOriginalFetch","patchFetch","options","globalThis","original"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}