{"version":3,"sources":["../../../../src/server/lib/incremental-cache/index.ts"],"sourcesContent":["import type { CacheFs } from '../../../shared/lib/utils'\nimport type { PrerenderManifest } from '../../../build'\nimport type {\n  IncrementalCacheValue,\n  IncrementalCacheEntry,\n  IncrementalCache as IncrementalCacheType,\n  IncrementalCacheKindHint,\n} from '../../response-cache'\nimport type { Revalidate } from '../revalidate'\nimport type { DeepReadonly } from '../../../shared/lib/deep-readonly'\n\nimport FetchCache from './fetch-cache'\nimport FileSystemCache from './file-system-cache'\nimport { normalizePagePath } from '../../../shared/lib/page-path/normalize-page-path'\n\nimport {\n  CACHE_ONE_YEAR,\n  NEXT_CACHE_REVALIDATED_TAGS_HEADER,\n  NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER,\n  PRERENDER_REVALIDATE_HEADER,\n} from '../../../lib/constants'\nimport { toRoute } from '../to-route'\nimport { SharedRevalidateTimings } from './shared-revalidate-timings'\n\nexport interface CacheHandlerContext {\n  fs?: CacheFs\n  dev?: boolean\n  flushToDisk?: boolean\n  serverDistDir?: string\n  maxMemoryCacheSize?: number\n  fetchCacheKeyPrefix?: string\n  prerenderManifest?: PrerenderManifest\n  revalidatedTags: string[]\n  isAppPPREnabled?: boolean\n  _appDir: boolean\n  _pagesDir: boolean\n  _requestHeaders: IncrementalCache['requestHeaders']\n}\n\nexport interface CacheHandlerValue {\n  lastModified?: number\n  age?: number\n  cacheState?: string\n  value: IncrementalCacheValue | null\n}\n\nexport class CacheHandler {\n  // eslint-disable-next-line\n  constructor(_ctx: CacheHandlerContext) {}\n\n  public async get(\n    ..._args: Parameters<IncrementalCache['get']>\n  ): Promise<CacheHandlerValue | null> {\n    return {} as any\n  }\n\n  public async set(\n    ..._args: Parameters<IncrementalCache['set']>\n  ): Promise<void> {}\n\n  public async revalidateTag(\n    ..._args: Parameters<IncrementalCache['revalidateTag']>\n  ): Promise<void> {}\n\n  public resetRequestCache(): void {}\n}\n\nexport class IncrementalCache implements IncrementalCacheType {\n  readonly dev?: boolean\n  readonly disableForTestmode?: boolean\n  readonly cacheHandler?: CacheHandler\n  readonly hasCustomCacheHandler: boolean\n  readonly prerenderManifest: DeepReadonly<PrerenderManifest>\n  readonly requestHeaders: Record<string, undefined | string | string[]>\n  readonly requestProtocol?: 'http' | 'https'\n  readonly allowedRevalidateHeaderKeys?: string[]\n  readonly minimalMode?: boolean\n  readonly fetchCacheKeyPrefix?: string\n  readonly revalidatedTags?: string[]\n  readonly isOnDemandRevalidate?: boolean\n\n  private readonly locks = new Map<string, Promise<void>>()\n  private readonly unlocks = new Map<string, () => Promise<void>>()\n\n  /**\n   * The revalidate timings for routes. This will source the timings from the\n   * prerender manifest until the in-memory cache is updated with new timings.\n   */\n  private readonly revalidateTimings: SharedRevalidateTimings\n\n  constructor({\n    fs,\n    dev,\n    appDir,\n    pagesDir,\n    flushToDisk,\n    fetchCache,\n    minimalMode,\n    serverDistDir,\n    requestHeaders,\n    requestProtocol,\n    maxMemoryCacheSize,\n    getPrerenderManifest,\n    fetchCacheKeyPrefix,\n    CurCacheHandler,\n    allowedRevalidateHeaderKeys,\n    isAppPPREnabled,\n  }: {\n    fs?: CacheFs\n    dev: boolean\n    appDir?: boolean\n    pagesDir?: boolean\n    fetchCache?: boolean\n    minimalMode?: boolean\n    serverDistDir?: string\n    flushToDisk?: boolean\n    requestProtocol?: 'http' | 'https'\n    allowedRevalidateHeaderKeys?: string[]\n    requestHeaders: IncrementalCache['requestHeaders']\n    maxMemoryCacheSize?: number\n    getPrerenderManifest: () => DeepReadonly<PrerenderManifest>\n    fetchCacheKeyPrefix?: string\n    CurCacheHandler?: typeof CacheHandler\n    isAppPPREnabled: boolean\n  }) {\n    const debug = !!process.env.NEXT_PRIVATE_DEBUG_CACHE\n    this.hasCustomCacheHandler = Boolean(CurCacheHandler)\n    if (!CurCacheHandler) {\n      if (fs && serverDistDir) {\n        if (debug) {\n          console.log('using filesystem cache handler')\n        }\n        CurCacheHandler = FileSystemCache\n      }\n      if (\n        FetchCache.isAvailable({ _requestHeaders: requestHeaders }) &&\n        minimalMode &&\n        fetchCache\n      ) {\n        if (debug) {\n          console.log('using fetch cache handler')\n        }\n        CurCacheHandler = FetchCache\n      }\n    } else if (debug) {\n      console.log('using custom cache handler', CurCacheHandler.name)\n    }\n\n    if (process.env.__NEXT_TEST_MAX_ISR_CACHE) {\n      // Allow cache size to be overridden for testing purposes\n      maxMemoryCacheSize = parseInt(process.env.__NEXT_TEST_MAX_ISR_CACHE, 10)\n    }\n    this.dev = dev\n    this.disableForTestmode = process.env.NEXT_PRIVATE_TEST_PROXY === 'true'\n    // this is a hack to avoid Webpack knowing this is equal to this.minimalMode\n    // because we replace this.minimalMode to true in production bundles.\n    const minimalModeKey = 'minimalMode'\n    this[minimalModeKey] = minimalMode\n    this.requestHeaders = requestHeaders\n    this.requestProtocol = requestProtocol\n    this.allowedRevalidateHeaderKeys = allowedRevalidateHeaderKeys\n    this.prerenderManifest = getPrerenderManifest()\n    this.revalidateTimings = new SharedRevalidateTimings(this.prerenderManifest)\n    this.fetchCacheKeyPrefix = fetchCacheKeyPrefix\n    let revalidatedTags: string[] = []\n\n    if (\n      requestHeaders[PRERENDER_REVALIDATE_HEADER] ===\n      this.prerenderManifest?.preview?.previewModeId\n    ) {\n      this.isOnDemandRevalidate = true\n    }\n\n    if (\n      minimalMode &&\n      typeof requestHeaders[NEXT_CACHE_REVALIDATED_TAGS_HEADER] === 'string' &&\n      requestHeaders[NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER] ===\n        this.prerenderManifest?.preview?.previewModeId\n    ) {\n      revalidatedTags =\n        requestHeaders[NEXT_CACHE_REVALIDATED_TAGS_HEADER].split(',')\n    }\n\n    if (CurCacheHandler) {\n      this.cacheHandler = new CurCacheHandler({\n        dev,\n        fs,\n        flushToDisk,\n        serverDistDir,\n        revalidatedTags,\n        maxMemoryCacheSize,\n        _pagesDir: !!pagesDir,\n        _appDir: !!appDir,\n        _requestHeaders: requestHeaders,\n        fetchCacheKeyPrefix,\n        isAppPPREnabled,\n      })\n    }\n  }\n\n  private calculateRevalidate(\n    pathname: string,\n    fromTime: number,\n    dev?: boolean\n  ): Revalidate {\n    // in development we don't have a prerender-manifest\n    // and default to always revalidating to allow easier debugging\n    if (dev) return new Date().getTime() - 1000\n\n    // if an entry isn't present in routes we fallback to a default\n    // of revalidating after 1 second.\n    const initialRevalidateSeconds =\n      this.revalidateTimings.get(toRoute(pathname)) ?? 1\n\n    const revalidateAfter =\n      typeof initialRevalidateSeconds === 'number'\n        ? initialRevalidateSeconds * 1000 + fromTime\n        : initialRevalidateSeconds\n\n    return revalidateAfter\n  }\n\n  _getPathname(pathname: string, fetchCache?: boolean) {\n    return fetchCache ? pathname : normalizePagePath(pathname)\n  }\n\n  resetRequestCache() {\n    this.cacheHandler?.resetRequestCache?.()\n  }\n\n  async unlock(cacheKey: string) {\n    const unlock = this.unlocks.get(cacheKey)\n    if (unlock) {\n      unlock()\n      this.locks.delete(cacheKey)\n      this.unlocks.delete(cacheKey)\n    }\n  }\n\n  async lock(cacheKey: string) {\n    if (\n      process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT &&\n      process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY &&\n      process.env.NEXT_RUNTIME !== 'edge'\n    ) {\n      const invokeIpcMethod = require('../server-ipc/request-utils')\n        .invokeIpcMethod as typeof import('../server-ipc/request-utils').invokeIpcMethod\n\n      await invokeIpcMethod({\n        method: 'lock',\n        ipcPort: process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT,\n        ipcKey: process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY,\n        args: [cacheKey],\n      })\n\n      return async () => {\n        await invokeIpcMethod({\n          method: 'unlock',\n          ipcPort: process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT,\n          ipcKey: process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY,\n          args: [cacheKey],\n        })\n      }\n    }\n\n    let unlockNext: () => Promise<void> = () => Promise.resolve()\n    const existingLock = this.locks.get(cacheKey)\n\n    if (existingLock) {\n      await existingLock\n    } else {\n      const newLock = new Promise<void>((resolve) => {\n        unlockNext = async () => {\n          resolve()\n        }\n      })\n\n      this.locks.set(cacheKey, newLock)\n      this.unlocks.set(cacheKey, unlockNext)\n    }\n\n    return unlockNext\n  }\n\n  async revalidateTag(tags: string | string[]): Promise<void> {\n    if (\n      process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT &&\n      process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY &&\n      process.env.NEXT_RUNTIME !== 'edge'\n    ) {\n      const invokeIpcMethod = require('../server-ipc/request-utils')\n        .invokeIpcMethod as typeof import('../server-ipc/request-utils').invokeIpcMethod\n      return invokeIpcMethod({\n        method: 'revalidateTag',\n        ipcPort: process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT,\n        ipcKey: process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY,\n        args: [...arguments],\n      })\n    }\n\n    return this.cacheHandler?.revalidateTag?.(tags)\n  }\n\n  // x-ref: https://github.com/facebook/react/blob/2655c9354d8e1c54ba888444220f63e836925caa/packages/react/src/ReactFetch.js#L23\n  async fetchCacheKey(\n    url: string,\n    init: RequestInit | Request = {}\n  ): Promise<string> {\n    // this should be bumped anytime a fix is made to cache entries\n    // that should bust the cache\n    const MAIN_KEY_PREFIX = 'v3'\n\n    const bodyChunks: string[] = []\n\n    const encoder = new TextEncoder()\n    const decoder = new TextDecoder()\n\n    if (init.body) {\n      // handle ReadableStream body\n      if (typeof (init.body as any).getReader === 'function') {\n        const readableBody = init.body as ReadableStream<Uint8Array | string>\n\n        const chunks: Uint8Array[] = []\n\n        try {\n          await readableBody.pipeTo(\n            new WritableStream({\n              write(chunk) {\n                if (typeof chunk === 'string') {\n                  chunks.push(encoder.encode(chunk))\n                  bodyChunks.push(chunk)\n                } else {\n                  chunks.push(chunk)\n                  bodyChunks.push(decoder.decode(chunk, { stream: true }))\n                }\n              },\n            })\n          )\n\n          // Flush the decoder.\n          bodyChunks.push(decoder.decode())\n\n          // Create a new buffer with all the chunks.\n          const length = chunks.reduce((total, arr) => total + arr.length, 0)\n          const arrayBuffer = new Uint8Array(length)\n\n          // Push each of the chunks into the new array buffer.\n          let offset = 0\n          for (const chunk of chunks) {\n            arrayBuffer.set(chunk, offset)\n            offset += chunk.length\n          }\n\n          ;(init as any)._ogBody = arrayBuffer\n        } catch (err) {\n          console.error('Problem reading body', err)\n        }\n      } // handle FormData or URLSearchParams bodies\n      else if (typeof (init.body as any).keys === 'function') {\n        const formData = init.body as FormData\n        ;(init as any)._ogBody = init.body\n        for (const key of new Set([...formData.keys()])) {\n          const values = formData.getAll(key)\n          bodyChunks.push(\n            `${key}=${(\n              await Promise.all(\n                values.map(async (val) => {\n                  if (typeof val === 'string') {\n                    return val\n                  } else {\n                    return await val.text()\n                  }\n                })\n              )\n            ).join(',')}`\n          )\n        }\n        // handle blob body\n      } else if (typeof (init.body as any).arrayBuffer === 'function') {\n        const blob = init.body as Blob\n        const arrayBuffer = await blob.arrayBuffer()\n        bodyChunks.push(await blob.text())\n        ;(init as any)._ogBody = new Blob([arrayBuffer], { type: blob.type })\n      } else if (typeof init.body === 'string') {\n        bodyChunks.push(init.body)\n        ;(init as any)._ogBody = init.body\n      }\n    }\n\n    const headers =\n      typeof (init.headers || {}).keys === 'function'\n        ? Object.fromEntries(init.headers as Headers)\n        : Object.assign({}, init.headers)\n\n    if ('traceparent' in headers) delete headers['traceparent']\n\n    const cacheString = JSON.stringify([\n      MAIN_KEY_PREFIX,\n      this.fetchCacheKeyPrefix || '',\n      url,\n      init.method,\n      headers,\n      init.mode,\n      init.redirect,\n      init.credentials,\n      init.referrer,\n      init.referrerPolicy,\n      init.integrity,\n      init.cache,\n      bodyChunks,\n    ])\n\n    if (process.env.NEXT_RUNTIME === 'edge') {\n      function bufferToHex(buffer: ArrayBuffer): string {\n        return Array.prototype.map\n          .call(new Uint8Array(buffer), (b) => b.toString(16).padStart(2, '0'))\n          .join('')\n      }\n      const buffer = encoder.encode(cacheString)\n      return bufferToHex(await crypto.subtle.digest('SHA-256', buffer))\n    } else {\n      const crypto = require('crypto') as typeof import('crypto')\n      return crypto.createHash('sha256').update(cacheString).digest('hex')\n    }\n  }\n\n  // get data from cache if available\n  async get(\n    cacheKey: string,\n    ctx: {\n      kindHint?: IncrementalCacheKindHint\n      revalidate?: Revalidate\n      fetchUrl?: string\n      fetchIdx?: number\n      tags?: string[]\n      softTags?: string[]\n    } = {}\n  ): Promise<IncrementalCacheEntry | null> {\n    if (\n      process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT &&\n      process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY &&\n      process.env.NEXT_RUNTIME !== 'edge'\n    ) {\n      const invokeIpcMethod = require('../server-ipc/request-utils')\n        .invokeIpcMethod as typeof import('../server-ipc/request-utils').invokeIpcMethod\n\n      return invokeIpcMethod({\n        method: 'get',\n        ipcPort: process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT,\n        ipcKey: process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY,\n        args: [...arguments],\n      })\n    }\n\n    // we don't leverage the prerender cache in dev mode\n    // so that getStaticProps is always called for easier debugging\n    if (\n      this.disableForTestmode ||\n      (this.dev &&\n        (ctx.kindHint !== 'fetch' ||\n          this.requestHeaders['cache-control'] === 'no-cache'))\n    ) {\n      return null\n    }\n\n    cacheKey = this._getPathname(cacheKey, ctx.kindHint === 'fetch')\n    let entry: IncrementalCacheEntry | null = null\n    let revalidate = ctx.revalidate\n\n    const cacheData = await this.cacheHandler?.get(cacheKey, ctx)\n\n    if (cacheData?.value?.kind === 'FETCH') {\n      const combinedTags = [...(ctx.tags || []), ...(ctx.softTags || [])]\n      // if a tag was revalidated we don't return stale data\n      if (\n        combinedTags.some((tag) => {\n          return this.revalidatedTags?.includes(tag)\n        })\n      ) {\n        return null\n      }\n\n      revalidate = revalidate || cacheData.value.revalidate\n      const age = (Date.now() - (cacheData.lastModified || 0)) / 1000\n\n      const isStale = age > revalidate\n      const data = cacheData.value.data\n\n      return {\n        isStale: isStale,\n        value: {\n          kind: 'FETCH',\n          data,\n          revalidate: revalidate,\n        },\n        revalidateAfter: Date.now() + revalidate * 1000,\n      }\n    }\n\n    const curRevalidate = this.revalidateTimings.get(toRoute(cacheKey))\n\n    let isStale: boolean | -1 | undefined\n    let revalidateAfter: Revalidate\n\n    if (cacheData?.lastModified === -1) {\n      isStale = -1\n      revalidateAfter = -1 * CACHE_ONE_YEAR\n    } else {\n      revalidateAfter = this.calculateRevalidate(\n        cacheKey,\n        cacheData?.lastModified || Date.now(),\n        this.dev && ctx.kindHint !== 'fetch'\n      )\n      isStale =\n        revalidateAfter !== false && revalidateAfter < Date.now()\n          ? true\n          : undefined\n    }\n\n    if (cacheData) {\n      entry = {\n        isStale,\n        curRevalidate,\n        revalidateAfter,\n        value: cacheData.value,\n      }\n    }\n\n    if (\n      !cacheData &&\n      this.prerenderManifest.notFoundRoutes.includes(cacheKey)\n    ) {\n      // for the first hit after starting the server the cache\n      // may not have a way to save notFound: true so if\n      // the prerender-manifest marks this as notFound then we\n      // return that entry and trigger a cache set to give it a\n      // chance to update in-memory entries\n      entry = {\n        isStale,\n        value: null,\n        curRevalidate,\n        revalidateAfter,\n      }\n      this.set(cacheKey, entry.value, ctx)\n    }\n    return entry\n  }\n\n  // populate the incremental cache with new data\n  async set(\n    pathname: string,\n    data: IncrementalCacheValue | null,\n    ctx: {\n      revalidate?: Revalidate\n      fetchCache?: boolean\n      fetchUrl?: string\n      fetchIdx?: number\n      tags?: string[]\n    }\n  ) {\n    if (\n      process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT &&\n      process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY &&\n      process.env.NEXT_RUNTIME !== 'edge'\n    ) {\n      const invokeIpcMethod = require('../server-ipc/request-utils')\n        .invokeIpcMethod as typeof import('../server-ipc/request-utils').invokeIpcMethod\n\n      return invokeIpcMethod({\n        method: 'set',\n        ipcPort: process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT,\n        ipcKey: process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY,\n        args: [...arguments],\n      })\n    }\n\n    if (this.disableForTestmode || (this.dev && !ctx.fetchCache)) return\n    // FetchCache has upper limit of 2MB per-entry currently\n    const itemSize = JSON.stringify(data).length\n    if (\n      ctx.fetchCache &&\n      // we don't show this error/warning when a custom cache handler is being used\n      // as it might not have this limit\n      !this.hasCustomCacheHandler &&\n      itemSize > 2 * 1024 * 1024\n    ) {\n      if (this.dev) {\n        throw new Error(\n          `Failed to set Next.js data cache, items over 2MB can not be cached (${itemSize} bytes)`\n        )\n      }\n      return\n    }\n\n    pathname = this._getPathname(pathname, ctx.fetchCache)\n\n    try {\n      // Set the value for the revalidate seconds so if it changes we can\n      // update the cache with the new value.\n      if (typeof ctx.revalidate !== 'undefined' && !ctx.fetchCache) {\n        this.revalidateTimings.set(toRoute(pathname), ctx.revalidate)\n      }\n\n      await this.cacheHandler?.set(pathname, data, ctx)\n    } catch (error) {\n      console.warn('Failed to update prerender cache for', pathname, error)\n    }\n  }\n}\n"],"names":["FetchCache","FileSystemCache","normalizePagePath","CACHE_ONE_YEAR","NEXT_CACHE_REVALIDATED_TAGS_HEADER","NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER","PRERENDER_REVALIDATE_HEADER","toRoute","SharedRevalidateTimings","CacheHandler","constructor","_ctx","get","_args","set","revalidateTag","resetRequestCache","IncrementalCache","fs","dev","appDir","pagesDir","flushToDisk","fetchCache","minimalMode","serverDistDir","requestHeaders","requestProtocol","maxMemoryCacheSize","getPrerenderManifest","fetchCacheKeyPrefix","CurCacheHandler","allowedRevalidateHeaderKeys","isAppPPREnabled","locks","Map","unlocks","debug","process","env","NEXT_PRIVATE_DEBUG_CACHE","hasCustomCacheHandler","Boolean","console","log","isAvailable","_requestHeaders","name","__NEXT_TEST_MAX_ISR_CACHE","parseInt","disableForTestmode","NEXT_PRIVATE_TEST_PROXY","minimalModeKey","prerenderManifest","revalidateTimings","revalidatedTags","preview","previewModeId","isOnDemandRevalidate","split","cacheHandler","_pagesDir","_appDir","calculateRevalidate","pathname","fromTime","Date","getTime","initialRevalidateSeconds","revalidateAfter","_getPathname","unlock","cacheKey","delete","lock","__NEXT_INCREMENTAL_CACHE_IPC_PORT","__NEXT_INCREMENTAL_CACHE_IPC_KEY","NEXT_RUNTIME","invokeIpcMethod","require","method","ipcPort","ipcKey","args","unlockNext","Promise","resolve","existingLock","newLock","tags","arguments","fetchCacheKey","url","init","MAIN_KEY_PREFIX","bodyChunks","encoder","TextEncoder","decoder","TextDecoder","body","getReader","readableBody","chunks","pipeTo","WritableStream","write","chunk","push","encode","decode","stream","length","reduce","total","arr","arrayBuffer","Uint8Array","offset","_ogBody","err","error","keys","formData","key","Set","values","getAll","all","map","val","text","join","blob","Blob","type","headers","Object","fromEntries","assign","cacheString","JSON","stringify","mode","redirect","credentials","referrer","referrerPolicy","integrity","cache","bufferToHex","buffer","Array","prototype","call","b","toString","padStart","crypto","subtle","digest","createHash","update","ctx","cacheData","kindHint","entry","revalidate","value","kind","combinedTags","softTags","some","tag","includes","age","now","lastModified","isStale","data","curRevalidate","undefined","notFoundRoutes","itemSize","Error","warn"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}