{"version":3,"sources":["../../../src/server/app-render/make-get-server-inserted-html.tsx"],"sourcesContent":["import React from 'react'\nimport { isNotFoundError } from '../../client/components/not-found'\nimport {\n  getURLFromRedirectError,\n  isRedirectError,\n  getRedirectStatusCodeFromError,\n} from '../../client/components/redirect'\nimport { renderToReadableStream } from 'react-dom/server.edge'\nimport { streamToString } from '../stream-utils/node-web-streams-helper'\nimport { RedirectStatusCode } from '../../client/components/redirect-status-code'\nimport { addPathPrefix } from '../../shared/lib/router/utils/add-path-prefix'\nimport type { ClientTraceDataEntry } from '../lib/trace/tracer'\n\nexport function getTracedMetadata(\n  traceData: ClientTraceDataEntry[],\n  clientTraceMetadata: string[] | undefined\n): ClientTraceDataEntry[] | undefined {\n  if (!clientTraceMetadata) return undefined\n  return traceData.filter(({ key }) => clientTraceMetadata.includes(key))\n}\n\nexport function makeGetServerInsertedHTML({\n  polyfills,\n  renderServerInsertedHTML,\n  serverCapturedErrors,\n  tracingMetadata,\n  basePath,\n}: {\n  polyfills: JSX.IntrinsicElements['script'][]\n  renderServerInsertedHTML: () => React.ReactNode\n  tracingMetadata: ClientTraceDataEntry[] | undefined\n  serverCapturedErrors: Error[]\n  basePath: string\n}) {\n  let flushedErrorMetaTagsUntilIndex = 0\n  let hasUnflushedPolyfills = polyfills.length !== 0\n\n  return async function getServerInsertedHTML() {\n    // Loop through all the errors that have been captured but not yet\n    // flushed.\n    const errorMetaTags = []\n    while (flushedErrorMetaTagsUntilIndex < serverCapturedErrors.length) {\n      const error = serverCapturedErrors[flushedErrorMetaTagsUntilIndex]\n      flushedErrorMetaTagsUntilIndex++\n\n      if (isNotFoundError(error)) {\n        errorMetaTags.push(\n          <meta name=\"robots\" content=\"noindex\" key={error.digest} />,\n          process.env.NODE_ENV === 'development' ? (\n            <meta name=\"next-error\" content=\"not-found\" key=\"next-error\" />\n          ) : null\n        )\n      } else if (isRedirectError(error)) {\n        const redirectUrl = addPathPrefix(\n          getURLFromRedirectError(error),\n          basePath\n        )\n        const statusCode = getRedirectStatusCodeFromError(error)\n        const isPermanent =\n          statusCode === RedirectStatusCode.PermanentRedirect ? true : false\n        if (redirectUrl) {\n          errorMetaTags.push(\n            <meta\n              id=\"__next-page-redirect\"\n              httpEquiv=\"refresh\"\n              content={`${isPermanent ? 0 : 1};url=${redirectUrl}`}\n              key={error.digest}\n            />\n          )\n        }\n      }\n    }\n\n    const serverInsertedHTML = renderServerInsertedHTML()\n\n    // Skip React rendering if we know the content is empty.\n    if (\n      !hasUnflushedPolyfills &&\n      errorMetaTags.length === 0 &&\n      Array.isArray(serverInsertedHTML) &&\n      serverInsertedHTML.length === 0\n    ) {\n      return ''\n    }\n\n    const stream = await renderToReadableStream(\n      <>\n        {\n          /* Insert the polyfills if they haven't been flushed yet. */\n          hasUnflushedPolyfills &&\n            polyfills.map((polyfill) => {\n              return <script key={polyfill.src} {...polyfill} />\n            })\n        }\n        {serverInsertedHTML}\n        {tracingMetadata\n          ? tracingMetadata.map(({ key, value }) => {\n              return (\n                <meta\n                  key={`next-trace-data-${key}:${value}`}\n                  name={key}\n                  content={value}\n                />\n              )\n            })\n          : null}\n        {errorMetaTags}\n      </>,\n      {\n        // Larger chunk because this isn't sent over the network.\n        // Let's set it to 1MB.\n        progressiveChunkSize: 1024 * 1024,\n      }\n    )\n\n    hasUnflushedPolyfills = false\n\n    // There's no need to wait for the stream to be ready\n    // e.g. calling `await stream.allReady` because `streamToString` will\n    // wait and decode the stream progressively with better parallelism.\n    return streamToString(stream)\n  }\n}\n"],"names":["React","isNotFoundError","getURLFromRedirectError","isRedirectError","getRedirectStatusCodeFromError","renderToReadableStream","streamToString","RedirectStatusCode","addPathPrefix","getTracedMetadata","traceData","clientTraceMetadata","undefined","filter","key","includes","makeGetServerInsertedHTML","polyfills","renderServerInsertedHTML","serverCapturedErrors","tracingMetadata","basePath","flushedErrorMetaTagsUntilIndex","hasUnflushedPolyfills","length","getServerInsertedHTML","errorMetaTags","error","push","meta","name","content","digest","process","env","NODE_ENV","redirectUrl","statusCode","isPermanent","PermanentRedirect","id","httpEquiv","serverInsertedHTML","Array","isArray","stream","map","polyfill","script","src","value","progressiveChunkSize"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":";AAAA,OAAOA,WAAW,QAAO;AACzB,SAASC,eAAe,QAAQ,oCAAmC;AACnE,SACEC,uBAAuB,EACvBC,eAAe,EACfC,8BAA8B,QACzB,mCAAkC;AACzC,SAASC,sBAAsB,QAAQ,wBAAuB;AAC9D,SAASC,cAAc,QAAQ,0CAAyC;AACxE,SAASC,kBAAkB,QAAQ,+CAA8C;AACjF,SAASC,aAAa,QAAQ,gDAA+C;AAG7E,OAAO,SAASC,kBACdC,SAAiC,EACjCC,mBAAyC;IAEzC,IAAI,CAACA,qBAAqB,OAAOC;IACjC,OAAOF,UAAUG,MAAM,CAAC,CAAC,EAAEC,GAAG,EAAE,GAAKH,oBAAoBI,QAAQ,CAACD;AACpE;AAEA,OAAO,SAASE,0BAA0B,EACxCC,SAAS,EACTC,wBAAwB,EACxBC,oBAAoB,EACpBC,eAAe,EACfC,QAAQ,EAOT;IACC,IAAIC,iCAAiC;IACrC,IAAIC,wBAAwBN,UAAUO,MAAM,KAAK;IAEjD,OAAO,eAAeC;QACpB,kEAAkE;QAClE,WAAW;QACX,MAAMC,gBAAgB,EAAE;QACxB,MAAOJ,iCAAiCH,qBAAqBK,MAAM,CAAE;YACnE,MAAMG,QAAQR,oBAAoB,CAACG,+BAA+B;YAClEA;YAEA,IAAIrB,gBAAgB0B,QAAQ;gBAC1BD,cAAcE,IAAI,eAChB,KAACC;oBAAKC,MAAK;oBAASC,SAAQ;mBAAeJ,MAAMK,MAAM,GACvDC,QAAQC,GAAG,CAACC,QAAQ,KAAK,8BACvB,KAACN;oBAAKC,MAAK;oBAAaC,SAAQ;mBAAgB,gBAC9C;YAER,OAAO,IAAI5B,gBAAgBwB,QAAQ;gBACjC,MAAMS,cAAc5B,cAClBN,wBAAwByB,QACxBN;gBAEF,MAAMgB,aAAajC,+BAA+BuB;gBAClD,MAAMW,cACJD,eAAe9B,mBAAmBgC,iBAAiB,GAAG,OAAO;gBAC/D,IAAIH,aAAa;oBACfV,cAAcE,IAAI,eAChB,KAACC;wBACCW,IAAG;wBACHC,WAAU;wBACVV,SAAS,CAAC,EAAEO,cAAc,IAAI,EAAE,KAAK,EAAEF,YAAY,CAAC;uBAC/CT,MAAMK,MAAM;gBAGvB;YACF;QACF;QAEA,MAAMU,qBAAqBxB;QAE3B,wDAAwD;QACxD,IACE,CAACK,yBACDG,cAAcF,MAAM,KAAK,KACzBmB,MAAMC,OAAO,CAACF,uBACdA,mBAAmBlB,MAAM,KAAK,GAC9B;YACA,OAAO;QACT;QAEA,MAAMqB,SAAS,MAAMxC,qCACnB;;gBAEI,0DAA0D,GAC1DkB,yBACEN,UAAU6B,GAAG,CAAC,CAACC;oBACb,qBAAO,KAACC;wBAA2B,GAAGD,QAAQ;uBAA1BA,SAASE,GAAG;gBAClC;gBAEHP;gBACAtB,kBACGA,gBAAgB0B,GAAG,CAAC,CAAC,EAAEhC,GAAG,EAAEoC,KAAK,EAAE;oBACjC,qBACE,KAACrB;wBAECC,MAAMhB;wBACNiB,SAASmB;uBAFJ,CAAC,gBAAgB,EAAEpC,IAAI,CAAC,EAAEoC,MAAM,CAAC;gBAK5C,KACA;gBACHxB;;YAEH;YACE,yDAAyD;YACzD,uBAAuB;YACvByB,sBAAsB,OAAO;QAC/B;QAGF5B,wBAAwB;QAExB,qDAAqD;QACrD,qEAAqE;QACrE,oEAAoE;QACpE,OAAOjB,eAAeuC;IACxB;AACF"}