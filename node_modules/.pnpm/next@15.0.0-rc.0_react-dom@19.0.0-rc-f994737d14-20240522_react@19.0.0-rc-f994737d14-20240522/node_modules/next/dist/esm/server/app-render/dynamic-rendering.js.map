{"version":3,"sources":["../../../src/server/app-render/dynamic-rendering.ts"],"sourcesContent":["/**\n * The functions provided by this module are used to communicate certain properties\n * about the currently running code so that Next.js can make decisions on how to handle\n * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.\n *\n * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.\n * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts\n * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of\n * Dynamic indications.\n *\n * The first is simply an intention to be dynamic. unstable_noStore is an example of this where\n * the currently executing code simply declares that the current scope is dynamic but if you use it\n * inside unstable_cache it can still be cached. This type of indication can be removed if we ever\n * make the default dynamic to begin with because the only way you would ever be static is inside\n * a cache scope which this indication does not affect.\n *\n * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic\n * because it means that it is inappropriate to cache this at all. using a dynamic data source inside\n * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should\n * read that data outside the cache and pass it in as an argument to the cached function.\n */\n\n// Once postpone is in stable we should switch to importing the postpone export directly\nimport React from 'react'\n\nimport type { StaticGenerationStore } from '../../client/components/static-generation-async-storage.external'\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { getPathname } from '../../lib/url'\n\nconst hasPostpone = typeof React.unstable_postpone === 'function'\n\ntype DynamicAccess = {\n  /**\n   * If debugging, this will contain the stack trace of where the dynamic access\n   * occurred. This is used to provide more information to the user about why\n   * their page is being rendered dynamically.\n   */\n  stack?: string\n\n  /**\n   * The expression that was accessed dynamically.\n   */\n  expression: string\n}\n\n// Stores dynamic reasons used during a render.\nexport type PrerenderState = {\n  /**\n   * When true, stack information will also be tracked during dynamic access.\n   */\n  readonly isDebugSkeleton: boolean | undefined\n\n  /**\n   * The dynamic accesses that occurred during the render.\n   */\n  readonly dynamicAccesses: DynamicAccess[]\n}\n\nexport function createPrerenderState(\n  isDebugSkeleton: boolean | undefined\n): PrerenderState {\n  return {\n    isDebugSkeleton,\n    dynamicAccesses: [],\n  }\n}\n\n/**\n * This function communicates that the current scope should be treated as dynamic.\n *\n * In most cases this function is a no-op but if called during\n * a PPR prerender it will postpone the current sub-tree.\n */\nexport function markCurrentScopeAsDynamic(\n  store: StaticGenerationStore,\n  expression: string\n): void {\n  const pathname = getPathname(store.urlPathname)\n  if (store.isUnstableCacheCallback) {\n    // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope\n    // creates a cache boundary. This is subtly different from reading a dynamic data source which is\n    // forbidden inside a cache scope.\n    return\n  } else if (store.dynamicShouldError) {\n    throw new StaticGenBailoutError(\n      `Route ${pathname} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n    )\n  } else if (\n    // We are in a prerender (PPR enabled, during build)\n    store.prerenderState\n  ) {\n    // We track that we had a dynamic scope that postponed.\n    // This will be used by the renderer to decide whether\n    // the prerender requires a resume\n    postponeWithTracking(store.prerenderState, expression, pathname)\n  } else {\n    store.revalidate = 0\n\n    if (store.isStaticGeneration) {\n      // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n      const err = new DynamicServerError(\n        `Route ${pathname} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n      )\n      store.dynamicUsageDescription = expression\n      store.dynamicUsageStack = err.stack\n\n      throw err\n    }\n  }\n}\n\n/**\n * This function communicates that some dynamic data was read. This typically would refer to accessing\n * a Request specific data store such as cookies or headers. This function is not how end-users will\n * describe reading from dynamic data sources which are valid to cache and up to the author to make\n * a determination of when to do so.\n *\n * If we are inside a cache scope we error\n * Also during a PPR Prerender we postpone\n */\nexport function trackDynamicDataAccessed(\n  store: StaticGenerationStore,\n  expression: string\n): void {\n  const pathname = getPathname(store.urlPathname)\n  if (store.isUnstableCacheCallback) {\n    throw new Error(\n      `Route ${pathname} used \"${expression}\" inside a function cached with \"unstable_cache(...)\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"${expression}\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n    )\n  } else if (store.dynamicShouldError) {\n    throw new StaticGenBailoutError(\n      `Route ${pathname} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n    )\n  } else if (\n    // We are in a prerender (PPR enabled, during build)\n    store.prerenderState\n  ) {\n    // We track that we had a dynamic scope that postponed.\n    // This will be used by the renderer to decide whether\n    // the prerender requires a resume\n    postponeWithTracking(store.prerenderState, expression, pathname)\n  } else {\n    store.revalidate = 0\n\n    if (store.isStaticGeneration) {\n      // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n      const err = new DynamicServerError(\n        `Route ${pathname} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n      )\n      store.dynamicUsageDescription = expression\n      store.dynamicUsageStack = err.stack\n\n      throw err\n    }\n  }\n}\n\n/**\n * This component will call `React.postpone` that throws the postponed error.\n */\ntype PostponeProps = {\n  reason: string\n  prerenderState: PrerenderState\n  pathname: string\n}\nexport function Postpone({\n  reason,\n  prerenderState,\n  pathname,\n}: PostponeProps): never {\n  postponeWithTracking(prerenderState, reason, pathname)\n}\n\n// @TODO refactor patch-fetch and this function to better model dynamic semantics. Currently this implementation\n// is too explicit about postponing if we are in a prerender and patch-fetch contains a lot of logic for determining\n// what makes the fetch \"dynamic\". It also doesn't handle Non PPR cases so it is isn't as consistent with the other\n// dynamic-rendering methods.\nexport function trackDynamicFetch(\n  store: StaticGenerationStore,\n  expression: string\n) {\n  // If we aren't in a prerender, or we're in an unstable cache callback, we\n  // don't need to postpone.\n  if (!store.prerenderState || store.isUnstableCacheCallback) return\n\n  postponeWithTracking(store.prerenderState, expression, store.urlPathname)\n}\n\nfunction postponeWithTracking(\n  prerenderState: PrerenderState,\n  expression: string,\n  pathname: string\n): never {\n  assertPostpone()\n  const reason =\n    `Route ${pathname} needs to bail out of prerendering at this point because it used ${expression}. ` +\n    `React throws this special object to indicate where. It should not be caught by ` +\n    `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`\n\n  prerenderState.dynamicAccesses.push({\n    // When we aren't debugging, we don't need to create another error for the\n    // stack trace.\n    stack: prerenderState.isDebugSkeleton ? new Error().stack : undefined,\n    expression,\n  })\n\n  React.unstable_postpone(reason)\n}\n\nexport function usedDynamicAPIs(prerenderState: PrerenderState): boolean {\n  return prerenderState.dynamicAccesses.length > 0\n}\n\nexport function formatDynamicAPIAccesses(\n  prerenderState: PrerenderState\n): string[] {\n  return prerenderState.dynamicAccesses\n    .filter(\n      (access): access is Required<DynamicAccess> =>\n        typeof access.stack === 'string' && access.stack.length > 0\n    )\n    .map(({ expression, stack }) => {\n      stack = stack\n        .split('\\n')\n        // Remove the \"Error: \" prefix from the first line of the stack trace as\n        // well as the first 4 lines of the stack trace which is the distance\n        // from the user code and the `new Error().stack` call.\n        .slice(4)\n        .filter((line) => {\n          // Exclude Next.js internals from the stack trace.\n          if (line.includes('node_modules/next/')) {\n            return false\n          }\n\n          // Exclude anonymous functions from the stack trace.\n          if (line.includes(' (<anonymous>)')) {\n            return false\n          }\n\n          // Exclude Node.js internals from the stack trace.\n          if (line.includes(' (node:')) {\n            return false\n          }\n\n          return true\n        })\n        .join('\\n')\n      return `Dynamic API Usage Debug - ${expression}:\\n${stack}`\n    })\n}\n\nfunction assertPostpone() {\n  if (!hasPostpone) {\n    throw new Error(\n      `Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`\n    )\n  }\n}\n\n/**\n * This is a bit of a hack to allow us to abort a render using a Postpone instance instead of an Error which changes React's\n * abort semantics slightly.\n */\nexport function createPostponedAbortSignal(reason: string): AbortSignal {\n  assertPostpone()\n  const controller = new AbortController()\n  // We get our hands on a postpone instance by calling postpone and catching the throw\n  try {\n    React.unstable_postpone(reason)\n  } catch (x: unknown) {\n    controller.abort(x)\n  }\n  return controller.signal\n}\n"],"names":["React","DynamicServerError","StaticGenBailoutError","getPathname","hasPostpone","unstable_postpone","createPrerenderState","isDebugSkeleton","dynamicAccesses","markCurrentScopeAsDynamic","store","expression","pathname","urlPathname","isUnstableCacheCallback","dynamicShouldError","prerenderState","postponeWithTracking","revalidate","isStaticGeneration","err","dynamicUsageDescription","dynamicUsageStack","stack","trackDynamicDataAccessed","Error","Postpone","reason","trackDynamicFetch","assertPostpone","push","undefined","usedDynamicAPIs","length","formatDynamicAPIAccesses","filter","access","map","split","slice","line","includes","join","createPostponedAbortSignal","controller","AbortController","x","abort","signal"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"AAAA;;;;;;;;;;;;;;;;;;;;CAoBC,GAED,wFAAwF;AACxF,OAAOA,WAAW,QAAO;AAGzB,SAASC,kBAAkB,QAAQ,+CAA8C;AACjF,SAASC,qBAAqB,QAAQ,oDAAmD;AACzF,SAASC,WAAW,QAAQ,gBAAe;AAE3C,MAAMC,cAAc,OAAOJ,MAAMK,iBAAiB,KAAK;AA6BvD,OAAO,SAASC,qBACdC,eAAoC;IAEpC,OAAO;QACLA;QACAC,iBAAiB,EAAE;IACrB;AACF;AAEA;;;;;CAKC,GACD,OAAO,SAASC,0BACdC,KAA4B,EAC5BC,UAAkB;IAElB,MAAMC,WAAWT,YAAYO,MAAMG,WAAW;IAC9C,IAAIH,MAAMI,uBAAuB,EAAE;QACjC,6FAA6F;QAC7F,iGAAiG;QACjG,kCAAkC;QAClC;IACF,OAAO,IAAIJ,MAAMK,kBAAkB,EAAE;QACnC,MAAM,IAAIb,sBACR,CAAC,MAAM,EAAEU,SAAS,8EAA8E,EAAED,WAAW,4HAA4H,CAAC;IAE9O,OAAO,IACL,oDAAoD;IACpDD,MAAMM,cAAc,EACpB;QACA,uDAAuD;QACvD,sDAAsD;QACtD,kCAAkC;QAClCC,qBAAqBP,MAAMM,cAAc,EAAEL,YAAYC;IACzD,OAAO;QACLF,MAAMQ,UAAU,GAAG;QAEnB,IAAIR,MAAMS,kBAAkB,EAAE;YAC5B,uGAAuG;YACvG,MAAMC,MAAM,IAAInB,mBACd,CAAC,MAAM,EAAEW,SAAS,iDAAiD,EAAED,WAAW,2EAA2E,CAAC;YAE9JD,MAAMW,uBAAuB,GAAGV;YAChCD,MAAMY,iBAAiB,GAAGF,IAAIG,KAAK;YAEnC,MAAMH;QACR;IACF;AACF;AAEA;;;;;;;;CAQC,GACD,OAAO,SAASI,yBACdd,KAA4B,EAC5BC,UAAkB;IAElB,MAAMC,WAAWT,YAAYO,MAAMG,WAAW;IAC9C,IAAIH,MAAMI,uBAAuB,EAAE;QACjC,MAAM,IAAIW,MACR,CAAC,MAAM,EAAEb,SAAS,OAAO,EAAED,WAAW,iLAAiL,EAAEA,WAAW,6KAA6K,CAAC;IAEtZ,OAAO,IAAID,MAAMK,kBAAkB,EAAE;QACnC,MAAM,IAAIb,sBACR,CAAC,MAAM,EAAEU,SAAS,8EAA8E,EAAED,WAAW,4HAA4H,CAAC;IAE9O,OAAO,IACL,oDAAoD;IACpDD,MAAMM,cAAc,EACpB;QACA,uDAAuD;QACvD,sDAAsD;QACtD,kCAAkC;QAClCC,qBAAqBP,MAAMM,cAAc,EAAEL,YAAYC;IACzD,OAAO;QACLF,MAAMQ,UAAU,GAAG;QAEnB,IAAIR,MAAMS,kBAAkB,EAAE;YAC5B,uGAAuG;YACvG,MAAMC,MAAM,IAAInB,mBACd,CAAC,MAAM,EAAEW,SAAS,iDAAiD,EAAED,WAAW,2EAA2E,CAAC;YAE9JD,MAAMW,uBAAuB,GAAGV;YAChCD,MAAMY,iBAAiB,GAAGF,IAAIG,KAAK;YAEnC,MAAMH;QACR;IACF;AACF;AAUA,OAAO,SAASM,SAAS,EACvBC,MAAM,EACNX,cAAc,EACdJ,QAAQ,EACM;IACdK,qBAAqBD,gBAAgBW,QAAQf;AAC/C;AAEA,gHAAgH;AAChH,oHAAoH;AACpH,mHAAmH;AACnH,6BAA6B;AAC7B,OAAO,SAASgB,kBACdlB,KAA4B,EAC5BC,UAAkB;IAElB,0EAA0E;IAC1E,0BAA0B;IAC1B,IAAI,CAACD,MAAMM,cAAc,IAAIN,MAAMI,uBAAuB,EAAE;IAE5DG,qBAAqBP,MAAMM,cAAc,EAAEL,YAAYD,MAAMG,WAAW;AAC1E;AAEA,SAASI,qBACPD,cAA8B,EAC9BL,UAAkB,EAClBC,QAAgB;IAEhBiB;IACA,MAAMF,SACJ,CAAC,MAAM,EAAEf,SAAS,iEAAiE,EAAED,WAAW,EAAE,CAAC,GACnG,CAAC,+EAA+E,CAAC,GACjF,CAAC,iFAAiF,CAAC;IAErFK,eAAeR,eAAe,CAACsB,IAAI,CAAC;QAClC,0EAA0E;QAC1E,eAAe;QACfP,OAAOP,eAAeT,eAAe,GAAG,IAAIkB,QAAQF,KAAK,GAAGQ;QAC5DpB;IACF;IAEAX,MAAMK,iBAAiB,CAACsB;AAC1B;AAEA,OAAO,SAASK,gBAAgBhB,cAA8B;IAC5D,OAAOA,eAAeR,eAAe,CAACyB,MAAM,GAAG;AACjD;AAEA,OAAO,SAASC,yBACdlB,cAA8B;IAE9B,OAAOA,eAAeR,eAAe,CAClC2B,MAAM,CACL,CAACC,SACC,OAAOA,OAAOb,KAAK,KAAK,YAAYa,OAAOb,KAAK,CAACU,MAAM,GAAG,GAE7DI,GAAG,CAAC,CAAC,EAAE1B,UAAU,EAAEY,KAAK,EAAE;QACzBA,QAAQA,MACLe,KAAK,CAAC,KACP,wEAAwE;QACxE,qEAAqE;QACrE,uDAAuD;SACtDC,KAAK,CAAC,GACNJ,MAAM,CAAC,CAACK;YACP,kDAAkD;YAClD,IAAIA,KAAKC,QAAQ,CAAC,uBAAuB;gBACvC,OAAO;YACT;YAEA,oDAAoD;YACpD,IAAID,KAAKC,QAAQ,CAAC,mBAAmB;gBACnC,OAAO;YACT;YAEA,kDAAkD;YAClD,IAAID,KAAKC,QAAQ,CAAC,YAAY;gBAC5B,OAAO;YACT;YAEA,OAAO;QACT,GACCC,IAAI,CAAC;QACR,OAAO,CAAC,0BAA0B,EAAE/B,WAAW,GAAG,EAAEY,MAAM,CAAC;IAC7D;AACJ;AAEA,SAASM;IACP,IAAI,CAACzB,aAAa;QAChB,MAAM,IAAIqB,MACR,CAAC,gIAAgI,CAAC;IAEtI;AACF;AAEA;;;CAGC,GACD,OAAO,SAASkB,2BAA2BhB,MAAc;IACvDE;IACA,MAAMe,aAAa,IAAIC;IACvB,qFAAqF;IACrF,IAAI;QACF7C,MAAMK,iBAAiB,CAACsB;IAC1B,EAAE,OAAOmB,GAAY;QACnBF,WAAWG,KAAK,CAACD;IACnB;IACA,OAAOF,WAAWI,MAAM;AAC1B"}