{"version":3,"sources":["../../../../../src/server/future/route-modules/app-route/module.ts"],"sourcesContent":["import type { NextConfig } from '../../../config-shared'\nimport type { AppRouteRouteDefinition } from '../../route-definitions/app-route-route-definition'\nimport type { AppConfig } from '../../../../build/utils'\nimport type { NextRequest } from '../../../web/spec-extension/request'\nimport type { PrerenderManifest } from '../../../../build'\nimport type { NextURL } from '../../../web/next-url'\nimport type { DeepReadonly } from '../../../../shared/lib/deep-readonly'\n\nimport {\n  RouteModule,\n  type RouteModuleHandleContext,\n  type RouteModuleOptions,\n} from '../route-module'\nimport {\n  RequestAsyncStorageWrapper,\n  type RequestContext,\n} from '../../../async-storage/request-async-storage-wrapper'\nimport {\n  StaticGenerationAsyncStorageWrapper,\n  type StaticGenerationContext,\n} from '../../../async-storage/static-generation-async-storage-wrapper'\nimport {\n  handleBadRequestResponse,\n  handleInternalServerErrorResponse,\n} from '../helpers/response-handlers'\nimport { type HTTP_METHOD, HTTP_METHODS, isHTTPMethod } from '../../../web/http'\nimport { addImplicitTags, patchFetch } from '../../../lib/patch-fetch'\nimport { getTracer } from '../../../lib/trace/tracer'\nimport { AppRouteRouteHandlersSpan } from '../../../lib/trace/constants'\nimport { getPathnameFromAbsolutePath } from './helpers/get-pathname-from-absolute-path'\nimport { resolveHandlerError } from './helpers/resolve-handler-error'\nimport * as Log from '../../../../build/output/log'\nimport { autoImplementMethods } from './helpers/auto-implement-methods'\nimport {\n  appendMutableCookies,\n  type ReadonlyRequestCookies,\n} from '../../../web/spec-extension/adapters/request-cookies'\nimport { HeadersAdapter } from '../../../web/spec-extension/adapters/headers'\nimport { RequestCookiesAdapter } from '../../../web/spec-extension/adapters/request-cookies'\nimport { parsedUrlQueryToParams } from './helpers/parsed-url-query-to-params'\n\nimport * as serverHooks from '../../../../client/components/hooks-server-context'\nimport { DynamicServerError } from '../../../../client/components/hooks-server-context'\n\nimport { requestAsyncStorage } from '../../../../client/components/request-async-storage.external'\nimport { staticGenerationAsyncStorage } from '../../../../client/components/static-generation-async-storage.external'\nimport { actionAsyncStorage } from '../../../../client/components/action-async-storage.external'\nimport * as sharedModules from './shared-modules'\nimport { getIsServerAction } from '../../../lib/server-action-request-meta'\nimport { RequestCookies } from 'next/dist/compiled/@edge-runtime/cookies'\nimport { cleanURL } from './helpers/clean-url'\nimport { StaticGenBailoutError } from '../../../../client/components/static-generation-bailout'\nimport { isStaticGenEnabled } from './helpers/is-static-gen-enabled'\n\n/**\n * The AppRouteModule is the type of the module exported by the bundled App\n * Route module.\n */\nexport type AppRouteModule =\n  typeof import('../../../../build/templates/app-route')\n\n/**\n * AppRouteRouteHandlerContext is the context that is passed to the route\n * handler for app routes.\n */\nexport interface AppRouteRouteHandlerContext extends RouteModuleHandleContext {\n  renderOpts: StaticGenerationContext['renderOpts']\n  prerenderManifest: DeepReadonly<PrerenderManifest>\n}\n\n/**\n * AppRouteHandlerFnContext is the context that is passed to the handler as the\n * second argument.\n */\ntype AppRouteHandlerFnContext = {\n  params?: Record<string, string | string[]>\n}\n\n/**\n * Handler function for app routes. If a non-Response value is returned, an error\n * will be thrown.\n */\nexport type AppRouteHandlerFn = (\n  /**\n   * Incoming request object.\n   */\n  req: NextRequest,\n  /**\n   * Context properties on the request (including the parameters if this was a\n   * dynamic route).\n   */\n  ctx: AppRouteHandlerFnContext\n) => unknown\n\n/**\n * AppRouteHandlers describes the handlers for app routes that is provided by\n * the userland module.\n */\nexport type AppRouteHandlers = {\n  [method in HTTP_METHOD]?: AppRouteHandlerFn\n}\n\n/**\n * AppRouteUserlandModule is the userland module that is provided for app\n * routes. This contains all the user generated code.\n */\nexport type AppRouteUserlandModule = AppRouteHandlers &\n  Pick<AppConfig, 'dynamic' | 'revalidate' | 'dynamicParams' | 'fetchCache'> & {\n    // TODO: (wyattjoh) create a type for this\n    generateStaticParams?: any\n  }\n\n/**\n * AppRouteRouteModuleOptions is the options that are passed to the app route\n * module from the bundled code.\n */\nexport interface AppRouteRouteModuleOptions\n  extends RouteModuleOptions<AppRouteRouteDefinition, AppRouteUserlandModule> {\n  readonly resolvedPagePath: string\n  readonly nextConfigOutput: NextConfig['output']\n}\n\n/**\n * AppRouteRouteHandler is the handler for app routes.\n */\nexport class AppRouteRouteModule extends RouteModule<\n  AppRouteRouteDefinition,\n  AppRouteUserlandModule\n> {\n  /**\n   * A reference to the request async storage.\n   */\n  public readonly requestAsyncStorage = requestAsyncStorage\n\n  /**\n   * A reference to the static generation async storage.\n   */\n  public readonly staticGenerationAsyncStorage = staticGenerationAsyncStorage\n\n  /**\n   * An interface to call server hooks which interact with the underlying\n   * storage.\n   */\n  public readonly serverHooks = serverHooks\n\n  public static readonly sharedModules = sharedModules\n\n  /**\n   * A reference to the mutation related async storage, such as mutations of\n   * cookies.\n   */\n  public readonly actionAsyncStorage = actionAsyncStorage\n\n  public readonly resolvedPagePath: string\n  public readonly nextConfigOutput: NextConfig['output'] | undefined\n\n  private readonly methods: Record<HTTP_METHOD, AppRouteHandlerFn>\n  private readonly hasNonStaticMethods: boolean\n  private readonly dynamic: AppRouteUserlandModule['dynamic']\n\n  constructor({\n    userland,\n    definition,\n    resolvedPagePath,\n    nextConfigOutput,\n  }: AppRouteRouteModuleOptions) {\n    super({ userland, definition })\n\n    this.resolvedPagePath = resolvedPagePath\n    this.nextConfigOutput = nextConfigOutput\n\n    // Automatically implement some methods if they aren't implemented by the\n    // userland module.\n    this.methods = autoImplementMethods(userland)\n\n    // Get the non-static methods for this route.\n    this.hasNonStaticMethods = hasNonStaticMethods(userland)\n\n    // Get the dynamic property from the userland module.\n    this.dynamic = this.userland.dynamic\n    if (this.nextConfigOutput === 'export') {\n      if (this.dynamic === 'force-dynamic') {\n        throw new Error(\n          `export const dynamic = \"force-dynamic\" on page \"${definition.pathname}\" cannot be used with \"output: export\". See more info here: https://nextjs.org/docs/advanced-features/static-html-export`\n        )\n      } else if (!isStaticGenEnabled(this.userland) && this.userland['GET']) {\n        throw new Error(\n          `export const dynamic = \"force-static\"/export const revalidate not configured on route \"${definition.pathname}\" with \"output: export\". See more info here: https://nextjs.org/docs/advanced-features/static-html-export`\n        )\n      } else {\n        this.dynamic = 'error'\n      }\n    }\n\n    // We only warn in development after here, so return if we're not in\n    // development.\n    if (process.env.NODE_ENV === 'development') {\n      // Print error in development if the exported handlers are in lowercase, only\n      // uppercase handlers are supported.\n      const lowercased = HTTP_METHODS.map((method) => method.toLowerCase())\n      for (const method of lowercased) {\n        if (method in this.userland) {\n          Log.error(\n            `Detected lowercase method '${method}' in '${\n              this.resolvedPagePath\n            }'. Export the uppercase '${method.toUpperCase()}' method name to fix this error.`\n          )\n        }\n      }\n\n      // Print error if the module exports a default handler, they must use named\n      // exports for each HTTP method.\n      if ('default' in this.userland) {\n        Log.error(\n          `Detected default export in '${this.resolvedPagePath}'. Export a named export for each HTTP method instead.`\n        )\n      }\n\n      // If there is no methods exported by this module, then return a not found\n      // response.\n      if (!HTTP_METHODS.some((method) => method in this.userland)) {\n        Log.error(\n          `No HTTP methods exported in '${this.resolvedPagePath}'. Export a named export for each HTTP method.`\n        )\n      }\n    }\n  }\n\n  /**\n   * Resolves the handler function for the given method.\n   *\n   * @param method the requested method\n   * @returns the handler function for the given method\n   */\n  private resolve(method: string): AppRouteHandlerFn {\n    // Ensure that the requested method is a valid method (to prevent RCE's).\n    if (!isHTTPMethod(method)) return handleBadRequestResponse\n\n    // Return the handler.\n    return this.methods[method]\n  }\n\n  /**\n   * Executes the route handler.\n   */\n  private async execute(\n    rawRequest: NextRequest,\n    context: AppRouteRouteHandlerContext\n  ): Promise<Response> {\n    // Get the handler function for the given method.\n    const handler = this.resolve(rawRequest.method)\n\n    // Get the context for the request.\n    const requestContext: RequestContext = {\n      req: rawRequest,\n    }\n\n    requestContext.renderOpts = {\n      // @ts-expect-error TODO: types for renderOpts should include previewProps\n      previewProps: context.prerenderManifest.preview,\n      waitUntil: context.renderOpts.waitUntil,\n      onClose: context.renderOpts.onClose,\n      experimental: context.renderOpts.experimental,\n    }\n\n    // Get the context for the static generation.\n    const staticGenerationContext: StaticGenerationContext = {\n      urlPathname: rawRequest.nextUrl.pathname,\n      renderOpts: context.renderOpts,\n    }\n\n    // Add the fetchCache option to the renderOpts.\n    staticGenerationContext.renderOpts.fetchCache = this.userland.fetchCache\n\n    // Run the handler with the request AsyncLocalStorage to inject the helper\n    // support. We set this to `unknown` because the type is not known until\n    // runtime when we do a instanceof check below.\n    const response: unknown = await this.actionAsyncStorage.run(\n      {\n        isAppRoute: true,\n        isAction: getIsServerAction(rawRequest),\n      },\n      () =>\n        RequestAsyncStorageWrapper.wrap(\n          this.requestAsyncStorage,\n          requestContext,\n          () =>\n            StaticGenerationAsyncStorageWrapper.wrap(\n              this.staticGenerationAsyncStorage,\n              staticGenerationContext,\n              (staticGenerationStore) => {\n                // Check to see if we should bail out of static generation based on\n                // having non-static methods.\n                const isStaticGeneration =\n                  staticGenerationStore.isStaticGeneration\n\n                if (this.hasNonStaticMethods) {\n                  if (isStaticGeneration) {\n                    const err = new DynamicServerError(\n                      'Route is configured with methods that cannot be statically generated.'\n                    )\n                    staticGenerationStore.dynamicUsageDescription = err.message\n                    staticGenerationStore.dynamicUsageStack = err.stack\n                    throw err\n                  } else {\n                    // We aren't statically generating but since this route has non-static methods\n                    // we still need to set the default caching to no cache by setting revalidate = 0\n                    // @TODO this type of logic is too indirect. we need to refactor how we set fetch cache\n                    // behavior. Prior to the most recent refactor this logic was buried deep in staticGenerationBailout\n                    // so it is possible it was unintentional and then tests were written to assert the current behavior\n                    staticGenerationStore.revalidate = 0\n                  }\n                }\n\n                // We assume we can pass the original request through however we may end up\n                // proxying it in certain circumstances based on execution type and configuration\n                let request = rawRequest\n\n                // Update the static generation store based on the dynamic property.\n                if (isStaticGeneration) {\n                  switch (this.dynamic) {\n                    case 'force-dynamic': {\n                      // Routes of generated paths should be dynamic\n                      staticGenerationStore.forceDynamic = true\n                      break\n                    }\n                    case 'force-static':\n                      // The dynamic property is set to force-static, so we should\n                      // force the page to be static.\n                      staticGenerationStore.forceStatic = true\n                      // We also Proxy the request to replace dynamic data on the request\n                      // with empty stubs to allow for safely executing as static\n                      request = new Proxy(\n                        rawRequest,\n                        forceStaticRequestHandlers\n                      )\n                      break\n                    case 'error':\n                      // The dynamic property is set to error, so we should throw an\n                      // error if the page is being statically generated.\n                      staticGenerationStore.dynamicShouldError = true\n                      if (isStaticGeneration)\n                        request = new Proxy(\n                          rawRequest,\n                          requireStaticRequestHandlers\n                        )\n                      break\n                    default:\n                      // When we are statically generating a route we want to bail out if anything dynamic\n                      // is accessed. We only create this proxy in the staticGenerationCase because it is overhead\n                      // for dynamic runtime executions\n                      request = new Proxy(\n                        rawRequest,\n                        staticGenerationRequestHandlers\n                      )\n                  }\n                } else {\n                  // Generally if we are in a dynamic render we don't have to modify much however for\n                  // force-static specifically we ensure the dynamic and static behavior is consistent\n                  // by proxying the request in the same way in both cases\n                  if (this.dynamic === 'force-static') {\n                    // The dynamic property is set to force-static, so we should\n                    // force the page to be static.\n                    staticGenerationStore.forceStatic = true\n                    request = new Proxy(rawRequest, forceStaticRequestHandlers)\n                  }\n                }\n\n                // If the static generation store does not have a revalidate value\n                // set, then we should set it the revalidate value from the userland\n                // module or default to false.\n                staticGenerationStore.revalidate ??=\n                  this.userland.revalidate ?? false\n\n                // TODO: propagate this pathname from route matcher\n                const route = getPathnameFromAbsolutePath(this.resolvedPagePath)\n                getTracer().getRootSpanAttributes()?.set('next.route', route)\n                return getTracer().trace(\n                  AppRouteRouteHandlersSpan.runHandler,\n                  {\n                    spanName: `executing api route (app) ${route}`,\n                    attributes: {\n                      'next.route': route,\n                    },\n                  },\n                  async () => {\n                    // Patch the global fetch.\n                    patchFetch({\n                      serverHooks: this.serverHooks,\n                      staticGenerationAsyncStorage:\n                        this.staticGenerationAsyncStorage,\n                    })\n                    const res = await handler(request, {\n                      params: context.params\n                        ? parsedUrlQueryToParams(context.params)\n                        : undefined,\n                    })\n                    if (!(res instanceof Response)) {\n                      throw new Error(\n                        `No response is returned from route handler '${this.resolvedPagePath}'. Ensure you return a \\`Response\\` or a \\`NextResponse\\` in all branches of your handler.`\n                      )\n                    }\n                    context.renderOpts.fetchMetrics =\n                      staticGenerationStore.fetchMetrics\n\n                    context.renderOpts.pendingWaitUntil = Promise.all([\n                      staticGenerationStore.incrementalCache?.revalidateTag(\n                        staticGenerationStore.revalidatedTags || []\n                      ),\n                      ...Object.values(\n                        staticGenerationStore.pendingRevalidates || {}\n                      ),\n                    ])\n\n                    addImplicitTags(staticGenerationStore)\n                    ;(context.renderOpts as any).fetchTags =\n                      staticGenerationStore.tags?.join(',')\n\n                    // It's possible cookies were set in the handler, so we need\n                    // to merge the modified cookies and the returned response\n                    // here.\n                    const requestStore = this.requestAsyncStorage.getStore()\n                    if (requestStore && requestStore.mutableCookies) {\n                      const headers = new Headers(res.headers)\n                      if (\n                        appendMutableCookies(\n                          headers,\n                          requestStore.mutableCookies\n                        )\n                      ) {\n                        return new Response(res.body, {\n                          status: res.status,\n                          statusText: res.statusText,\n                          headers,\n                        })\n                      }\n                    }\n\n                    return res\n                  }\n                )\n              }\n            )\n        )\n    )\n\n    // If the handler did't return a valid response, then return the internal\n    // error response.\n    if (!(response instanceof Response)) {\n      // TODO: validate the correct handling behavior, maybe log something?\n      return handleInternalServerErrorResponse()\n    }\n\n    if (response.headers.has('x-middleware-rewrite')) {\n      // TODO: move this error into the `NextResponse.rewrite()` function.\n      // TODO-APP: re-enable support below when we can proxy these type of requests\n      throw new Error(\n        'NextResponse.rewrite() was used in a app route handler, this is not currently supported. Please remove the invocation to continue.'\n      )\n\n      // // This is a rewrite created via `NextResponse.rewrite()`. We need to send\n      // // the response up so it can be handled by the backing server.\n\n      // // If the server is running in minimal mode, we just want to forward the\n      // // response (including the rewrite headers) upstream so it can perform the\n      // // redirect for us, otherwise return with the special condition so this\n      // // server can perform a rewrite.\n      // if (!minimalMode) {\n      //   return { response, condition: 'rewrite' }\n      // }\n\n      // // Relativize the url so it's relative to the base url. This is so the\n      // // outgoing headers upstream can be relative.\n      // const rewritePath = response.headers.get('x-middleware-rewrite')!\n      // const initUrl = getRequestMeta(req, 'initURL')!\n      // const { pathname } = parseUrl(relativizeURL(rewritePath, initUrl))\n      // response.headers.set('x-middleware-rewrite', pathname)\n    }\n\n    if (response.headers.get('x-middleware-next') === '1') {\n      // TODO: move this error into the `NextResponse.next()` function.\n      throw new Error(\n        'NextResponse.next() was used in a app route handler, this is not supported. See here for more info: https://nextjs.org/docs/messages/next-response-next-in-app-route-handler'\n      )\n    }\n\n    return response\n  }\n\n  public async handle(\n    request: NextRequest,\n    context: AppRouteRouteHandlerContext\n  ): Promise<Response> {\n    try {\n      // Execute the route to get the response.\n      const response = await this.execute(request, context)\n\n      // The response was handled, return it.\n      return response\n    } catch (err) {\n      // Try to resolve the error to a response, else throw it again.\n      const response = resolveHandlerError(err)\n      if (!response) throw err\n\n      // The response was resolved, return it.\n      return response\n    }\n  }\n}\n\nexport default AppRouteRouteModule\n\n/**\n * Gets all the method names for handlers that are not considered static.\n *\n * @param handlers the handlers from the userland module\n * @returns the method names that are not considered static or false if all\n *          methods are static\n */\nexport function hasNonStaticMethods(handlers: AppRouteHandlers): boolean {\n  if (\n    // Order these by how common they are to be used\n    handlers.POST ||\n    handlers.POST ||\n    handlers.DELETE ||\n    handlers.PATCH ||\n    handlers.OPTIONS\n  ) {\n    return true\n  }\n  return false\n}\n\n// These symbols will be used to stash cached values on Proxied requests without requiring\n// additional closures or storage such as WeakMaps.\nconst nextURLSymbol = Symbol('nextUrl')\nconst requestCloneSymbol = Symbol('clone')\nconst urlCloneSymbol = Symbol('clone')\nconst searchParamsSymbol = Symbol('searchParams')\nconst hrefSymbol = Symbol('href')\nconst toStringSymbol = Symbol('toString')\nconst headersSymbol = Symbol('headers')\nconst cookiesSymbol = Symbol('cookies')\n\ntype RequestSymbolTarget = {\n  [headersSymbol]?: Headers\n  [cookiesSymbol]?: RequestCookies | ReadonlyRequestCookies\n  [nextURLSymbol]?: NextURL\n  [requestCloneSymbol]?: () => NextRequest\n}\n\ntype UrlSymbolTarget = {\n  [searchParamsSymbol]?: URLSearchParams\n  [hrefSymbol]?: string\n  [toStringSymbol]?: () => string\n  [urlCloneSymbol]?: () => NextURL\n}\n\n/**\n * The general technique with these proxy handlers is to prioritize keeping them static\n * by stashing computed values on the Proxy itself. This is safe because the Proxy is\n * inaccessible to the consumer since all operations are forwarded\n */\nconst forceStaticRequestHandlers = {\n  get(\n    target: NextRequest & RequestSymbolTarget,\n    prop: string | symbol,\n    receiver: any\n  ): unknown {\n    switch (prop) {\n      case 'headers':\n        return (\n          target[headersSymbol] ||\n          (target[headersSymbol] = HeadersAdapter.seal(new Headers({})))\n        )\n      case 'cookies':\n        return (\n          target[cookiesSymbol] ||\n          (target[cookiesSymbol] = RequestCookiesAdapter.seal(\n            new RequestCookies(new Headers({}))\n          ))\n        )\n      case 'nextUrl':\n        return (\n          target[nextURLSymbol] ||\n          (target[nextURLSymbol] = new Proxy(\n            target.nextUrl,\n            forceStaticNextUrlHandlers\n          ))\n        )\n      case 'url':\n        // we don't need to separately cache this we can just read the nextUrl\n        // and return the href since we know it will have been stripped of any\n        // dynamic parts. We access via the receiver to trigger the get trap\n        return receiver.nextUrl.href\n      case 'geo':\n      case 'ip':\n        return undefined\n      case 'clone':\n        return (\n          target[requestCloneSymbol] ||\n          (target[requestCloneSymbol] = () =>\n            new Proxy(\n              // This is vaguely unsafe but it's required since NextRequest does not implement\n              // clone. The reason we might expect this to work in this context is the Proxy will\n              // respond with static-amenable values anyway somewhat restoring the interface.\n              // @TODO we need to rethink NextRequest and NextURL because they are not sufficientlly\n              // sophisticated to adequately represent themselves in all contexts. A better approach is\n              // to probably embed the static generation logic into the class itself removing the need\n              // for any kind of proxying\n              target.clone() as NextRequest,\n              forceStaticRequestHandlers\n            ))\n        )\n      default:\n        const result = Reflect.get(target, prop, receiver)\n        if (typeof result === 'function') {\n          return result.bind(target)\n        }\n        return result\n    }\n  },\n  // We don't need to proxy set because all the properties we proxy are ready only\n  // and will be ignored\n}\n\nconst forceStaticNextUrlHandlers = {\n  get(\n    target: NextURL & UrlSymbolTarget,\n    prop: string | symbol,\n    receiver: any\n  ): unknown {\n    switch (prop) {\n      // URL properties\n      case 'search':\n        return ''\n      case 'searchParams':\n        return (\n          target[searchParamsSymbol] ||\n          (target[searchParamsSymbol] = new URLSearchParams())\n        )\n      case 'href':\n        return (\n          target[hrefSymbol] ||\n          (target[hrefSymbol] = cleanURL(target.href).href)\n        )\n      case 'toJSON':\n      case 'toString':\n        return (\n          target[toStringSymbol] ||\n          (target[toStringSymbol] = () => receiver.href)\n        )\n\n      // NextUrl properties\n      case 'url':\n        // Currently nextURL does not expose url but our Docs indicate that it is an available property\n        // I am forcing this to undefined here to avoid accidentally exposing a dynamic value later if\n        // the underlying nextURL ends up adding this property\n        return undefined\n      case 'clone':\n        return (\n          target[urlCloneSymbol] ||\n          (target[urlCloneSymbol] = () =>\n            new Proxy(target.clone(), forceStaticNextUrlHandlers))\n        )\n      default:\n        const result = Reflect.get(target, prop, receiver)\n        if (typeof result === 'function') {\n          return result.bind(target)\n        }\n        return result\n    }\n  },\n}\n\nconst staticGenerationRequestHandlers = {\n  get(\n    target: NextRequest & RequestSymbolTarget,\n    prop: string | symbol,\n    receiver: any\n  ): unknown {\n    switch (prop) {\n      case 'nextUrl':\n        return (\n          target[nextURLSymbol] ||\n          (target[nextURLSymbol] = new Proxy(\n            target.nextUrl,\n            staticGenerationNextUrlHandlers\n          ))\n        )\n      case 'headers':\n      case 'cookies':\n      case 'url':\n      case 'body':\n      case 'blob':\n      case 'json':\n      case 'text':\n      case 'arrayBuffer':\n      case 'formData':\n        throw new DynamicServerError(\n          `Route ${target.nextUrl.pathname} couldn't be rendered statically because it accessed \\`request.${prop}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n        )\n      case 'clone':\n        return (\n          target[requestCloneSymbol] ||\n          (target[requestCloneSymbol] = () =>\n            new Proxy(\n              // This is vaguely unsafe but it's required since NextRequest does not implement\n              // clone. The reason we might expect this to work in this context is the Proxy will\n              // respond with static-amenable values anyway somewhat restoring the interface.\n              // @TODO we need to rethink NextRequest and NextURL because they are not sufficientlly\n              // sophisticated to adequately represent themselves in all contexts. A better approach is\n              // to probably embed the static generation logic into the class itself removing the need\n              // for any kind of proxying\n              target.clone() as NextRequest,\n              staticGenerationRequestHandlers\n            ))\n        )\n      default:\n        const result = Reflect.get(target, prop, receiver)\n        if (typeof result === 'function') {\n          return result.bind(target)\n        }\n        return result\n    }\n  },\n  // We don't need to proxy set because all the properties we proxy are ready only\n  // and will be ignored\n}\n\nconst staticGenerationNextUrlHandlers = {\n  get(\n    target: NextURL & UrlSymbolTarget,\n    prop: string | symbol,\n    receiver: any\n  ): unknown {\n    switch (prop) {\n      case 'search':\n      case 'searchParams':\n      case 'url':\n      case 'href':\n      case 'toJSON':\n      case 'toString':\n      case 'origin':\n        throw new DynamicServerError(\n          `Route ${target.pathname} couldn't be rendered statically because it accessed \\`nextUrl.${prop}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n        )\n      case 'clone':\n        return (\n          target[urlCloneSymbol] ||\n          (target[urlCloneSymbol] = () =>\n            new Proxy(target.clone(), staticGenerationNextUrlHandlers))\n        )\n      default:\n        const result = Reflect.get(target, prop, receiver)\n        if (typeof result === 'function') {\n          return result.bind(target)\n        }\n        return result\n    }\n  },\n}\n\nconst requireStaticRequestHandlers = {\n  get(\n    target: NextRequest & RequestSymbolTarget,\n    prop: string | symbol,\n    receiver: any\n  ): unknown {\n    switch (prop) {\n      case 'nextUrl':\n        return (\n          target[nextURLSymbol] ||\n          (target[nextURLSymbol] = new Proxy(\n            target.nextUrl,\n            requireStaticNextUrlHandlers\n          ))\n        )\n      case 'headers':\n      case 'cookies':\n      case 'url':\n      case 'body':\n      case 'blob':\n      case 'json':\n      case 'text':\n      case 'arrayBuffer':\n      case 'formData':\n        throw new StaticGenBailoutError(\n          `Route ${target.nextUrl.pathname} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it accessed \\`request.${prop}\\`.`\n        )\n      case 'clone':\n        return (\n          target[requestCloneSymbol] ||\n          (target[requestCloneSymbol] = () =>\n            new Proxy(\n              // This is vaguely unsafe but it's required since NextRequest does not implement\n              // clone. The reason we might expect this to work in this context is the Proxy will\n              // respond with static-amenable values anyway somewhat restoring the interface.\n              // @TODO we need to rethink NextRequest and NextURL because they are not sufficientlly\n              // sophisticated to adequately represent themselves in all contexts. A better approach is\n              // to probably embed the static generation logic into the class itself removing the need\n              // for any kind of proxying\n              target.clone() as NextRequest,\n              requireStaticRequestHandlers\n            ))\n        )\n      default:\n        const result = Reflect.get(target, prop, receiver)\n        if (typeof result === 'function') {\n          return result.bind(target)\n        }\n        return result\n    }\n  },\n  // We don't need to proxy set because all the properties we proxy are ready only\n  // and will be ignored\n}\n\nconst requireStaticNextUrlHandlers = {\n  get(\n    target: NextURL & UrlSymbolTarget,\n    prop: string | symbol,\n    receiver: any\n  ): unknown {\n    switch (prop) {\n      case 'search':\n      case 'searchParams':\n      case 'url':\n      case 'href':\n      case 'toJSON':\n      case 'toString':\n      case 'origin':\n        throw new StaticGenBailoutError(\n          `Route ${target.pathname} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it accessed \\`nextUrl.${prop}\\`.`\n        )\n      case 'clone':\n        return (\n          target[urlCloneSymbol] ||\n          (target[urlCloneSymbol] = () =>\n            new Proxy(target.clone(), requireStaticNextUrlHandlers))\n        )\n      default:\n        const result = Reflect.get(target, prop, receiver)\n        if (typeof result === 'function') {\n          return result.bind(target)\n        }\n        return result\n    }\n  },\n}\n"],"names":["RouteModule","RequestAsyncStorageWrapper","StaticGenerationAsyncStorageWrapper","handleBadRequestResponse","handleInternalServerErrorResponse","HTTP_METHODS","isHTTPMethod","addImplicitTags","patchFetch","getTracer","AppRouteRouteHandlersSpan","getPathnameFromAbsolutePath","resolveHandlerError","Log","autoImplementMethods","appendMutableCookies","HeadersAdapter","RequestCookiesAdapter","parsedUrlQueryToParams","serverHooks","DynamicServerError","requestAsyncStorage","staticGenerationAsyncStorage","actionAsyncStorage","sharedModules","getIsServerAction","RequestCookies","cleanURL","StaticGenBailoutError","isStaticGenEnabled","AppRouteRouteModule","constructor","userland","definition","resolvedPagePath","nextConfigOutput","methods","hasNonStaticMethods","dynamic","Error","pathname","process","env","NODE_ENV","lowercased","map","method","toLowerCase","error","toUpperCase","some","resolve","execute","rawRequest","context","handler","requestContext","req","renderOpts","previewProps","prerenderManifest","preview","waitUntil","onClose","experimental","staticGenerationContext","urlPathname","nextUrl","fetchCache","response","run","isAppRoute","isAction","wrap","staticGenerationStore","isStaticGeneration","err","dynamicUsageDescription","message","dynamicUsageStack","stack","revalidate","request","forceDynamic","forceStatic","Proxy","forceStaticRequestHandlers","dynamicShouldError","requireStaticRequestHandlers","staticGenerationRequestHandlers","route","getRootSpanAttributes","set","trace","runHandler","spanName","attributes","res","params","undefined","Response","fetchMetrics","pendingWaitUntil","Promise","all","incrementalCache","revalidateTag","revalidatedTags","Object","values","pendingRevalidates","fetchTags","tags","join","requestStore","getStore","mutableCookies","headers","Headers","body","status","statusText","has","get","handle","handlers","POST","DELETE","PATCH","OPTIONS","nextURLSymbol","Symbol","requestCloneSymbol","urlCloneSymbol","searchParamsSymbol","hrefSymbol","toStringSymbol","headersSymbol","cookiesSymbol","target","prop","receiver","seal","forceStaticNextUrlHandlers","href","clone","result","Reflect","bind","URLSearchParams","staticGenerationNextUrlHandlers","requireStaticNextUrlHandlers"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}