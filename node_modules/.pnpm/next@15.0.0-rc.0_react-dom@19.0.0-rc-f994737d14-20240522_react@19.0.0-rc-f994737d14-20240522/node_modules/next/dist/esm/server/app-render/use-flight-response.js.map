{"version":3,"sources":["../../../src/server/app-render/use-flight-response.tsx"],"sourcesContent":["import type { ClientReferenceManifest } from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { BinaryStreamOf } from './app-render'\n\nimport { htmlEscapeJsonString } from '../htmlescape'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\n\nconst isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n\nconst INLINE_FLIGHT_PAYLOAD_BOOTSTRAP = 0\nconst INLINE_FLIGHT_PAYLOAD_DATA = 1\nconst INLINE_FLIGHT_PAYLOAD_FORM_STATE = 2\n\nconst flightResponses = new WeakMap<BinaryStreamOf<any>, Promise<any>>()\nconst encoder = new TextEncoder()\n\n/**\n * Render Flight stream.\n * This is only used for renderToHTML, the Flight response does not need additional wrappers.\n */\nexport function useFlightStream<T>(\n  flightStream: BinaryStreamOf<T>,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>,\n  nonce?: string\n): Promise<T> {\n  const response = flightResponses.get(flightStream)\n\n  if (response) {\n    return response\n  }\n\n  // react-server-dom-webpack/client.edge must not be hoisted for require cache clearing to work correctly\n  let createFromReadableStream\n  // @TODO: investigate why the aliasing for turbopack doesn't pick this up, requiring this runtime check\n  if (process.env.TURBOPACK) {\n    createFromReadableStream =\n      // eslint-disable-next-line import/no-extraneous-dependencies\n      require('react-server-dom-turbopack/client.edge').createFromReadableStream\n  } else {\n    createFromReadableStream =\n      // eslint-disable-next-line import/no-extraneous-dependencies\n      require('react-server-dom-webpack/client.edge').createFromReadableStream\n  }\n\n  const newResponse = createFromReadableStream(flightStream, {\n    ssrManifest: {\n      moduleLoading: clientReferenceManifest.moduleLoading,\n      moduleMap: isEdgeRuntime\n        ? clientReferenceManifest.edgeSSRModuleMapping\n        : clientReferenceManifest.ssrModuleMapping,\n    },\n    nonce,\n  })\n\n  flightResponses.set(flightStream, newResponse)\n\n  return newResponse\n}\n\n/**\n * There are times when an SSR render may be finished but the RSC render\n * is ongoing and we need to wait for it to complete to make some determination\n * about how to handle the render. This function will drain the RSC reader and\n * resolve when completed. This will generally require teeing the RSC stream and it\n * should be noted that it will cause all the RSC chunks to queue in the underlying\n * ReadableStream however given Flight currently is a push stream that doesn't respond\n * to backpressure this shouldn't change how much memory is maximally consumed\n */\nexport async function flightRenderComplete(\n  flightStream: ReadableStream<Uint8Array>\n): Promise<void> {\n  const flightReader = flightStream.getReader()\n\n  while (true) {\n    const { done } = await flightReader.read()\n    if (done) {\n      return\n    }\n  }\n}\n\n/**\n * Creates a ReadableStream provides inline script tag chunks for writing hydration\n * data to the client outside the React render itself.\n *\n * @param flightStream The RSC render stream\n * @param nonce optionally a nonce used during this particular render\n * @param formState optionally the formState used with this particular render\n * @returns a ReadableStream without the complete property. This signifies a lazy ReadableStream\n */\nexport function createInlinedDataReadableStream(\n  flightStream: ReadableStream<Uint8Array>,\n  nonce: string | undefined,\n  formState: unknown | null\n): ReadableStream<Uint8Array> {\n  const startScriptTag = nonce\n    ? `<script nonce=${JSON.stringify(nonce)}>`\n    : '<script>'\n\n  const decoder = new TextDecoder('utf-8', { fatal: true })\n  const decoderOptions = { stream: true }\n\n  const flightReader = flightStream.getReader()\n\n  const readable = new ReadableStream({\n    type: 'bytes',\n    start(controller) {\n      try {\n        writeInitialInstructions(controller, startScriptTag, formState)\n      } catch (error) {\n        // during encoding or enqueueing forward the error downstream\n        controller.error(error)\n      }\n    },\n    async pull(controller) {\n      try {\n        const { done, value } = await flightReader.read()\n        if (done) {\n          const tail = decoder.decode(value, { stream: false })\n          if (tail.length) {\n            writeFlightDataInstruction(controller, startScriptTag, tail)\n          }\n          controller.close()\n        } else {\n          const chunkAsString = decoder.decode(value, decoderOptions)\n          writeFlightDataInstruction(controller, startScriptTag, chunkAsString)\n        }\n      } catch (error) {\n        // There was a problem in the upstream reader or during decoding or enqueuing\n        // forward the error downstream\n        controller.error(error)\n      }\n    },\n  })\n\n  return readable\n}\n\nfunction writeInitialInstructions(\n  controller: ReadableStreamDefaultController,\n  scriptStart: string,\n  formState: unknown | null\n) {\n  controller.enqueue(\n    encoder.encode(\n      `${scriptStart}(self.__next_f=self.__next_f||[]).push(${htmlEscapeJsonString(\n        JSON.stringify([INLINE_FLIGHT_PAYLOAD_BOOTSTRAP])\n      )});self.__next_f.push(${htmlEscapeJsonString(\n        JSON.stringify([INLINE_FLIGHT_PAYLOAD_FORM_STATE, formState])\n      )})</script>`\n    )\n  )\n}\n\nfunction writeFlightDataInstruction(\n  controller: ReadableStreamDefaultController,\n  scriptStart: string,\n  chunkAsString: string\n) {\n  controller.enqueue(\n    encoder.encode(\n      `${scriptStart}self.__next_f.push(${htmlEscapeJsonString(\n        JSON.stringify([INLINE_FLIGHT_PAYLOAD_DATA, chunkAsString])\n      )})</script>`\n    )\n  )\n}\n"],"names":["htmlEscapeJsonString","isEdgeRuntime","process","env","NEXT_RUNTIME","INLINE_FLIGHT_PAYLOAD_BOOTSTRAP","INLINE_FLIGHT_PAYLOAD_DATA","INLINE_FLIGHT_PAYLOAD_FORM_STATE","flightResponses","WeakMap","encoder","TextEncoder","useFlightStream","flightStream","clientReferenceManifest","nonce","response","get","createFromReadableStream","TURBOPACK","require","newResponse","ssrManifest","moduleLoading","moduleMap","edgeSSRModuleMapping","ssrModuleMapping","set","flightRenderComplete","flightReader","getReader","done","read","createInlinedDataReadableStream","formState","startScriptTag","JSON","stringify","decoder","TextDecoder","fatal","decoderOptions","stream","readable","ReadableStream","type","start","controller","writeInitialInstructions","error","pull","value","tail","decode","length","writeFlightDataInstruction","close","chunkAsString","scriptStart","enqueue","encode"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}