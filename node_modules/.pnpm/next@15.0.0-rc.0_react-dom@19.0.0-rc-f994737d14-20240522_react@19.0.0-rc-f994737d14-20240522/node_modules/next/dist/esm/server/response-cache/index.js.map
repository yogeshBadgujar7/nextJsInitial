{"version":3,"sources":["../../../src/server/response-cache/index.ts"],"sourcesContent":["import type {\n  IncrementalCache,\n  ResponseCacheEntry,\n  ResponseGenerator,\n  IncrementalCacheItem,\n  ResponseCacheBase,\n  IncrementalCacheKindHint,\n} from './types'\nimport { RouteKind } from '../future/route-kind'\n\nimport { Batcher } from '../../lib/batcher'\nimport { scheduleOnNextTick } from '../../lib/scheduler'\nimport { fromResponseCacheEntry, toResponseCacheEntry } from './utils'\n\nexport * from './types'\n\nexport default class ResponseCache implements ResponseCacheBase {\n  private readonly batcher = Batcher.create<\n    { key: string; isOnDemandRevalidate: boolean },\n    IncrementalCacheItem | null,\n    string\n  >({\n    // Ensure on-demand revalidate doesn't block normal requests, it should be\n    // safe to run an on-demand revalidate for the same key as a normal request.\n    cacheKeyFn: ({ key, isOnDemandRevalidate }) =>\n      `${key}-${isOnDemandRevalidate ? '1' : '0'}`,\n    // We wait to do any async work until after we've added our promise to\n    // `pendingResponses` to ensure that any any other calls will reuse the\n    // same promise until we've fully finished our work.\n    schedulerFn: scheduleOnNextTick,\n  })\n\n  private previousCacheItem?: {\n    key: string\n    entry: IncrementalCacheItem | null\n    expiresAt: number\n  }\n\n  private minimalMode?: boolean\n\n  constructor(minimalMode: boolean) {\n    // this is a hack to avoid Webpack knowing this is equal to this.minimalMode\n    // because we replace this.minimalMode to true in production bundles.\n    const minimalModeKey = 'minimalMode'\n    this[minimalModeKey] = minimalMode\n  }\n\n  public async get(\n    key: string | null,\n    responseGenerator: ResponseGenerator,\n    context: {\n      routeKind?: RouteKind\n      isOnDemandRevalidate?: boolean\n      isPrefetch?: boolean\n      incrementalCache: IncrementalCache\n    }\n  ): Promise<ResponseCacheEntry | null> {\n    // If there is no key for the cache, we can't possibly look this up in the\n    // cache so just return the result of the response generator.\n    if (!key) return responseGenerator(false, null)\n\n    const { incrementalCache, isOnDemandRevalidate = false } = context\n\n    const response = await this.batcher.batch(\n      { key, isOnDemandRevalidate },\n      async (cacheKey, resolve) => {\n        // We keep the previous cache entry around to leverage when the\n        // incremental cache is disabled in minimal mode.\n        if (\n          this.minimalMode &&\n          this.previousCacheItem?.key === cacheKey &&\n          this.previousCacheItem.expiresAt > Date.now()\n        ) {\n          return this.previousCacheItem.entry\n        }\n\n        // Coerce the kindHint into a given kind for the incremental cache.\n        let kindHint: IncrementalCacheKindHint | undefined\n        if (\n          context.routeKind === RouteKind.APP_PAGE ||\n          context.routeKind === RouteKind.APP_ROUTE\n        ) {\n          kindHint = 'app'\n        } else if (context.routeKind === RouteKind.PAGES) {\n          kindHint = 'pages'\n        }\n\n        let resolved = false\n        let cachedResponse: IncrementalCacheItem = null\n        try {\n          cachedResponse = !this.minimalMode\n            ? await incrementalCache.get(key, { kindHint })\n            : null\n\n          if (cachedResponse && !isOnDemandRevalidate) {\n            if (cachedResponse.value?.kind === 'FETCH') {\n              throw new Error(\n                `invariant: unexpected cachedResponse of kind fetch in response cache`\n              )\n            }\n\n            resolve({\n              ...cachedResponse,\n              revalidate: cachedResponse.curRevalidate,\n            })\n            resolved = true\n\n            if (!cachedResponse.isStale || context.isPrefetch) {\n              // The cached value is still valid, so we don't need\n              // to update it yet.\n              return null\n            }\n          }\n\n          const cacheEntry = await responseGenerator(\n            resolved,\n            cachedResponse,\n            true\n          )\n\n          // If the cache entry couldn't be generated, we don't want to cache\n          // the result.\n          if (!cacheEntry) {\n            // Unset the previous cache item if it was set.\n            if (this.minimalMode) this.previousCacheItem = undefined\n            return null\n          }\n\n          const resolveValue = await fromResponseCacheEntry({\n            ...cacheEntry,\n            isMiss: !cachedResponse,\n          })\n          if (!resolveValue) {\n            // Unset the previous cache item if it was set.\n            if (this.minimalMode) this.previousCacheItem = undefined\n            return null\n          }\n\n          // For on-demand revalidate wait to resolve until cache is set.\n          // Otherwise resolve now.\n          if (!isOnDemandRevalidate && !resolved) {\n            resolve(resolveValue)\n            resolved = true\n          }\n\n          if (typeof resolveValue.revalidate !== 'undefined') {\n            if (this.minimalMode) {\n              this.previousCacheItem = {\n                key: cacheKey,\n                entry: resolveValue,\n                expiresAt: Date.now() + 1000,\n              }\n            } else {\n              await incrementalCache.set(key, resolveValue.value, {\n                revalidate: resolveValue.revalidate,\n              })\n            }\n          }\n\n          return resolveValue\n        } catch (err) {\n          // When a getStaticProps path is erroring we automatically re-set the\n          // existing cache under a new expiration to prevent non-stop retrying.\n          if (cachedResponse) {\n            await incrementalCache.set(key, cachedResponse.value, {\n              revalidate: Math.min(\n                Math.max(cachedResponse.revalidate || 3, 3),\n                30\n              ),\n            })\n          }\n\n          // While revalidating in the background we can't reject as we already\n          // resolved the cache entry so log the error here.\n          if (resolved) {\n            console.error(err)\n            return null\n          }\n\n          // We haven't resolved yet, so let's throw to indicate an error.\n          throw err\n        }\n      }\n    )\n\n    return toResponseCacheEntry(response)\n  }\n}\n"],"names":["RouteKind","Batcher","scheduleOnNextTick","fromResponseCacheEntry","toResponseCacheEntry","ResponseCache","constructor","minimalMode","batcher","create","cacheKeyFn","key","isOnDemandRevalidate","schedulerFn","minimalModeKey","get","responseGenerator","context","incrementalCache","response","batch","cacheKey","resolve","previousCacheItem","expiresAt","Date","now","entry","kindHint","routeKind","APP_PAGE","APP_ROUTE","PAGES","resolved","cachedResponse","value","kind","Error","revalidate","curRevalidate","isStale","isPrefetch","cacheEntry","undefined","resolveValue","isMiss","set","err","Math","min","max","console","error"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}