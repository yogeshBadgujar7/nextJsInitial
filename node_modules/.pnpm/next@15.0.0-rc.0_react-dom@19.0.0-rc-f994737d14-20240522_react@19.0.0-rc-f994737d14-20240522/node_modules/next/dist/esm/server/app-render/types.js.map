{"version":3,"sources":["../../../src/server/app-render/types.ts"],"sourcesContent":["import type { LoadComponentsReturnType } from '../load-components'\nimport type { ServerRuntime, SizeLimit } from '../../types'\nimport type { NextConfigComplete } from '../../server/config-shared'\nimport type { ClientReferenceManifest } from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { NextFontManifest } from '../../build/webpack/plugins/next-font-manifest-plugin'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { AppPageModule } from '../future/route-modules/app-page/module'\nimport type { SwrDelta } from '../lib/revalidate'\nimport type { LoadingModuleData } from '../../shared/lib/app-router-context.shared-runtime'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\n\nimport s from 'next/dist/compiled/superstruct'\nimport type { RequestLifecycleOpts } from '../base-server'\n\nexport type DynamicParamTypes =\n  | 'catchall'\n  | 'catchall-intercepted'\n  | 'optional-catchall'\n  | 'dynamic'\n  | 'dynamic-intercepted'\n\nconst dynamicParamTypesSchema = s.enums(['c', 'ci', 'oc', 'd', 'di'])\n\nexport type DynamicParamTypesShort = s.Infer<typeof dynamicParamTypesSchema>\n\nconst segmentSchema = s.union([\n  s.string(),\n  s.tuple([s.string(), s.string(), dynamicParamTypesSchema]),\n])\n\nexport type Segment = s.Infer<typeof segmentSchema>\n\n// unfortunately the tuple is not understood well by Describe so we have to\n// use any here. This does not have any impact on the runtime type since the validation\n// does work correctly.\nexport const flightRouterStateSchema: s.Describe<any> = s.tuple([\n  segmentSchema,\n  s.record(\n    s.string(),\n    s.lazy(() => flightRouterStateSchema)\n  ),\n  s.optional(s.nullable(s.string())),\n  s.optional(s.nullable(s.union([s.literal('refetch'), s.literal('refresh')]))),\n  s.optional(s.boolean()),\n])\n\n/**\n * Router state\n */\nexport type FlightRouterState = [\n  segment: Segment,\n  parallelRoutes: { [parallelRouterKey: string]: FlightRouterState },\n  url?: string | null,\n  /*\n  /* \"refresh\" and \"refetch\", despite being similarly named, have different semantics.\n   * - \"refetch\" is a server indicator which informs where rendering should start from.\n   * - \"refresh\" is a client router indicator that it should re-fetch the data from the server for the current segment.\n   *   It uses the \"url\" property above to determine where to fetch from.\n   */\n  refresh?: 'refetch' | 'refresh' | null,\n  isRootLayout?: boolean,\n]\n\n/**\n * Individual Flight response path\n */\nexport type FlightSegmentPath =\n  // Uses `any` as repeating pattern can't be typed.\n  | any[]\n  // Looks somewhat like this\n  | [\n      segment: Segment,\n      parallelRouterKey: string,\n      segment: Segment,\n      parallelRouterKey: string,\n      segment: Segment,\n      parallelRouterKey: string,\n    ]\n\n/**\n * Represents a tree of segments and the Flight data (i.e. React nodes) that\n * correspond to each one. The tree is isomorphic to the FlightRouterState;\n * however in the future we want to be able to fetch arbitrary partial segments\n * without having to fetch all its children. So this response format will\n * likely change.\n */\nexport type CacheNodeSeedData = [\n  segment: Segment,\n  parallelRoutes: {\n    [parallelRouterKey: string]: CacheNodeSeedData | null\n  },\n  node: React.ReactNode | null,\n  loading: LoadingModuleData,\n]\n\nexport type FlightDataPath =\n  // Uses `any` as repeating pattern can't be typed.\n  | any[]\n  // Looks somewhat like this\n  | [\n      // Holds full path to the segment.\n      ...FlightSegmentPath[],\n      /* segment of the rendered slice: */ Segment,\n      /* treePatch */ FlightRouterState,\n      /* cacheNodeSeedData */ CacheNodeSeedData, // Can be null during prefetch if there's no loading component\n      /* head */ React.ReactNode | null,\n    ]\n\n/**\n * The Flight response data\n */\nexport type FlightData = Array<FlightDataPath> | string\n\nexport type ActionResult = Promise<any>\n\n// Response from `createFromFetch` for normal rendering\nexport type NextFlightResponse = [buildId: string, flightData: FlightData]\n\n// Response from `createFromFetch` for server actions. Action's flight data can be null\nexport type ActionFlightResponse =\n  | [ActionResult, [buildId: string, flightData: FlightData | null]]\n  // This case happens when `redirect()` is called in a server action.\n  | NextFlightResponse\n\nexport interface RenderOptsPartial {\n  err?: Error | null\n  dev?: boolean\n  buildId: string\n  basePath: string\n  trailingSlash: boolean\n  clientReferenceManifest?: DeepReadonly<ClientReferenceManifest>\n  supportsDynamicHTML: boolean\n  runtime?: ServerRuntime\n  serverComponents?: boolean\n  enableTainting?: boolean\n  assetPrefix?: string\n  crossOrigin?: '' | 'anonymous' | 'use-credentials' | undefined\n  nextFontManifest?: DeepReadonly<NextFontManifest>\n  isBot?: boolean\n  incrementalCache?: import('../lib/incremental-cache').IncrementalCache\n  isRevalidate?: boolean\n  nextExport?: boolean\n  nextConfigOutput?: 'standalone' | 'export'\n  appDirDevErrorLogger?: (err: any) => Promise<void>\n  originalPathname?: string\n  isDraftMode?: boolean\n  deploymentId?: string\n  onUpdateCookies?: (cookies: string[]) => void\n  loadConfig?: (\n    phase: string,\n    dir: string,\n    customConfig?: object | null,\n    rawConfig?: boolean,\n    silent?: boolean\n  ) => Promise<NextConfigComplete>\n  serverActions?: {\n    bodySizeLimit?: SizeLimit\n    allowedOrigins?: string[]\n  }\n  params?: ParsedUrlQuery\n  isPrefetch?: boolean\n  experimental: {\n    /**\n     * When true, some routes support partial prerendering (PPR).\n     */\n    isAppPPREnabled: boolean\n\n    /**\n     * When true, it indicates that the current page supports partial\n     * prerendering.\n     */\n    isRoutePPREnabled?: boolean\n    swrDelta: SwrDelta | undefined\n    clientTraceMetadata: string[] | undefined\n    after: boolean\n  }\n  postponed?: string\n  /**\n   * When true, only the skeleton of the PPR page will be rendered. This will\n   * also enable other debugging features such as logging.\n   */\n  isDebugPPRSkeleton?: boolean\n  isStaticGeneration?: boolean\n}\n\nexport type RenderOpts = LoadComponentsReturnType<AppPageModule> &\n  RenderOptsPartial &\n  RequestLifecycleOpts\n"],"names":["s","dynamicParamTypesSchema","enums","segmentSchema","union","string","tuple","flightRouterStateSchema","record","lazy","optional","nullable","literal","boolean"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"AAWA,OAAOA,OAAO,iCAAgC;AAU9C,MAAMC,0BAA0BD,EAAEE,KAAK,CAAC;IAAC;IAAK;IAAM;IAAM;IAAK;CAAK;AAIpE,MAAMC,gBAAgBH,EAAEI,KAAK,CAAC;IAC5BJ,EAAEK,MAAM;IACRL,EAAEM,KAAK,CAAC;QAACN,EAAEK,MAAM;QAAIL,EAAEK,MAAM;QAAIJ;KAAwB;CAC1D;AAID,2EAA2E;AAC3E,uFAAuF;AACvF,uBAAuB;AACvB,OAAO,MAAMM,0BAA2CP,EAAEM,KAAK,CAAC;IAC9DH;IACAH,EAAEQ,MAAM,CACNR,EAAEK,MAAM,IACRL,EAAES,IAAI,CAAC,IAAMF;IAEfP,EAAEU,QAAQ,CAACV,EAAEW,QAAQ,CAACX,EAAEK,MAAM;IAC9BL,EAAEU,QAAQ,CAACV,EAAEW,QAAQ,CAACX,EAAEI,KAAK,CAAC;QAACJ,EAAEY,OAAO,CAAC;QAAYZ,EAAEY,OAAO,CAAC;KAAW;IAC1EZ,EAAEU,QAAQ,CAACV,EAAEa,OAAO;CACrB,EAAC"}