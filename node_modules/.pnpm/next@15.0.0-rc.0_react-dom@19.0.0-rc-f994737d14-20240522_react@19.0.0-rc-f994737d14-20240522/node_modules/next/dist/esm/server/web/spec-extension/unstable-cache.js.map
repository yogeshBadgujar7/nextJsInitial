{"version":3,"sources":["../../../../src/server/web/spec-extension/unstable-cache.ts"],"sourcesContent":["import type { IncrementalCache } from '../../lib/incremental-cache'\n\nimport { CACHE_ONE_YEAR } from '../../../lib/constants'\nimport {\n  addImplicitTags,\n  validateRevalidate,\n  validateTags,\n} from '../../lib/patch-fetch'\nimport { staticGenerationAsyncStorage } from '../../../client/components/static-generation-async-storage.external'\n\ntype Callback = (...args: any[]) => Promise<any>\n\nlet noStoreFetchIdx = 0\n\nasync function cacheNewResult<T>(\n  result: T,\n  incrementalCache: IncrementalCache,\n  cacheKey: string,\n  tags: string[],\n  revalidate: number | false | undefined,\n  fetchIdx: number,\n  fetchUrl: string\n): Promise<unknown> {\n  await incrementalCache.set(\n    cacheKey,\n    {\n      kind: 'FETCH',\n      data: {\n        headers: {},\n        // TODO: handle non-JSON values?\n        body: JSON.stringify(result),\n        status: 200,\n        url: '',\n      },\n      revalidate: typeof revalidate !== 'number' ? CACHE_ONE_YEAR : revalidate,\n    },\n    {\n      revalidate,\n      fetchCache: true,\n      tags,\n      fetchIdx,\n      fetchUrl,\n    }\n  )\n  return\n}\n\n/**\n * This function allows you to cache the results of expensive operations, like database queries, and reuse them across multiple requests.\n *\n * Read more: [Next.js Docs: `unstable_cache`](https://nextjs.org/docs/app/api-reference/functions/unstable_cache)\n */\nexport function unstable_cache<T extends Callback>(\n  cb: T,\n  keyParts?: string[],\n  options: {\n    /**\n     * The revalidation interval in seconds.\n     */\n    revalidate?: number | false\n    tags?: string[]\n  } = {}\n): T {\n  if (options.revalidate === 0) {\n    throw new Error(\n      `Invariant revalidate: 0 can not be passed to unstable_cache(), must be \"false\" or \"> 0\" ${cb.toString()}`\n    )\n  }\n\n  // Validate the tags provided are valid\n  const tags = options.tags\n    ? validateTags(options.tags, `unstable_cache ${cb.toString()}`)\n    : []\n\n  // Validate the revalidate options\n  validateRevalidate(\n    options.revalidate,\n    `unstable_cache ${cb.name || cb.toString()}`\n  )\n\n  // Stash the fixed part of the key at construction time. The invocation key will combine\n  // the fixed key with the arguments when actually called\n  // @TODO if cb.toString() is long we should hash it\n  // @TODO come up with a collision-free way to combine keyParts\n  // @TODO consider validating the keyParts are all strings. TS can't provide runtime guarantees\n  // and the error produced by accidentally using something that cannot be safely coerced is likely\n  // hard to debug\n  const fixedKey = `${cb.toString()}-${\n    Array.isArray(keyParts) && keyParts.join(',')\n  }`\n\n  const cachedCb = async (...args: any[]) => {\n    const store = staticGenerationAsyncStorage.getStore()\n\n    // We must be able to find the incremental cache otherwise we throw\n    const maybeIncrementalCache:\n      | import('../../lib/incremental-cache').IncrementalCache\n      | undefined =\n      store?.incrementalCache || (globalThis as any).__incrementalCache\n\n    if (!maybeIncrementalCache) {\n      throw new Error(\n        `Invariant: incrementalCache missing in unstable_cache ${cb.toString()}`\n      )\n    }\n    const incrementalCache = maybeIncrementalCache\n\n    // Construct the complete cache key for this function invocation\n    // @TODO stringify is likely not safe here. We will coerce undefined to null which will make\n    // the keyspace smaller than the execution space\n    const invocationKey = `${fixedKey}-${JSON.stringify(args)}`\n    const cacheKey = await incrementalCache.fetchCacheKey(invocationKey)\n    const fetchUrl = `unstable_cache ${cb.name ? ` ${cb.name}` : cacheKey}`\n    const fetchIdx = (store ? store.nextFetchId : noStoreFetchIdx) ?? 1\n\n    if (store) {\n      store.nextFetchId = fetchIdx + 1\n\n      // We are in an App Router context. We try to return the cached entry if it exists and is valid\n      // If the entry is fresh we return it. If the entry is stale we return it but revalidate the entry in\n      // the background. If the entry is missing or invalid we generate a new entry and return it.\n\n      // We update the store's revalidate property if the option.revalidate is a higher precedence\n      if (typeof options.revalidate === 'number') {\n        if (\n          typeof store.revalidate === 'number' &&\n          store.revalidate < options.revalidate\n        ) {\n          // The store is already revalidating on a shorter time interval, leave it alone\n        } else {\n          store.revalidate = options.revalidate\n        }\n      } else if (\n        options.revalidate === false &&\n        typeof store.revalidate === 'undefined'\n      ) {\n        // The store has not defined revalidate type so we can use the false option\n        store.revalidate = options.revalidate\n      }\n\n      // We need to accumulate the tags for this invocation within the store\n      if (!store.tags) {\n        store.tags = tags.slice()\n      } else {\n        for (const tag of tags) {\n          // @TODO refactor tags to be a set to avoid this O(n) lookup\n          if (!store.tags.includes(tag)) {\n            store.tags.push(tag)\n          }\n        }\n      }\n      // @TODO check on this API. addImplicitTags mutates the store and returns the implicit tags. The naming\n      // of this function is potentially a little confusing\n      const implicitTags = addImplicitTags(store)\n\n      if (\n        // when we are nested inside of other unstable_cache's\n        // we should bypass cache similar to fetches\n        store.fetchCache !== 'force-no-store' &&\n        !store.isOnDemandRevalidate &&\n        !incrementalCache.isOnDemandRevalidate &&\n        !store.isDraftMode\n      ) {\n        // We attempt to get the current cache entry from the incremental cache.\n        const cacheEntry = await incrementalCache.get(cacheKey, {\n          kindHint: 'fetch',\n          revalidate: options.revalidate,\n          tags,\n          softTags: implicitTags,\n          fetchIdx,\n        })\n\n        if (cacheEntry && cacheEntry.value) {\n          // The entry exists and has a value\n          if (cacheEntry.value.kind !== 'FETCH') {\n            // The entry is invalid and we need a special warning\n            // @TODO why do we warn this way? Should this just be an error? How are these errors surfaced\n            // so bugs can be reported\n            // @TODO the invocation key can have sensitive data in it. we should not log this entire object\n            console.error(\n              `Invariant invalid cacheEntry returned for ${invocationKey}`\n            )\n            // will fall through to generating a new cache entry below\n          } else {\n            // We have a valid cache entry so we will be returning it. We also check to see if we need\n            // to background revalidate it by checking if it is stale.\n            const cachedResponse =\n              cacheEntry.value.data.body !== undefined\n                ? JSON.parse(cacheEntry.value.data.body)\n                : undefined\n            if (cacheEntry.isStale) {\n              // In App Router we return the stale result and revalidate in the background\n              if (!store.pendingRevalidates) {\n                store.pendingRevalidates = {}\n              }\n              // We run the cache function asynchronously and save the result when it completes\n              store.pendingRevalidates[invocationKey] =\n                staticGenerationAsyncStorage\n                  .run(\n                    {\n                      ...store,\n                      // force any nested fetches to bypass cache so they revalidate\n                      // when the unstable_cache call is revalidated\n                      fetchCache: 'force-no-store',\n                      isUnstableCacheCallback: true,\n                    },\n                    cb,\n                    ...args\n                  )\n                  .then((result) => {\n                    return cacheNewResult(\n                      result,\n                      incrementalCache,\n                      cacheKey,\n                      tags,\n                      options.revalidate,\n                      fetchIdx,\n                      fetchUrl\n                    )\n                  })\n                  // @TODO This error handling seems wrong. We swallow the error?\n                  .catch((err) =>\n                    console.error(\n                      `revalidating cache with key: ${invocationKey}`,\n                      err\n                    )\n                  )\n            }\n            // We had a valid cache entry so we return it here\n            return cachedResponse\n          }\n        }\n      }\n\n      // If we got this far then we had an invalid cache entry and need to generate a new one\n      const result = await staticGenerationAsyncStorage.run(\n        {\n          ...store,\n          // force any nested fetches to bypass cache so they revalidate\n          // when the unstable_cache call is revalidated\n          fetchCache: 'force-no-store',\n          isUnstableCacheCallback: true,\n        },\n        cb,\n        ...args\n      )\n      cacheNewResult(\n        result,\n        incrementalCache,\n        cacheKey,\n        tags,\n        options.revalidate,\n        fetchIdx,\n        fetchUrl\n      )\n      return result\n    } else {\n      noStoreFetchIdx += 1\n      // We are in Pages Router or were called outside of a render. We don't have a store\n      // so we just call the callback directly when it needs to run.\n      // If the entry is fresh we return it. If the entry is stale we return it but revalidate the entry in\n      // the background. If the entry is missing or invalid we generate a new entry and return it.\n\n      if (!incrementalCache.isOnDemandRevalidate) {\n        // We aren't doing an on demand revalidation so we check use the cache if valid\n\n        const cacheEntry = await incrementalCache.get(cacheKey, {\n          kindHint: 'fetch',\n          revalidate: options.revalidate,\n          tags,\n        })\n\n        if (cacheEntry && cacheEntry.value) {\n          // The entry exists and has a value\n          if (cacheEntry.value.kind !== 'FETCH') {\n            // The entry is invalid and we need a special warning\n            // @TODO why do we warn this way? Should this just be an error? How are these errors surfaced\n            // so bugs can be reported\n            console.error(\n              `Invariant invalid cacheEntry returned for ${invocationKey}`\n            )\n            // will fall through to generating a new cache entry below\n          } else if (!cacheEntry.isStale) {\n            // We have a valid cache entry and it is fresh so we return it\n            return cacheEntry.value.data.body !== undefined\n              ? JSON.parse(cacheEntry.value.data.body)\n              : undefined\n          }\n        }\n      }\n\n      // If we got this far then we had an invalid cache entry and need to generate a new one\n      // @TODO this storage wrapper is included here because it existed prior to the latest refactor\n      // however it is incorrect logic because it causes any internal cache calls to follow the App Router\n      // path rather than Pages router path. This may mean there is existing buggy behavior however no specific\n      // issues are known at this time. The whole static generation storage pathways should be reworked\n      // to allow tracking which \"mode\" we are in without the presence of a store or not. For now I have\n      // maintained the existing behavior to limit the impact of the current refactor\n      const result = await staticGenerationAsyncStorage.run(\n        // We are making a fake store that is useful for scoping fetchCache: 'force-no-store' and isUnstableCacheCallback: true\n        // The fact that we need to construct this kind of fake store indicates the code is not factored correctly\n        // @TODO refactor to not require this fake store object\n        {\n          // force any nested fetches to bypass cache so they revalidate\n          // when the unstable_cache call is revalidated\n          fetchCache: 'force-no-store',\n          isUnstableCacheCallback: true,\n          urlPathname: '/',\n          isStaticGeneration: false,\n          prerenderState: null,\n        },\n        cb,\n        ...args\n      )\n      cacheNewResult(\n        result,\n        incrementalCache,\n        cacheKey,\n        tags,\n        options.revalidate,\n        fetchIdx,\n        fetchUrl\n      )\n      return result\n    }\n  }\n  // TODO: once AsyncLocalStorage.run() returns the correct types this override will no longer be necessary\n  return cachedCb as unknown as T\n}\n"],"names":["CACHE_ONE_YEAR","addImplicitTags","validateRevalidate","validateTags","staticGenerationAsyncStorage","noStoreFetchIdx","cacheNewResult","result","incrementalCache","cacheKey","tags","revalidate","fetchIdx","fetchUrl","set","kind","data","headers","body","JSON","stringify","status","url","fetchCache","unstable_cache","cb","keyParts","options","Error","toString","name","fixedKey","Array","isArray","join","cachedCb","args","store","getStore","maybeIncrementalCache","globalThis","__incrementalCache","invocationKey","fetchCacheKey","nextFetchId","slice","tag","includes","push","implicitTags","isOnDemandRevalidate","isDraftMode","cacheEntry","get","kindHint","softTags","value","console","error","cachedResponse","undefined","parse","isStale","pendingRevalidates","run","isUnstableCacheCallback","then","catch","err","urlPathname","isStaticGeneration","prerenderState"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"AAEA,SAASA,cAAc,QAAQ,yBAAwB;AACvD,SACEC,eAAe,EACfC,kBAAkB,EAClBC,YAAY,QACP,wBAAuB;AAC9B,SAASC,4BAA4B,QAAQ,sEAAqE;AAIlH,IAAIC,kBAAkB;AAEtB,eAAeC,eACbC,MAAS,EACTC,gBAAkC,EAClCC,QAAgB,EAChBC,IAAc,EACdC,UAAsC,EACtCC,QAAgB,EAChBC,QAAgB;IAEhB,MAAML,iBAAiBM,GAAG,CACxBL,UACA;QACEM,MAAM;QACNC,MAAM;YACJC,SAAS,CAAC;YACV,gCAAgC;YAChCC,MAAMC,KAAKC,SAAS,CAACb;YACrBc,QAAQ;YACRC,KAAK;QACP;QACAX,YAAY,OAAOA,eAAe,WAAWX,iBAAiBW;IAChE,GACA;QACEA;QACAY,YAAY;QACZb;QACAE;QACAC;IACF;IAEF;AACF;AAEA;;;;CAIC,GACD,OAAO,SAASW,eACdC,EAAK,EACLC,QAAmB,EACnBC,UAMI,CAAC,CAAC;IAEN,IAAIA,QAAQhB,UAAU,KAAK,GAAG;QAC5B,MAAM,IAAIiB,MACR,CAAC,wFAAwF,EAAEH,GAAGI,QAAQ,GAAG,CAAC;IAE9G;IAEA,uCAAuC;IACvC,MAAMnB,OAAOiB,QAAQjB,IAAI,GACrBP,aAAawB,QAAQjB,IAAI,EAAE,CAAC,eAAe,EAAEe,GAAGI,QAAQ,GAAG,CAAC,IAC5D,EAAE;IAEN,kCAAkC;IAClC3B,mBACEyB,QAAQhB,UAAU,EAClB,CAAC,eAAe,EAAEc,GAAGK,IAAI,IAAIL,GAAGI,QAAQ,GAAG,CAAC;IAG9C,wFAAwF;IACxF,wDAAwD;IACxD,mDAAmD;IACnD,8DAA8D;IAC9D,8FAA8F;IAC9F,iGAAiG;IACjG,gBAAgB;IAChB,MAAME,WAAW,CAAC,EAAEN,GAAGI,QAAQ,GAAG,CAAC,EACjCG,MAAMC,OAAO,CAACP,aAAaA,SAASQ,IAAI,CAAC,KAC1C,CAAC;IAEF,MAAMC,WAAW,OAAO,GAAGC;QACzB,MAAMC,QAAQjC,6BAA6BkC,QAAQ;QAEnD,mEAAmE;QACnE,MAAMC,wBAGJF,CAAAA,yBAAAA,MAAO7B,gBAAgB,KAAI,AAACgC,WAAmBC,kBAAkB;QAEnE,IAAI,CAACF,uBAAuB;YAC1B,MAAM,IAAIX,MACR,CAAC,sDAAsD,EAAEH,GAAGI,QAAQ,GAAG,CAAC;QAE5E;QACA,MAAMrB,mBAAmB+B;QAEzB,gEAAgE;QAChE,4FAA4F;QAC5F,gDAAgD;QAChD,MAAMG,gBAAgB,CAAC,EAAEX,SAAS,CAAC,EAAEZ,KAAKC,SAAS,CAACgB,MAAM,CAAC;QAC3D,MAAM3B,WAAW,MAAMD,iBAAiBmC,aAAa,CAACD;QACtD,MAAM7B,WAAW,CAAC,eAAe,EAAEY,GAAGK,IAAI,GAAG,CAAC,CAAC,EAAEL,GAAGK,IAAI,CAAC,CAAC,GAAGrB,SAAS,CAAC;QACvE,MAAMG,WAAW,AAACyB,CAAAA,QAAQA,MAAMO,WAAW,GAAGvC,eAAc,KAAM;QAElE,IAAIgC,OAAO;YACTA,MAAMO,WAAW,GAAGhC,WAAW;YAE/B,+FAA+F;YAC/F,qGAAqG;YACrG,4FAA4F;YAE5F,4FAA4F;YAC5F,IAAI,OAAOe,QAAQhB,UAAU,KAAK,UAAU;gBAC1C,IACE,OAAO0B,MAAM1B,UAAU,KAAK,YAC5B0B,MAAM1B,UAAU,GAAGgB,QAAQhB,UAAU,EACrC;gBACA,+EAA+E;gBACjF,OAAO;oBACL0B,MAAM1B,UAAU,GAAGgB,QAAQhB,UAAU;gBACvC;YACF,OAAO,IACLgB,QAAQhB,UAAU,KAAK,SACvB,OAAO0B,MAAM1B,UAAU,KAAK,aAC5B;gBACA,2EAA2E;gBAC3E0B,MAAM1B,UAAU,GAAGgB,QAAQhB,UAAU;YACvC;YAEA,sEAAsE;YACtE,IAAI,CAAC0B,MAAM3B,IAAI,EAAE;gBACf2B,MAAM3B,IAAI,GAAGA,KAAKmC,KAAK;YACzB,OAAO;gBACL,KAAK,MAAMC,OAAOpC,KAAM;oBACtB,4DAA4D;oBAC5D,IAAI,CAAC2B,MAAM3B,IAAI,CAACqC,QAAQ,CAACD,MAAM;wBAC7BT,MAAM3B,IAAI,CAACsC,IAAI,CAACF;oBAClB;gBACF;YACF;YACA,uGAAuG;YACvG,qDAAqD;YACrD,MAAMG,eAAehD,gBAAgBoC;YAErC,IACE,sDAAsD;YACtD,4CAA4C;YAC5CA,MAAMd,UAAU,KAAK,oBACrB,CAACc,MAAMa,oBAAoB,IAC3B,CAAC1C,iBAAiB0C,oBAAoB,IACtC,CAACb,MAAMc,WAAW,EAClB;gBACA,wEAAwE;gBACxE,MAAMC,aAAa,MAAM5C,iBAAiB6C,GAAG,CAAC5C,UAAU;oBACtD6C,UAAU;oBACV3C,YAAYgB,QAAQhB,UAAU;oBAC9BD;oBACA6C,UAAUN;oBACVrC;gBACF;gBAEA,IAAIwC,cAAcA,WAAWI,KAAK,EAAE;oBAClC,mCAAmC;oBACnC,IAAIJ,WAAWI,KAAK,CAACzC,IAAI,KAAK,SAAS;wBACrC,qDAAqD;wBACrD,6FAA6F;wBAC7F,0BAA0B;wBAC1B,+FAA+F;wBAC/F0C,QAAQC,KAAK,CACX,CAAC,0CAA0C,EAAEhB,cAAc,CAAC;oBAE9D,0DAA0D;oBAC5D,OAAO;wBACL,0FAA0F;wBAC1F,0DAA0D;wBAC1D,MAAMiB,iBACJP,WAAWI,KAAK,CAACxC,IAAI,CAACE,IAAI,KAAK0C,YAC3BzC,KAAK0C,KAAK,CAACT,WAAWI,KAAK,CAACxC,IAAI,CAACE,IAAI,IACrC0C;wBACN,IAAIR,WAAWU,OAAO,EAAE;4BACtB,4EAA4E;4BAC5E,IAAI,CAACzB,MAAM0B,kBAAkB,EAAE;gCAC7B1B,MAAM0B,kBAAkB,GAAG,CAAC;4BAC9B;4BACA,iFAAiF;4BACjF1B,MAAM0B,kBAAkB,CAACrB,cAAc,GACrCtC,6BACG4D,GAAG,CACF;gCACE,GAAG3B,KAAK;gCACR,8DAA8D;gCAC9D,8CAA8C;gCAC9Cd,YAAY;gCACZ0C,yBAAyB;4BAC3B,GACAxC,OACGW,MAEJ8B,IAAI,CAAC,CAAC3D;gCACL,OAAOD,eACLC,QACAC,kBACAC,UACAC,MACAiB,QAAQhB,UAAU,EAClBC,UACAC;4BAEJ,EACA,+DAA+D;6BAC9DsD,KAAK,CAAC,CAACC,MACNX,QAAQC,KAAK,CACX,CAAC,6BAA6B,EAAEhB,cAAc,CAAC,EAC/C0B;wBAGV;wBACA,kDAAkD;wBAClD,OAAOT;oBACT;gBACF;YACF;YAEA,uFAAuF;YACvF,MAAMpD,SAAS,MAAMH,6BAA6B4D,GAAG,CACnD;gBACE,GAAG3B,KAAK;gBACR,8DAA8D;gBAC9D,8CAA8C;gBAC9Cd,YAAY;gBACZ0C,yBAAyB;YAC3B,GACAxC,OACGW;YAEL9B,eACEC,QACAC,kBACAC,UACAC,MACAiB,QAAQhB,UAAU,EAClBC,UACAC;YAEF,OAAON;QACT,OAAO;YACLF,mBAAmB;YACnB,mFAAmF;YACnF,8DAA8D;YAC9D,qGAAqG;YACrG,4FAA4F;YAE5F,IAAI,CAACG,iBAAiB0C,oBAAoB,EAAE;gBAC1C,+EAA+E;gBAE/E,MAAME,aAAa,MAAM5C,iBAAiB6C,GAAG,CAAC5C,UAAU;oBACtD6C,UAAU;oBACV3C,YAAYgB,QAAQhB,UAAU;oBAC9BD;gBACF;gBAEA,IAAI0C,cAAcA,WAAWI,KAAK,EAAE;oBAClC,mCAAmC;oBACnC,IAAIJ,WAAWI,KAAK,CAACzC,IAAI,KAAK,SAAS;wBACrC,qDAAqD;wBACrD,6FAA6F;wBAC7F,0BAA0B;wBAC1B0C,QAAQC,KAAK,CACX,CAAC,0CAA0C,EAAEhB,cAAc,CAAC;oBAE9D,0DAA0D;oBAC5D,OAAO,IAAI,CAACU,WAAWU,OAAO,EAAE;wBAC9B,8DAA8D;wBAC9D,OAAOV,WAAWI,KAAK,CAACxC,IAAI,CAACE,IAAI,KAAK0C,YAClCzC,KAAK0C,KAAK,CAACT,WAAWI,KAAK,CAACxC,IAAI,CAACE,IAAI,IACrC0C;oBACN;gBACF;YACF;YAEA,uFAAuF;YACvF,8FAA8F;YAC9F,oGAAoG;YACpG,yGAAyG;YACzG,iGAAiG;YACjG,kGAAkG;YAClG,+EAA+E;YAC/E,MAAMrD,SAAS,MAAMH,6BAA6B4D,GAAG,CACnD,uHAAuH;YACvH,0GAA0G;YAC1G,uDAAuD;YACvD;gBACE,8DAA8D;gBAC9D,8CAA8C;gBAC9CzC,YAAY;gBACZ0C,yBAAyB;gBACzBI,aAAa;gBACbC,oBAAoB;gBACpBC,gBAAgB;YAClB,GACA9C,OACGW;YAEL9B,eACEC,QACAC,kBACAC,UACAC,MACAiB,QAAQhB,UAAU,EAClBC,UACAC;YAEF,OAAON;QACT;IACF;IACA,yGAAyG;IACzG,OAAO4B;AACT"}