{"version":3,"sources":["../../../src/lib/metadata/metadata.tsx"],"sourcesContent":["import type { ParsedUrlQuery } from 'querystring'\nimport type { GetDynamicParamFromSegment } from '../../server/app-render/app-render'\nimport type { LoaderTree } from '../../server/lib/app-dir-module'\n\nimport React from 'react'\nimport {\n  AppleWebAppMeta,\n  FormatDetectionMeta,\n  ItunesMeta,\n  BasicMeta,\n  ViewportMeta,\n  VerificationMeta,\n} from './generate/basic'\nimport { AlternatesMetadata } from './generate/alternate'\nimport {\n  OpenGraphMetadata,\n  TwitterMetadata,\n  AppLinksMeta,\n} from './generate/opengraph'\nimport { IconsMetadata } from './generate/icons'\nimport { resolveMetadata } from './resolve-metadata'\nimport { MetaFilter } from './generate/meta'\nimport type {\n  ResolvedMetadata,\n  ResolvedViewport,\n} from './types/metadata-interface'\nimport {\n  createDefaultMetadata,\n  createDefaultViewport,\n} from './default-metadata'\nimport { isNotFoundError } from '../../client/components/not-found'\n\n// Use a promise to share the status of the metadata resolving,\n// returning two components `MetadataTree` and `MetadataOutlet`\n// `MetadataTree` is the one that will be rendered at first in the content sequence for metadata tags.\n// `MetadataOutlet` is the one that will be rendered under error boundaries for metadata resolving errors.\n// In this way we can let the metadata tags always render successfully,\n// and the error will be caught by the error boundary and trigger fallbacks.\nexport function createMetadataComponents({\n  tree,\n  pathname,\n  trailingSlash,\n  query,\n  getDynamicParamFromSegment,\n  appUsingSizeAdjustment,\n  errorType,\n  createDynamicallyTrackedSearchParams,\n}: {\n  tree: LoaderTree\n  pathname: string\n  trailingSlash: boolean\n  query: ParsedUrlQuery\n  getDynamicParamFromSegment: GetDynamicParamFromSegment\n  appUsingSizeAdjustment: boolean\n  errorType?: 'not-found' | 'redirect'\n  createDynamicallyTrackedSearchParams: (\n    searchParams: ParsedUrlQuery\n  ) => ParsedUrlQuery\n}): [React.ComponentType, React.ComponentType] {\n  const metadataContext = {\n    // Make sure the pathname without query string\n    pathname: pathname.split('?')[0],\n    trailingSlash,\n  }\n\n  let resolve: (value: Error | undefined) => void | undefined\n  // Only use promise.resolve here to avoid unhandled rejections\n  const metadataErrorResolving = new Promise<Error | undefined>((res) => {\n    resolve = res\n  })\n\n  async function MetadataTree() {\n    const defaultMetadata = createDefaultMetadata()\n    const defaultViewport = createDefaultViewport()\n    let metadata: ResolvedMetadata | undefined = defaultMetadata\n    let viewport: ResolvedViewport | undefined = defaultViewport\n    let error: any\n    const errorMetadataItem: [null, null, null] = [null, null, null]\n    const errorConvention = errorType === 'redirect' ? undefined : errorType\n    const searchParams = createDynamicallyTrackedSearchParams(query)\n\n    const [resolvedError, resolvedMetadata, resolvedViewport] =\n      await resolveMetadata({\n        tree,\n        parentParams: {},\n        metadataItems: [],\n        errorMetadataItem,\n        searchParams,\n        getDynamicParamFromSegment,\n        errorConvention,\n        metadataContext,\n      })\n    if (!resolvedError) {\n      viewport = resolvedViewport\n      metadata = resolvedMetadata\n      resolve(undefined)\n    } else {\n      error = resolvedError\n      // If a not-found error is triggered during metadata resolution, we want to capture the metadata\n      // for the not-found route instead of whatever triggered the error. For all error types, we resolve an\n      // error, which will cause the outlet to throw it so it'll be handled by an error boundary\n      // (either an actual error, or an internal error that renders UI such as the NotFoundBoundary).\n      if (!errorType && isNotFoundError(resolvedError)) {\n        const [notFoundMetadataError, notFoundMetadata, notFoundViewport] =\n          await resolveMetadata({\n            tree,\n            parentParams: {},\n            metadataItems: [],\n            errorMetadataItem,\n            searchParams,\n            getDynamicParamFromSegment,\n            errorConvention: 'not-found',\n            metadataContext,\n          })\n        viewport = notFoundViewport\n        metadata = notFoundMetadata\n        error = notFoundMetadataError || error\n      }\n      resolve(error)\n    }\n\n    const elements = MetaFilter([\n      ViewportMeta({ viewport: viewport }),\n      BasicMeta({ metadata }),\n      AlternatesMetadata({ alternates: metadata.alternates }),\n      ItunesMeta({ itunes: metadata.itunes }),\n      FormatDetectionMeta({ formatDetection: metadata.formatDetection }),\n      VerificationMeta({ verification: metadata.verification }),\n      AppleWebAppMeta({ appleWebApp: metadata.appleWebApp }),\n      OpenGraphMetadata({ openGraph: metadata.openGraph }),\n      TwitterMetadata({ twitter: metadata.twitter }),\n      AppLinksMeta({ appLinks: metadata.appLinks }),\n      IconsMetadata({ icons: metadata.icons }),\n    ])\n\n    if (appUsingSizeAdjustment) elements.push(<meta name=\"next-size-adjust\" />)\n\n    return (\n      <>\n        {elements.map((el, index) => {\n          return React.cloneElement(el as React.ReactElement, { key: index })\n        })}\n      </>\n    )\n  }\n\n  async function MetadataOutlet() {\n    const error = await metadataErrorResolving\n    if (error) {\n      throw error\n    }\n    return null\n  }\n\n  return [MetadataTree, MetadataOutlet]\n}\n"],"names":["React","AppleWebAppMeta","FormatDetectionMeta","ItunesMeta","BasicMeta","ViewportMeta","VerificationMeta","AlternatesMetadata","OpenGraphMetadata","TwitterMetadata","AppLinksMeta","IconsMetadata","resolveMetadata","MetaFilter","createDefaultMetadata","createDefaultViewport","isNotFoundError","createMetadataComponents","tree","pathname","trailingSlash","query","getDynamicParamFromSegment","appUsingSizeAdjustment","errorType","createDynamicallyTrackedSearchParams","metadataContext","split","resolve","metadataErrorResolving","Promise","res","MetadataTree","defaultMetadata","defaultViewport","metadata","viewport","error","errorMetadataItem","errorConvention","undefined","searchParams","resolvedError","resolvedMetadata","resolvedViewport","parentParams","metadataItems","notFoundMetadataError","notFoundMetadata","notFoundViewport","elements","alternates","itunes","formatDetection","verification","appleWebApp","openGraph","twitter","appLinks","icons","push","meta","name","map","el","index","cloneElement","key","MetadataOutlet"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}