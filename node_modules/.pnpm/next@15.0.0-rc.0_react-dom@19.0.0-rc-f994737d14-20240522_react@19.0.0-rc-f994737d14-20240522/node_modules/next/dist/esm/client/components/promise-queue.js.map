{"version":3,"sources":["../../../src/client/components/promise-queue.ts"],"sourcesContent":["/*\n    This is a simple promise queue that allows you to limit the number of concurrent promises\n    that are running at any given time. It's used to limit the number of concurrent\n    prefetch requests that are being made to the server but could be used for other\n    things as well.\n*/\nexport class PromiseQueue {\n  #maxConcurrency: number\n  #runningCount: number\n  #queue: Array<{\n    promiseFn: Promise<any>\n    task: () => void\n  }>\n\n  constructor(maxConcurrency = 5) {\n    this.#maxConcurrency = maxConcurrency\n    this.#runningCount = 0\n    this.#queue = []\n  }\n\n  enqueue<T>(promiseFn: () => Promise<T>): Promise<T> {\n    let taskResolve: (value: T | PromiseLike<T>) => void\n    let taskReject: (reason?: any) => void\n\n    const taskPromise = new Promise((resolve, reject) => {\n      taskResolve = resolve\n      taskReject = reject\n    }) as Promise<T>\n\n    const task = async () => {\n      try {\n        this.#runningCount++\n        const result = await promiseFn()\n        taskResolve(result)\n      } catch (error) {\n        taskReject(error)\n      } finally {\n        this.#runningCount--\n        this.#processNext()\n      }\n    }\n\n    const enqueueResult = { promiseFn: taskPromise, task }\n    // wonder if we should take a LIFO approach here\n    this.#queue.push(enqueueResult)\n    this.#processNext()\n\n    return taskPromise\n  }\n\n  bump(promiseFn: Promise<any>) {\n    const index = this.#queue.findIndex((item) => item.promiseFn === promiseFn)\n\n    if (index > -1) {\n      const bumpedItem = this.#queue.splice(index, 1)[0]\n      this.#queue.unshift(bumpedItem)\n      this.#processNext(true)\n    }\n  }\n\n  #processNext(forced = false) {\n    if (\n      (this.#runningCount < this.#maxConcurrency || forced) &&\n      this.#queue.length > 0\n    ) {\n      this.#queue.shift()?.task()\n    }\n  }\n}\n"],"names":["PromiseQueue","enqueue","promiseFn","taskResolve","taskReject","taskPromise","Promise","resolve","reject","task","runningCount","result","error","processNext","enqueueResult","queue","push","bump","index","findIndex","item","bumpedItem","splice","unshift","constructor","maxConcurrency","forced","length","shift"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"AAAA;;;;;AAKA;;IAEE,mFACA,+EACA,iEAmDA;AAtDF,OAAO,MAAMA;IAcXC,QAAWC,SAA2B,EAAc;QAClD,IAAIC;QACJ,IAAIC;QAEJ,MAAMC,cAAc,IAAIC,QAAQ,CAACC,SAASC;YACxCL,cAAcI;YACdH,aAAaI;QACf;QAEA,MAAMC,OAAO;YACX,IAAI;gBACF,gCAAA,IAAI,EAAEC,eAAAA;gBACN,MAAMC,SAAS,MAAMT;gBACrBC,YAAYQ;YACd,EAAE,OAAOC,OAAO;gBACdR,WAAWQ;YACb,SAAU;gBACR,gCAAA,IAAI,EAAEF,eAAAA;gBACN,gCAAA,IAAI,EAAEG,cAAAA;YACR;QACF;QAEA,MAAMC,gBAAgB;YAAEZ,WAAWG;YAAaI;QAAK;QACrD,gDAAgD;QAChD,gCAAA,IAAI,EAAEM,QAAAA,QAAMC,IAAI,CAACF;QACjB,gCAAA,IAAI,EAAED,cAAAA;QAEN,OAAOR;IACT;IAEAY,KAAKf,SAAuB,EAAE;QAC5B,MAAMgB,QAAQ,gCAAA,IAAI,EAAEH,QAAAA,QAAMI,SAAS,CAAC,CAACC,OAASA,KAAKlB,SAAS,KAAKA;QAEjE,IAAIgB,QAAQ,CAAC,GAAG;YACd,MAAMG,aAAa,gCAAA,IAAI,EAAEN,QAAAA,QAAMO,MAAM,CAACJ,OAAO,EAAE,CAAC,EAAE;YAClD,gCAAA,IAAI,EAAEH,QAAAA,QAAMQ,OAAO,CAACF;YACpB,gCAAA,IAAI,EAAER,cAAAA,cAAY;QACpB;IACF;IA5CAW,YAAYC,iBAAiB,CAAC,CAAE;QA8ChC,4BAAA;mBAAA;;QArDA,4BAAA;;mBAAA,KAAA;;QACA,4BAAA;;mBAAA,KAAA;;QACA,4BAAA;;mBAAA,KAAA;;QAME,gCAAA,IAAI,EAAEA,iBAAAA,mBAAiBA;QACvB,gCAAA,IAAI,EAAEf,eAAAA,iBAAe;QACrB,gCAAA,IAAI,EAAEK,QAAAA,UAAQ,EAAE;IAClB;AAkDF;AARE,SAAA,YAAaW,MAAc;IAAdA,IAAAA,mBAAAA,SAAS;IACpB,IACE,AAAC,CAAA,gCAAA,IAAI,EAAEhB,eAAAA,iBAAe,gCAAA,IAAI,EAAEe,iBAAAA,oBAAkBC,MAAK,KACnD,gCAAA,IAAI,EAAEX,QAAAA,QAAMY,MAAM,GAAG,GACrB;YACA;SAAA,+CAAA,gCAAA,IAAI,EAAEZ,QAAAA,QAAMa,KAAK,uBAAjB,6CAAqBnB,IAAI;IAC3B;AACF"}