{"version":3,"sources":["../../../../src/shared/lib/router/action-queue.ts"],"sourcesContent":["import {\n  isThenable,\n  type AppRouterState,\n  type ReducerActions,\n  type ReducerState,\n  ACTION_REFRESH,\n  ACTION_SERVER_ACTION,\n  ACTION_NAVIGATE,\n  ACTION_RESTORE,\n} from '../../../client/components/router-reducer/router-reducer-types'\nimport type { ReduxDevToolsInstance } from '../../../client/components/use-reducer-with-devtools'\nimport { reducer } from '../../../client/components/router-reducer/router-reducer'\nimport React, { startTransition } from 'react'\n\nexport type DispatchStatePromise = React.Dispatch<ReducerState>\n\nexport type AppRouterActionQueue = {\n  state: AppRouterState | null\n  devToolsInstance?: ReduxDevToolsInstance\n  dispatch: (payload: ReducerActions, setState: DispatchStatePromise) => void\n  action: (state: AppRouterState, action: ReducerActions) => ReducerState\n  pending: ActionQueueNode | null\n  needsRefresh?: boolean\n  last: ActionQueueNode | null\n}\n\nexport type ActionQueueNode = {\n  payload: ReducerActions\n  next: ActionQueueNode | null\n  resolve: (value: ReducerState) => void\n  reject: (err: Error) => void\n  discarded?: boolean\n}\n\nexport const ActionQueueContext =\n  React.createContext<AppRouterActionQueue | null>(null)\n\nfunction runRemainingActions(\n  actionQueue: AppRouterActionQueue,\n  setState: DispatchStatePromise\n) {\n  if (actionQueue.pending !== null) {\n    actionQueue.pending = actionQueue.pending.next\n    if (actionQueue.pending !== null) {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      runAction({\n        actionQueue,\n        action: actionQueue.pending,\n        setState,\n      })\n    } else {\n      // No more actions are pending, check if a refresh is needed\n      if (actionQueue.needsRefresh) {\n        actionQueue.needsRefresh = false\n        actionQueue.dispatch(\n          {\n            type: ACTION_REFRESH,\n            origin: window.location.origin,\n          },\n          setState\n        )\n      }\n    }\n  }\n}\n\nasync function runAction({\n  actionQueue,\n  action,\n  setState,\n}: {\n  actionQueue: AppRouterActionQueue\n  action: ActionQueueNode\n  setState: DispatchStatePromise\n}) {\n  const prevState = actionQueue.state\n  if (!prevState) {\n    // This shouldn't happen as the state is initialized in the dispatcher if it's not set\n    throw new Error('Invariant: Router state not initialized')\n  }\n\n  actionQueue.pending = action\n\n  const payload = action.payload\n  const actionResult = actionQueue.action(prevState, payload)\n\n  function handleResult(nextState: AppRouterState) {\n    // if we discarded this action, the state should also be discarded\n    if (action.discarded) {\n      return\n    }\n\n    actionQueue.state = nextState\n\n    if (actionQueue.devToolsInstance) {\n      actionQueue.devToolsInstance.send(payload, nextState)\n    }\n\n    runRemainingActions(actionQueue, setState)\n    action.resolve(nextState)\n  }\n\n  // if the action is a promise, set up a callback to resolve it\n  if (isThenable(actionResult)) {\n    actionResult.then(handleResult, (err) => {\n      runRemainingActions(actionQueue, setState)\n      action.reject(err)\n    })\n  } else {\n    handleResult(actionResult)\n  }\n}\n\nfunction dispatchAction(\n  actionQueue: AppRouterActionQueue,\n  payload: ReducerActions,\n  setState: DispatchStatePromise\n) {\n  let resolvers: {\n    resolve: (value: ReducerState) => void\n    reject: (reason: any) => void\n  } = { resolve: setState, reject: () => {} }\n\n  // most of the action types are async with the exception of restore\n  // it's important that restore is handled quickly since it's fired on the popstate event\n  // and we don't want to add any delay on a back/forward nav\n  // this only creates a promise for the async actions\n  if (payload.type !== ACTION_RESTORE) {\n    // Create the promise and assign the resolvers to the object.\n    const deferredPromise = new Promise<AppRouterState>((resolve, reject) => {\n      resolvers = { resolve, reject }\n    })\n\n    startTransition(() => {\n      // we immediately notify React of the pending promise -- the resolver is attached to the action node\n      // and will be called when the associated action promise resolves\n      setState(deferredPromise)\n    })\n  }\n\n  const newAction: ActionQueueNode = {\n    payload,\n    next: null,\n    resolve: resolvers.resolve,\n    reject: resolvers.reject,\n  }\n\n  // Check if the queue is empty\n  if (actionQueue.pending === null) {\n    // The queue is empty, so add the action and start it immediately\n    // Mark this action as the last in the queue\n    actionQueue.last = newAction\n\n    runAction({\n      actionQueue,\n      action: newAction,\n      setState,\n    })\n  } else if (\n    payload.type === ACTION_NAVIGATE ||\n    payload.type === ACTION_RESTORE\n  ) {\n    // Navigations (including back/forward) take priority over any pending actions.\n    // Mark the pending action as discarded (so the state is never applied) and start the navigation action immediately.\n    actionQueue.pending.discarded = true\n\n    // Mark this action as the last in the queue\n    actionQueue.last = newAction\n\n    // if the pending action was a server action, mark the queue as needing a refresh once events are processed\n    if (actionQueue.pending.payload.type === ACTION_SERVER_ACTION) {\n      actionQueue.needsRefresh = true\n    }\n\n    runAction({\n      actionQueue,\n      action: newAction,\n      setState,\n    })\n  } else {\n    // The queue is not empty, so add the action to the end of the queue\n    // It will be started by runRemainingActions after the previous action finishes\n    if (actionQueue.last !== null) {\n      actionQueue.last.next = newAction\n    }\n    actionQueue.last = newAction\n  }\n}\n\nexport function createMutableActionQueue(): AppRouterActionQueue {\n  const actionQueue: AppRouterActionQueue = {\n    state: null,\n    dispatch: (payload: ReducerActions, setState: DispatchStatePromise) =>\n      dispatchAction(actionQueue, payload, setState),\n    action: async (state: AppRouterState, action: ReducerActions) => {\n      if (state === null) {\n        throw new Error('Invariant: Router state not initialized')\n      }\n      const result = reducer(state, action)\n      return result\n    },\n    pending: null,\n    last: null,\n  }\n\n  return actionQueue\n}\n"],"names":["isThenable","ACTION_REFRESH","ACTION_SERVER_ACTION","ACTION_NAVIGATE","ACTION_RESTORE","reducer","React","startTransition","ActionQueueContext","createContext","runRemainingActions","actionQueue","setState","pending","next","runAction","action","needsRefresh","dispatch","type","origin","window","location","prevState","state","Error","payload","actionResult","handleResult","nextState","discarded","devToolsInstance","send","resolve","then","err","reject","dispatchAction","resolvers","deferredPromise","Promise","newAction","last","createMutableActionQueue","result"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}