{"version":3,"sources":["../../../src/server/app-render/walk-tree-with-flight-router-state.tsx"],"sourcesContent":["import type {\n  FlightDataPath,\n  FlightRouterState,\n  FlightSegmentPath,\n  Segment,\n} from './types'\nimport React from 'react'\nimport {\n  canSegmentBeOverridden,\n  matchSegment,\n} from '../../client/components/match-segments'\nimport type { LoaderTree } from '../lib/app-dir-module'\nimport { getLinkAndScriptTags } from './get-css-inlined-link-tags'\nimport { getPreloadableFonts } from './get-preloadable-fonts'\nimport {\n  addSearchParamsIfPageSegment,\n  createFlightRouterStateFromLoaderTree,\n} from './create-flight-router-state-from-loader-tree'\nimport { parseLoaderTree } from './parse-loader-tree'\nimport type { CreateSegmentPath, AppRenderContext } from './app-render'\nimport { getLayerAssets } from './get-layer-assets'\nimport { hasLoadingComponentInTree } from './has-loading-component-in-tree'\nimport { createComponentTree } from './create-component-tree'\nimport { DEFAULT_SEGMENT_KEY } from '../../shared/lib/segment'\n\n/**\n * Use router state to decide at what common layout to render the page.\n * This can either be the common layout between two pages or a specific place to start rendering from using the \"refetch\" marker in the tree.\n */\nexport async function walkTreeWithFlightRouterState({\n  createSegmentPath,\n  loaderTreeToFilter,\n  parentParams,\n  isFirst,\n  flightRouterState,\n  parentRendered,\n  rscPayloadHead,\n  injectedCSS,\n  injectedJS,\n  injectedFontPreloadTags,\n  rootLayoutIncluded,\n  asNotFound,\n  metadataOutlet,\n  ctx,\n}: {\n  createSegmentPath: CreateSegmentPath\n  loaderTreeToFilter: LoaderTree\n  parentParams: { [key: string]: string | string[] }\n  isFirst: boolean\n  flightRouterState?: FlightRouterState\n  parentRendered?: boolean\n  rscPayloadHead: React.ReactNode\n  injectedCSS: Set<string>\n  injectedJS: Set<string>\n  injectedFontPreloadTags: Set<string>\n  rootLayoutIncluded: boolean\n  asNotFound?: boolean\n  metadataOutlet: React.ReactNode\n  ctx: AppRenderContext\n}): Promise<FlightDataPath[]> {\n  const {\n    renderOpts: { nextFontManifest, experimental },\n    query,\n    isPrefetch,\n    getDynamicParamFromSegment,\n    componentMod: { tree: loaderTree },\n  } = ctx\n\n  const [segment, parallelRoutes, components] = loaderTreeToFilter\n\n  const parallelRoutesKeys = Object.keys(parallelRoutes)\n\n  const { layout } = components\n  const isLayout = typeof layout !== 'undefined'\n\n  /**\n   * Checks if the current segment is a root layout.\n   */\n  const rootLayoutAtThisLevel = isLayout && !rootLayoutIncluded\n  /**\n   * Checks if the current segment or any level above it has a root layout.\n   */\n  const rootLayoutIncludedAtThisLevelOrAbove =\n    rootLayoutIncluded || rootLayoutAtThisLevel\n\n  // Because this function walks to a deeper point in the tree to start rendering we have to track the dynamic parameters up to the point where rendering starts\n  const segmentParam = getDynamicParamFromSegment(segment)\n  const currentParams =\n    // Handle null case where dynamic param is optional\n    segmentParam && segmentParam.value !== null\n      ? {\n          ...parentParams,\n          [segmentParam.param]: segmentParam.value,\n        }\n      : parentParams\n  const actualSegment: Segment = addSearchParamsIfPageSegment(\n    segmentParam ? segmentParam.treeSegment : segment,\n    query\n  )\n\n  /**\n   * Decide if the current segment is where rendering has to start.\n   */\n  const renderComponentsOnThisLevel =\n    // No further router state available\n    !flightRouterState ||\n    // Segment in router state does not match current segment\n    !matchSegment(actualSegment, flightRouterState[0]) ||\n    // Last item in the tree\n    parallelRoutesKeys.length === 0 ||\n    // Explicit refresh\n    flightRouterState[3] === 'refetch'\n\n  const shouldSkipComponentTree =\n    // loading.tsx has no effect on prefetching when PPR is enabled\n    !experimental.isRoutePPREnabled &&\n    isPrefetch &&\n    !Boolean(components.loading) &&\n    (flightRouterState ||\n      // If there is no flightRouterState, we need to check the entire loader tree, as otherwise we'll be only checking the root\n      !hasLoadingComponentInTree(loaderTree))\n\n  if (!parentRendered && renderComponentsOnThisLevel) {\n    const overriddenSegment =\n      flightRouterState &&\n      canSegmentBeOverridden(actualSegment, flightRouterState[0])\n        ? flightRouterState[0]\n        : actualSegment\n\n    const routerState = createFlightRouterStateFromLoaderTree(\n      // Create router state using the slice of the loaderTree\n      loaderTreeToFilter,\n      getDynamicParamFromSegment,\n      query\n    )\n\n    if (shouldSkipComponentTree) {\n      // Send only the router state\n      return [[overriddenSegment, routerState, null, null]]\n    } else {\n      // Create component tree using the slice of the loaderTree\n      const { seedData } = await createComponentTree(\n        // This ensures flightRouterPath is valid and filters down the tree\n        {\n          ctx,\n          createSegmentPath,\n          loaderTree: loaderTreeToFilter,\n          parentParams: currentParams,\n          firstItem: isFirst,\n          injectedCSS,\n          injectedJS,\n          injectedFontPreloadTags,\n          // This is intentionally not \"rootLayoutIncludedAtThisLevelOrAbove\" as createComponentTree starts at the current level and does a check for \"rootLayoutAtThisLevel\" too.\n          rootLayoutIncluded,\n          asNotFound,\n          metadataOutlet,\n        }\n      )\n\n      // Create head\n      const { layoutOrPagePath } = parseLoaderTree(loaderTreeToFilter)\n      const layerAssets = getLayerAssets({\n        ctx,\n        layoutOrPagePath,\n        injectedCSS: new Set(injectedCSS),\n        injectedJS: new Set(injectedJS),\n        injectedFontPreloadTags: new Set(injectedFontPreloadTags),\n      })\n      const head = (\n        <>\n          {layerAssets}\n          {rscPayloadHead}\n        </>\n      )\n\n      return [[overriddenSegment, routerState, seedData, head]]\n    }\n  }\n\n  // If we are not rendering on this level we need to check if the current\n  // segment has a layout. If so, we need to track all the used CSS to make\n  // the result consistent.\n  const layoutPath = layout?.[1]\n  const injectedCSSWithCurrentLayout = new Set(injectedCSS)\n  const injectedJSWithCurrentLayout = new Set(injectedJS)\n  const injectedFontPreloadTagsWithCurrentLayout = new Set(\n    injectedFontPreloadTags\n  )\n  if (layoutPath) {\n    getLinkAndScriptTags(\n      ctx.clientReferenceManifest,\n      layoutPath,\n      injectedCSSWithCurrentLayout,\n      injectedJSWithCurrentLayout,\n      true\n    )\n    getPreloadableFonts(\n      nextFontManifest,\n      layoutPath,\n      injectedFontPreloadTagsWithCurrentLayout\n    )\n  }\n\n  // Walk through all parallel routes.\n  const paths: FlightDataPath[] = (\n    await Promise.all(\n      parallelRoutesKeys.map(async (parallelRouteKey) => {\n        // for (const parallelRouteKey of parallelRoutesKeys) {\n        const parallelRoute = parallelRoutes[parallelRouteKey]\n\n        const currentSegmentPath: FlightSegmentPath = isFirst\n          ? [parallelRouteKey]\n          : [actualSegment, parallelRouteKey]\n\n        const path = await walkTreeWithFlightRouterState({\n          ctx,\n          createSegmentPath: (child) => {\n            return createSegmentPath([...currentSegmentPath, ...child])\n          },\n          loaderTreeToFilter: parallelRoute,\n          parentParams: currentParams,\n          flightRouterState:\n            flightRouterState && flightRouterState[1][parallelRouteKey],\n          parentRendered: parentRendered || renderComponentsOnThisLevel,\n          isFirst: false,\n          rscPayloadHead,\n          injectedCSS: injectedCSSWithCurrentLayout,\n          injectedJS: injectedJSWithCurrentLayout,\n          injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,\n          rootLayoutIncluded: rootLayoutIncludedAtThisLevelOrAbove,\n          asNotFound,\n          metadataOutlet,\n        })\n\n        return path\n          .map((item) => {\n            // we don't need to send over default routes in the flight data\n            // because they are always ignored by the client, unless it's a refetch\n            if (\n              item[0] === DEFAULT_SEGMENT_KEY &&\n              flightRouterState &&\n              !!flightRouterState[1][parallelRouteKey][0] &&\n              flightRouterState[1][parallelRouteKey][3] !== 'refetch'\n            ) {\n              return null\n            }\n            return [actualSegment, parallelRouteKey, ...item]\n          })\n          .filter(Boolean) as FlightDataPath[]\n      })\n    )\n  ).flat()\n\n  return paths\n}\n"],"names":["walkTreeWithFlightRouterState","createSegmentPath","loaderTreeToFilter","parentParams","isFirst","flightRouterState","parentRendered","rscPayloadHead","injectedCSS","injectedJS","injectedFontPreloadTags","rootLayoutIncluded","asNotFound","metadataOutlet","ctx","renderOpts","nextFontManifest","experimental","query","isPrefetch","getDynamicParamFromSegment","componentMod","tree","loaderTree","segment","parallelRoutes","components","parallelRoutesKeys","Object","keys","layout","isLayout","rootLayoutAtThisLevel","rootLayoutIncludedAtThisLevelOrAbove","segmentParam","currentParams","value","param","actualSegment","addSearchParamsIfPageSegment","treeSegment","renderComponentsOnThisLevel","matchSegment","length","shouldSkipComponentTree","isRoutePPREnabled","Boolean","loading","hasLoadingComponentInTree","overriddenSegment","canSegmentBeOverridden","routerState","createFlightRouterStateFromLoaderTree","seedData","createComponentTree","firstItem","layoutOrPagePath","parseLoaderTree","layerAssets","getLayerAssets","Set","head","layoutPath","injectedCSSWithCurrentLayout","injectedJSWithCurrentLayout","injectedFontPreloadTagsWithCurrentLayout","getLinkAndScriptTags","clientReferenceManifest","getPreloadableFonts","paths","Promise","all","map","parallelRouteKey","parallelRoute","currentSegmentPath","path","child","item","DEFAULT_SEGMENT_KEY","filter","flat"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}