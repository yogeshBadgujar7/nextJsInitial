{"version":3,"sources":["../../../src/server/app-render/app-render.tsx"],"sourcesContent":["import type {\n  ActionResult,\n  DynamicParamTypesShort,\n  FlightData,\n  FlightRouterState,\n  FlightSegmentPath,\n  RenderOpts,\n  Segment,\n  CacheNodeSeedData,\n} from './types'\nimport type { StaticGenerationStore } from '../../client/components/static-generation-async-storage.external'\nimport type { RequestStore } from '../../client/components/request-async-storage.external'\nimport type { NextParsedUrlQuery } from '../request-meta'\nimport type { LoaderTree } from '../lib/app-dir-module'\nimport type { AppPageModule } from '../future/route-modules/app-page/module'\nimport type { ClientReferenceManifest } from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { Revalidate } from '../lib/revalidate'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport type { BaseNextRequest, BaseNextResponse } from '../base-http'\n\nimport React from 'react'\n\nimport RenderResult, {\n  type AppPageRenderResultMetadata,\n  type RenderResultOptions,\n  type RenderResultResponse,\n} from '../render-result'\nimport {\n  chainStreams,\n  renderToInitialFizzStream,\n  continueFizzStream,\n  continueDynamicPrerender,\n  continueStaticPrerender,\n  continueDynamicHTMLResume,\n  continueDynamicDataResume,\n} from '../stream-utils/node-web-streams-helper'\nimport { canSegmentBeOverridden } from '../../client/components/match-segments'\nimport { stripInternalQueries } from '../internal-utils'\nimport {\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE,\n  NEXT_URL,\n  RSC_HEADER,\n} from '../../client/components/app-router-headers'\nimport { createMetadataComponents } from '../../lib/metadata/metadata'\nimport { RequestAsyncStorageWrapper } from '../async-storage/request-async-storage-wrapper'\nimport { StaticGenerationAsyncStorageWrapper } from '../async-storage/static-generation-async-storage-wrapper'\nimport { isNotFoundError } from '../../client/components/not-found'\nimport {\n  getURLFromRedirectError,\n  isRedirectError,\n  getRedirectStatusCodeFromError,\n} from '../../client/components/redirect'\nimport { addImplicitTags } from '../lib/patch-fetch'\nimport { AppRenderSpan, NextNodeServerSpan } from '../lib/trace/constants'\nimport { getTracer } from '../lib/trace/tracer'\nimport { FlightRenderResult } from './flight-render-result'\nimport {\n  createErrorHandler,\n  ErrorHandlerSource,\n  type ErrorHandler,\n} from './create-error-handler'\nimport {\n  getShortDynamicParamType,\n  dynamicParamTypes,\n} from './get-short-dynamic-param-type'\nimport { getSegmentParam } from './get-segment-param'\nimport { getScriptNonceFromHeader } from './get-script-nonce-from-header'\nimport { parseAndValidateFlightRouterState } from './parse-and-validate-flight-router-state'\nimport { validateURL } from './validate-url'\nimport { createFlightRouterStateFromLoaderTree } from './create-flight-router-state-from-loader-tree'\nimport { handleAction } from './action-handler'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { warn, error } from '../../build/output/log'\nimport { appendMutableCookies } from '../web/spec-extension/adapters/request-cookies'\nimport { createServerInsertedHTML } from './server-inserted-html'\nimport { getRequiredScripts } from './required-scripts'\nimport { addPathPrefix } from '../../shared/lib/router/utils/add-path-prefix'\nimport {\n  getTracedMetadata,\n  makeGetServerInsertedHTML,\n} from './make-get-server-inserted-html'\nimport { walkTreeWithFlightRouterState } from './walk-tree-with-flight-router-state'\nimport { createComponentTree } from './create-component-tree'\nimport { getAssetQueryString } from './get-asset-query-string'\nimport { setReferenceManifestsSingleton } from './encryption-utils'\nimport {\n  createStaticRenderer,\n  getDynamicDataPostponedState,\n  getDynamicHTMLPostponedState,\n} from './static/static-renderer'\nimport { isDynamicServerError } from '../../client/components/hooks-server-context'\nimport {\n  useFlightStream,\n  createInlinedDataReadableStream,\n  flightRenderComplete,\n} from './use-flight-response'\nimport {\n  StaticGenBailoutError,\n  isStaticGenBailoutError,\n} from '../../client/components/static-generation-bailout'\nimport { isInterceptionRouteAppPath } from '../future/helpers/interception-routes'\nimport { getStackWithoutErrorMessage } from '../../lib/format-server-error'\nimport {\n  usedDynamicAPIs,\n  createPostponedAbortSignal,\n  formatDynamicAPIAccesses,\n} from './dynamic-rendering'\nimport {\n  getClientComponentLoaderMetrics,\n  wrapClientComponentLoader,\n} from '../client-component-renderer-logger'\nimport { createServerModuleMap } from './action-utils'\nimport { isNodeNextRequest } from '../base-http/helpers'\nimport { parseParameter } from '../../shared/lib/router/utils/route-regex'\n\nexport type GetDynamicParamFromSegment = (\n  // [slug] / [[slug]] / [...slug]\n  segment: string\n) => {\n  param: string\n  value: string | string[] | null\n  treeSegment: Segment\n  type: DynamicParamTypesShort\n} | null\n\ntype AppRenderBaseContext = {\n  staticGenerationStore: StaticGenerationStore\n  requestStore: RequestStore\n  componentMod: AppPageModule\n  renderOpts: RenderOpts\n}\n\nexport type GenerateFlight = typeof generateFlight\n\nexport type AppRenderContext = AppRenderBaseContext & {\n  getDynamicParamFromSegment: GetDynamicParamFromSegment\n  query: NextParsedUrlQuery\n  isPrefetch: boolean\n  requestTimestamp: number\n  appUsingSizeAdjustment: boolean\n  flightRouterState?: FlightRouterState\n  requestId: string\n  defaultRevalidate: Revalidate\n  pagePath: string\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n  assetPrefix: string\n  flightDataRendererErrorHandler: ErrorHandler\n  serverComponentsErrorHandler: ErrorHandler\n  isNotFoundPath: boolean\n  nonce: string | undefined\n  res: BaseNextResponse\n}\n\nfunction createNotFoundLoaderTree(loaderTree: LoaderTree): LoaderTree {\n  // Align the segment with parallel-route-default in next-app-loader\n  return ['', {}, loaderTree[2]]\n}\n\n/* This method is important for intercepted routes to function:\n * when a route is intercepted, e.g. /blog/[slug], it will be rendered\n * with the layout of the previous page, e.g. /profile/[id]. The problem is\n * that the loader tree needs to know the dynamic param in order to render (id and slug in the example).\n * Normally they are read from the path but since we are intercepting the route, the path would not contain id,\n * so we need to read it from the router state.\n */\nfunction findDynamicParamFromRouterState(\n  flightRouterState: FlightRouterState | undefined,\n  segment: string\n): {\n  param: string\n  value: string | string[] | null\n  treeSegment: Segment\n  type: DynamicParamTypesShort\n} | null {\n  if (!flightRouterState) {\n    return null\n  }\n\n  const treeSegment = flightRouterState[0]\n\n  if (canSegmentBeOverridden(segment, treeSegment)) {\n    if (!Array.isArray(treeSegment) || Array.isArray(segment)) {\n      return null\n    }\n\n    return {\n      param: treeSegment[0],\n      value: treeSegment[1],\n      treeSegment: treeSegment,\n      type: treeSegment[2],\n    }\n  }\n\n  for (const parallelRouterState of Object.values(flightRouterState[1])) {\n    const maybeDynamicParam = findDynamicParamFromRouterState(\n      parallelRouterState,\n      segment\n    )\n    if (maybeDynamicParam) {\n      return maybeDynamicParam\n    }\n  }\n\n  return null\n}\n\nexport type CreateSegmentPath = (child: FlightSegmentPath) => FlightSegmentPath\n\n/**\n * Returns a function that parses the dynamic segment and return the associated value.\n */\nfunction makeGetDynamicParamFromSegment(\n  params: { [key: string]: any },\n  pagePath: string,\n  flightRouterState: FlightRouterState | undefined\n): GetDynamicParamFromSegment {\n  return function getDynamicParamFromSegment(\n    // [slug] / [[slug]] / [...slug]\n    segment: string\n  ) {\n    const segmentParam = getSegmentParam(segment)\n    if (!segmentParam) {\n      return null\n    }\n\n    const key = segmentParam.param\n\n    let value = params[key]\n\n    // this is a special marker that will be present for interception routes\n    if (value === '__NEXT_EMPTY_PARAM__') {\n      value = undefined\n    }\n\n    if (Array.isArray(value)) {\n      value = value.map((i) => encodeURIComponent(i))\n    } else if (typeof value === 'string') {\n      value = encodeURIComponent(value)\n    }\n\n    if (!value) {\n      const isCatchall = segmentParam.type === 'catchall'\n      const isOptionalCatchall = segmentParam.type === 'optional-catchall'\n\n      if (isCatchall || isOptionalCatchall) {\n        const dynamicParamType = dynamicParamTypes[segmentParam.type]\n        // handle the case where an optional catchall does not have a value,\n        // e.g. `/dashboard/[[...slug]]` when requesting `/dashboard`\n        if (isOptionalCatchall) {\n          return {\n            param: key,\n            value: null,\n            type: dynamicParamType,\n            treeSegment: [key, '', dynamicParamType],\n          }\n        }\n\n        // handle the case where a catchall or optional catchall does not have a value,\n        // e.g. `/foo/bar/hello` and `@slot/[...catchall]` or `@slot/[[...catchall]]` is matched\n        value = pagePath\n          .split('/')\n          // remove the first empty string\n          .slice(1)\n          // replace any dynamic params with the actual values\n          .flatMap((pathSegment) => {\n            const param = parseParameter(pathSegment)\n            // if the segment matches a param, return the param value\n            // otherwise, it's a static segment, so just return that\n            return params[param.key] ?? param.key\n          })\n\n        return {\n          param: key,\n          value,\n          type: dynamicParamType,\n          // This value always has to be a string.\n          treeSegment: [key, value.join('/'), dynamicParamType],\n        }\n      }\n\n      return findDynamicParamFromRouterState(flightRouterState, segment)\n    }\n\n    const type = getShortDynamicParamType(segmentParam.type)\n\n    return {\n      param: key,\n      // The value that is passed to user code.\n      value: value,\n      // The value that is rendered in the router tree.\n      treeSegment: [key, Array.isArray(value) ? value.join('/') : value, type],\n      type: type,\n    }\n  }\n}\n\n// Handle Flight render request. This is only used when client-side navigating. E.g. when you `router.push('/dashboard')` or `router.reload()`.\nasync function generateFlight(\n  ctx: AppRenderContext,\n  options?: {\n    actionResult: ActionResult\n    skipFlight: boolean\n    asNotFound?: boolean\n  }\n): Promise<RenderResult> {\n  // Flight data that is going to be passed to the browser.\n  // Currently a single item array but in the future multiple patches might be combined in a single request.\n  let flightData: FlightData | null = null\n\n  const {\n    componentMod: {\n      tree: loaderTree,\n      renderToReadableStream,\n      createDynamicallyTrackedSearchParams,\n    },\n    getDynamicParamFromSegment,\n    appUsingSizeAdjustment,\n    staticGenerationStore: { urlPathname },\n    query,\n    requestId,\n    flightRouterState,\n  } = ctx\n\n  if (!options?.skipFlight) {\n    const [MetadataTree, MetadataOutlet] = createMetadataComponents({\n      tree: loaderTree,\n      pathname: urlPathname,\n      trailingSlash: ctx.renderOpts.trailingSlash,\n      query,\n      getDynamicParamFromSegment,\n      appUsingSizeAdjustment,\n      createDynamicallyTrackedSearchParams,\n    })\n    flightData = (\n      await walkTreeWithFlightRouterState({\n        ctx,\n        createSegmentPath: (child) => child,\n        loaderTreeToFilter: loaderTree,\n        parentParams: {},\n        flightRouterState,\n        isFirst: true,\n        // For flight, render metadata inside leaf page\n        rscPayloadHead: (\n          // Adding requestId as react key to make metadata remount for each render\n          <MetadataTree key={requestId} />\n        ),\n        injectedCSS: new Set(),\n        injectedJS: new Set(),\n        injectedFontPreloadTags: new Set(),\n        rootLayoutIncluded: false,\n        asNotFound: ctx.isNotFoundPath || options?.asNotFound,\n        metadataOutlet: <MetadataOutlet />,\n      })\n    ).map((path) => path.slice(1)) // remove the '' (root) segment\n  }\n\n  const buildIdFlightDataPair = [ctx.renderOpts.buildId, flightData]\n\n  // For app dir, use the bundled version of Flight server renderer (renderToReadableStream)\n  // which contains the subset React.\n  const flightReadableStream = renderToReadableStream(\n    options\n      ? [options.actionResult, buildIdFlightDataPair]\n      : buildIdFlightDataPair,\n    ctx.clientReferenceManifest.clientModules,\n    {\n      onError: ctx.flightDataRendererErrorHandler,\n      nonce: ctx.nonce,\n    }\n  )\n\n  return new FlightRenderResult(flightReadableStream)\n}\n\ntype RenderToStreamResult = {\n  stream: RenderResultResponse\n  err?: unknown\n}\n\ntype RenderToStreamOptions = {\n  /**\n   * This option is used to indicate that the page should be rendered as\n   * if it was not found. When it's enabled, instead of rendering the\n   * page component, it renders the not-found segment.\n   *\n   */\n  asNotFound: boolean\n  tree: LoaderTree\n  formState: any\n}\n\n/**\n * Creates a resolver that eagerly generates a flight payload that is then\n * resolved when the resolver is called.\n */\nfunction createFlightDataResolver(ctx: AppRenderContext) {\n  // Generate the flight data and as soon as it can, convert it into a string.\n  const promise = generateFlight(ctx)\n    .then(async (result) => ({\n      flightData: await result.toUnchunkedString(true),\n    }))\n    // Otherwise if it errored, return the error.\n    .catch((err) => ({ err }))\n\n  return async () => {\n    // Resolve the promise to get the flight data or error.\n    const result = await promise\n\n    // If the flight data failed to render due to an error, re-throw the error\n    // here.\n    if ('err' in result) {\n      throw result.err\n    }\n\n    // Otherwise, return the flight data.\n    return result.flightData\n  }\n}\n\ntype ReactServerAppProps = {\n  tree: LoaderTree\n  ctx: AppRenderContext\n  asNotFound: boolean\n}\n// This is the root component that runs in the RSC context\nasync function ReactServerApp({ tree, ctx, asNotFound }: ReactServerAppProps) {\n  // Create full component tree from root to leaf.\n  const injectedCSS = new Set<string>()\n  const injectedJS = new Set<string>()\n  const injectedFontPreloadTags = new Set<string>()\n  const missingSlots = new Set<string>()\n  const {\n    getDynamicParamFromSegment,\n    query,\n    appUsingSizeAdjustment,\n    componentMod: {\n      AppRouter,\n      GlobalError,\n      createDynamicallyTrackedSearchParams,\n    },\n    staticGenerationStore: { urlPathname },\n  } = ctx\n  const initialTree = createFlightRouterStateFromLoaderTree(\n    tree,\n    getDynamicParamFromSegment,\n    query\n  )\n\n  const [MetadataTree, MetadataOutlet] = createMetadataComponents({\n    tree,\n    errorType: asNotFound ? 'not-found' : undefined,\n    pathname: urlPathname,\n    trailingSlash: ctx.renderOpts.trailingSlash,\n    query,\n    getDynamicParamFromSegment: getDynamicParamFromSegment,\n    appUsingSizeAdjustment: appUsingSizeAdjustment,\n    createDynamicallyTrackedSearchParams,\n  })\n\n  const { seedData, styles } = await createComponentTree({\n    ctx,\n    createSegmentPath: (child) => child,\n    loaderTree: tree,\n    parentParams: {},\n    firstItem: true,\n    injectedCSS,\n    injectedJS,\n    injectedFontPreloadTags,\n    rootLayoutIncluded: false,\n    asNotFound: asNotFound,\n    metadataOutlet: <MetadataOutlet />,\n    missingSlots,\n  })\n\n  // When the `vary` response header is present with `Next-URL`, that means there's a chance\n  // it could respond differently if there's an interception route. We provide this information\n  // to `AppRouter` so that it can properly seed the prefetch cache with a prefix, if needed.\n  const varyHeader = ctx.res.getHeader('vary')\n  const couldBeIntercepted =\n    typeof varyHeader === 'string' && varyHeader.includes(NEXT_URL)\n\n  return (\n    <>\n      {styles}\n      <AppRouter\n        buildId={ctx.renderOpts.buildId}\n        assetPrefix={ctx.assetPrefix}\n        initialCanonicalUrl={urlPathname}\n        // This is the router state tree.\n        initialTree={initialTree}\n        // This is the tree of React nodes that are seeded into the cache\n        initialSeedData={seedData}\n        couldBeIntercepted={couldBeIntercepted}\n        initialHead={\n          <>\n            {typeof ctx.res.statusCode === 'number' &&\n              ctx.res.statusCode > 400 && (\n                <meta name=\"robots\" content=\"noindex\" />\n              )}\n            {/* Adding requestId as react key to make metadata remount for each render */}\n            <MetadataTree key={ctx.requestId} />\n          </>\n        }\n        globalErrorComponent={GlobalError}\n        // This is used to provide debug information (when in development mode)\n        // about which slots were not filled by page components while creating the component tree.\n        missingSlots={missingSlots}\n      />\n    </>\n  )\n}\n\ntype ReactServerErrorProps = {\n  tree: LoaderTree\n  ctx: AppRenderContext\n  errorType: 'not-found' | 'redirect' | undefined\n}\n// This is the root component that runs in the RSC context\nasync function ReactServerError({\n  tree,\n  ctx,\n  errorType,\n}: ReactServerErrorProps) {\n  const {\n    getDynamicParamFromSegment,\n    query,\n    appUsingSizeAdjustment,\n    componentMod: {\n      AppRouter,\n      GlobalError,\n      createDynamicallyTrackedSearchParams,\n    },\n    staticGenerationStore: { urlPathname },\n    requestId,\n    res,\n  } = ctx\n\n  const [MetadataTree] = createMetadataComponents({\n    tree,\n    pathname: urlPathname,\n    trailingSlash: ctx.renderOpts.trailingSlash,\n    errorType,\n    query,\n    getDynamicParamFromSegment,\n    appUsingSizeAdjustment,\n    createDynamicallyTrackedSearchParams,\n  })\n\n  const head = (\n    <>\n      {/* Adding requestId as react key to make metadata remount for each render */}\n      <MetadataTree key={requestId} />\n      {typeof res.statusCode === 'number' && res.statusCode >= 400 && (\n        <meta name=\"robots\" content=\"noindex\" />\n      )}\n      {process.env.NODE_ENV === 'development' && (\n        <meta name=\"next-error\" content=\"not-found\" />\n      )}\n    </>\n  )\n\n  const initialTree = createFlightRouterStateFromLoaderTree(\n    tree,\n    getDynamicParamFromSegment,\n    query\n  )\n\n  // For metadata notFound error there's no global not found boundary on top\n  // so we create a not found page with AppRouter\n  const initialSeedData: CacheNodeSeedData = [\n    initialTree[0],\n    {},\n    <html id=\"__next_error__\">\n      <head></head>\n      <body></body>\n    </html>,\n    null,\n  ]\n  return (\n    <AppRouter\n      buildId={ctx.renderOpts.buildId}\n      assetPrefix={ctx.assetPrefix}\n      initialCanonicalUrl={urlPathname}\n      initialTree={initialTree}\n      initialHead={head}\n      globalErrorComponent={GlobalError}\n      initialSeedData={initialSeedData}\n      missingSlots={new Set()}\n    />\n  )\n}\n\n// This component must run in an SSR context. It will render the RSC root component\nfunction ReactServerEntrypoint<T>({\n  reactServerStream,\n  preinitScripts,\n  clientReferenceManifest,\n  nonce,\n}: {\n  reactServerStream: BinaryStreamOf<T>\n  preinitScripts: () => void\n  clientReferenceManifest: NonNullable<RenderOpts['clientReferenceManifest']>\n  nonce?: string\n}): T {\n  preinitScripts()\n  const response = useFlightStream(\n    reactServerStream,\n    clientReferenceManifest,\n    nonce\n  )\n  return React.use(response)\n}\n\n// We use a trick with TS Generics to branch streams with a type so we can\n// consume the parsed value of a Readable Stream if it was constructed with a\n// certain object shape. The generic type is not used directly in the type so it\n// requires a disabling of the eslint rule disallowing unused vars\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport type BinaryStreamOf<T> = ReadableStream<Uint8Array>\n\nasync function renderToHTMLOrFlightImpl(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  pagePath: string,\n  query: NextParsedUrlQuery,\n  renderOpts: RenderOpts,\n  baseCtx: AppRenderBaseContext,\n  requestEndedState: { ended?: boolean }\n) {\n  const isNotFoundPath = pagePath === '/404'\n\n  // A unique request timestamp used by development to ensure that it's\n  // consistent and won't change during this request. This is important to\n  // avoid that resources can be deduped by React Float if the same resource is\n  // rendered or preloaded multiple times: `<link href=\"a.css?v={Date.now()}\"/>`.\n  const requestTimestamp = Date.now()\n\n  const {\n    buildManifest,\n    subresourceIntegrityManifest,\n    serverActionsManifest,\n    ComponentMod,\n    dev,\n    nextFontManifest,\n    supportsDynamicHTML,\n    serverActions,\n    appDirDevErrorLogger,\n    assetPrefix = '',\n    enableTainting,\n  } = renderOpts\n\n  // We need to expose the bundled `require` API globally for\n  // react-server-dom-webpack. This is a hack until we find a better way.\n  if (ComponentMod.__next_app__) {\n    const instrumented = wrapClientComponentLoader(ComponentMod)\n    // @ts-ignore\n    globalThis.__next_require__ = instrumented.require\n    // @ts-ignore\n    globalThis.__next_chunk_load__ = instrumented.loadChunk\n  }\n\n  if (\n    // The type check here ensures that `req` is correctly typed, and the\n    // environment variable check provides dead code elimination.\n    process.env.NEXT_RUNTIME !== 'edge' &&\n    isNodeNextRequest(req)\n  ) {\n    req.originalRequest.on('end', () => {\n      requestEndedState.ended = true\n\n      if ('performance' in globalThis) {\n        const metrics = getClientComponentLoaderMetrics({ reset: true })\n        if (metrics) {\n          getTracer()\n            .startSpan(NextNodeServerSpan.clientComponentLoading, {\n              startTime: metrics.clientComponentLoadStart,\n              attributes: {\n                'next.clientComponentLoadCount':\n                  metrics.clientComponentLoadCount,\n              },\n            })\n            .end(\n              metrics.clientComponentLoadStart +\n                metrics.clientComponentLoadTimes\n            )\n        }\n      }\n    })\n  }\n\n  const metadata: AppPageRenderResultMetadata = {}\n\n  const appUsingSizeAdjustment = !!nextFontManifest?.appUsingSizeAdjust\n\n  // TODO: fix this typescript\n  const clientReferenceManifest = renderOpts.clientReferenceManifest!\n\n  const serverModuleMap = createServerModuleMap({\n    serverActionsManifest,\n    pageName: renderOpts.page,\n  })\n\n  setReferenceManifestsSingleton({\n    clientReferenceManifest,\n    serverActionsManifest,\n    serverModuleMap,\n  })\n\n  const digestErrorsMap: Map<string, Error> = new Map()\n  const allCapturedErrors: Error[] = []\n  const isNextExport = !!renderOpts.nextExport\n  const { staticGenerationStore, requestStore } = baseCtx\n  const { isStaticGeneration } = staticGenerationStore\n\n  /**\n   * Sets the headers on the response object. If we're generating static HTML,\n   * we store the headers in the metadata object as well so that they can be\n   * persisted.\n   */\n  const setHeader = isStaticGeneration\n    ? (name: string, value: string | string[]) => {\n        res.setHeader(name, value)\n\n        metadata.headers ??= {}\n        metadata.headers[name] = res.getHeader(name)\n\n        return res\n      }\n    : res.setHeader.bind(res)\n\n  const isRoutePPREnabled = renderOpts.experimental.isRoutePPREnabled === true\n\n  // When static generation fails during PPR, we log the errors separately. We\n  // intentionally silence the error logger in this case to avoid double\n  // logging.\n  const silenceStaticGenerationErrors = isRoutePPREnabled && isStaticGeneration\n\n  const serverComponentsErrorHandler = createErrorHandler({\n    source: ErrorHandlerSource.serverComponents,\n    dev,\n    isNextExport,\n    errorLogger: appDirDevErrorLogger,\n    digestErrorsMap,\n    silenceLogger: silenceStaticGenerationErrors,\n  })\n  const flightDataRendererErrorHandler = createErrorHandler({\n    source: ErrorHandlerSource.flightData,\n    dev,\n    isNextExport,\n    errorLogger: appDirDevErrorLogger,\n    digestErrorsMap,\n    silenceLogger: silenceStaticGenerationErrors,\n  })\n  const htmlRendererErrorHandler = createErrorHandler({\n    source: ErrorHandlerSource.html,\n    dev,\n    isNextExport,\n    errorLogger: appDirDevErrorLogger,\n    digestErrorsMap,\n    allCapturedErrors,\n    silenceLogger: silenceStaticGenerationErrors,\n  })\n\n  ComponentMod.patchFetch()\n\n  if (renderOpts.experimental.after) {\n    ComponentMod.patchCacheScopeSupportIntoReact()\n  }\n\n  /**\n   * Rules of Static & Dynamic HTML:\n   *\n   *    1.) We must generate static HTML unless the caller explicitly opts\n   *        in to dynamic HTML support.\n   *\n   *    2.) If dynamic HTML support is requested, we must honor that request\n   *        or throw an error. It is the sole responsibility of the caller to\n   *        ensure they aren't e.g. requesting dynamic HTML for an AMP page.\n   *\n   * These rules help ensure that other existing features like request caching,\n   * coalescing, and ISR continue working as intended.\n   */\n  const generateStaticHTML = supportsDynamicHTML !== true\n\n  // Pull out the hooks/references from the component.\n  const { tree: loaderTree, taintObjectReference } = ComponentMod\n\n  if (enableTainting) {\n    taintObjectReference(\n      'Do not pass process.env to client components since it will leak sensitive data',\n      process.env\n    )\n  }\n\n  staticGenerationStore.fetchMetrics = []\n  metadata.fetchMetrics = staticGenerationStore.fetchMetrics\n\n  // don't modify original query object\n  query = { ...query }\n  stripInternalQueries(query)\n\n  const isRSCRequest = req.headers[RSC_HEADER.toLowerCase()] !== undefined\n\n  const isPrefetchRSCRequest =\n    isRSCRequest &&\n    req.headers[NEXT_ROUTER_PREFETCH_HEADER.toLowerCase()] !== undefined\n\n  /**\n   * Router state provided from the client-side router. Used to handle rendering\n   * from the common layout down. This value will be undefined if the request\n   * is not a client-side navigation request or if the request is a prefetch\n   * request (except when it's a prefetch request for an interception route\n   * which is always dynamic).\n   */\n  const shouldProvideFlightRouterState =\n    isRSCRequest &&\n    (!isPrefetchRSCRequest ||\n      !isRoutePPREnabled ||\n      // Interception routes currently depend on the flight router state to\n      // extract dynamic params.\n      isInterceptionRouteAppPath(pagePath))\n\n  const parsedFlightRouterState = parseAndValidateFlightRouterState(\n    req.headers[NEXT_ROUTER_STATE_TREE.toLowerCase()]\n  )\n\n  /**\n   * The metadata items array created in next-app-loader with all relevant information\n   * that we need to resolve the final metadata.\n   */\n  let requestId: string\n\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    requestId = crypto.randomUUID()\n  } else {\n    requestId = require('next/dist/compiled/nanoid').nanoid()\n  }\n\n  /**\n   * Dynamic parameters. E.g. when you visit `/dashboard/vercel` which is rendered by `/dashboard/[slug]` the value will be {\"slug\": \"vercel\"}.\n   */\n  const params = renderOpts.params ?? {}\n\n  const getDynamicParamFromSegment = makeGetDynamicParamFromSegment(\n    params,\n    pagePath,\n    // `FlightRouterState` is unconditionally provided here because this method uses it\n    // to extract dynamic params as a fallback if they're not present in the path.\n    parsedFlightRouterState\n  )\n\n  // Get the nonce from the incoming request if it has one.\n  const csp =\n    req.headers['content-security-policy'] ||\n    req.headers['content-security-policy-report-only']\n  let nonce: string | undefined\n  if (csp && typeof csp === 'string') {\n    nonce = getScriptNonceFromHeader(csp)\n  }\n\n  const ctx: AppRenderContext = {\n    ...baseCtx,\n    getDynamicParamFromSegment,\n    query,\n    isPrefetch: isPrefetchRSCRequest,\n    requestTimestamp,\n    appUsingSizeAdjustment,\n    flightRouterState: shouldProvideFlightRouterState\n      ? parsedFlightRouterState\n      : undefined,\n    requestId,\n    defaultRevalidate: false,\n    pagePath,\n    clientReferenceManifest,\n    assetPrefix,\n    flightDataRendererErrorHandler,\n    serverComponentsErrorHandler,\n    isNotFoundPath,\n    nonce,\n    res,\n  }\n\n  if (isRSCRequest && !isStaticGeneration) {\n    return generateFlight(ctx)\n  }\n\n  // Create the resolver that can get the flight payload when it's ready or\n  // throw the error if it occurred. If we are not generating static HTML, we\n  // don't need to generate the flight payload because it's a dynamic request\n  // which means we're either getting the flight payload only or just the\n  // regular HTML.\n  const flightDataResolver = isStaticGeneration\n    ? createFlightDataResolver(ctx)\n    : null\n\n  const validateRootLayout = dev\n\n  const { HeadManagerContext } =\n    require('../../shared/lib/head-manager-context.shared-runtime') as typeof import('../../shared/lib/head-manager-context.shared-runtime')\n\n  // On each render, create a new `ServerInsertedHTML` context to capture\n  // injected nodes from user code (`useServerInsertedHTML`).\n  const { ServerInsertedHTMLProvider, renderServerInsertedHTML } =\n    createServerInsertedHTML()\n\n  getTracer().getRootSpanAttributes()?.set('next.route', pagePath)\n\n  const renderToStream = getTracer().wrap(\n    AppRenderSpan.getBodyResult,\n    {\n      spanName: `render route (app) ${pagePath}`,\n      attributes: {\n        'next.route': pagePath,\n      },\n    },\n    async ({\n      asNotFound,\n      tree,\n      formState,\n    }: RenderToStreamOptions): Promise<RenderToStreamResult> => {\n      const tracingMetadata = getTracedMetadata(\n        getTracer().getTracePropagationData(),\n        renderOpts.experimental.clientTraceMetadata\n      )\n\n      const polyfills: JSX.IntrinsicElements['script'][] =\n        buildManifest.polyfillFiles\n          .filter(\n            (polyfill) =>\n              polyfill.endsWith('.js') && !polyfill.endsWith('.module.js')\n          )\n          .map((polyfill) => ({\n            src: `${assetPrefix}/_next/${polyfill}${getAssetQueryString(\n              ctx,\n              false\n            )}`,\n            integrity: subresourceIntegrityManifest?.[polyfill],\n            crossOrigin: renderOpts.crossOrigin,\n            noModule: true,\n            nonce,\n          }))\n\n      const [preinitScripts, bootstrapScript] = getRequiredScripts(\n        buildManifest,\n        assetPrefix,\n        renderOpts.crossOrigin,\n        subresourceIntegrityManifest,\n        getAssetQueryString(ctx, true),\n        nonce\n      )\n\n      // We kick off the Flight Request (render) here. It is ok to initiate the render in an arbitrary\n      // place however it is critical that we only construct the Flight Response inside the SSR\n      // render so that directives like preloads are correctly piped through\n      const serverStream = ComponentMod.renderToReadableStream(\n        <ReactServerApp tree={tree} ctx={ctx} asNotFound={asNotFound} />,\n        clientReferenceManifest.clientModules,\n        {\n          onError: serverComponentsErrorHandler,\n          nonce,\n        }\n      )\n\n      // We are going to consume this render both for SSR and for inlining the flight data\n      let [renderStream, dataStream] = serverStream.tee()\n\n      const children = (\n        <HeadManagerContext.Provider\n          value={{\n            appDir: true,\n            nonce,\n          }}\n        >\n          <ServerInsertedHTMLProvider>\n            <ReactServerEntrypoint\n              reactServerStream={renderStream}\n              preinitScripts={preinitScripts}\n              clientReferenceManifest={clientReferenceManifest}\n              nonce={nonce}\n            />\n          </ServerInsertedHTMLProvider>\n        </HeadManagerContext.Provider>\n      )\n\n      const isResume = !!renderOpts.postponed\n\n      const onHeaders =\n        // During prerenders, we want to capture the headers created so we can\n        // persist them to the metadata.\n        staticGenerationStore.prerenderState ||\n        // During static generation and during resumes we don't\n        // ask React to emit headers. For Resume this is just not supported\n        // For static generation we know there will be an entire HTML document\n        // output and so moving from tag to header for preloading can only\n        // server to alter preloading priorities in unwanted ways\n        (!isStaticGeneration && !isResume)\n          ? (headers: Headers) => {\n              headers.forEach((value, key) => {\n                setHeader(key, value)\n              })\n            }\n          : undefined\n\n      const getServerInsertedHTML = makeGetServerInsertedHTML({\n        polyfills,\n        renderServerInsertedHTML,\n        serverCapturedErrors: allCapturedErrors,\n        basePath: renderOpts.basePath,\n        tracingMetadata: tracingMetadata,\n      })\n\n      const renderer = createStaticRenderer({\n        isRoutePPREnabled,\n        isStaticGeneration,\n        // If provided, the postpone state should be parsed as JSON so it can be\n        // provided to React.\n        postponed:\n          typeof renderOpts.postponed === 'string'\n            ? JSON.parse(renderOpts.postponed)\n            : null,\n        streamOptions: {\n          onError: htmlRendererErrorHandler,\n          onHeaders,\n          maxHeadersLength: 600,\n          nonce,\n          bootstrapScripts: [bootstrapScript],\n          formState,\n        },\n      })\n\n      try {\n        let { stream, postponed, resumed } = await renderer.render(children)\n\n        const prerenderState = staticGenerationStore.prerenderState\n        if (prerenderState) {\n          /**\n           * When prerendering there are three outcomes to consider\n           *\n           *   Dynamic HTML:      The prerender has dynamic holes (caused by using Next.js Dynamic Rendering APIs)\n           *                      We will need to resume this result when requests are handled and we don't include\n           *                      any server inserted HTML or inlined flight data in the static HTML\n           *\n           *   Dynamic Data:      The prerender has no dynamic holes but dynamic APIs were used. We will not\n           *                      resume this render when requests are handled but we will generate new inlined\n           *                      flight data since it is dynamic and differences may end up reconciling on the client\n           *\n           *   Static:            The prerender has no dynamic holes and no dynamic APIs were used. We statically encode\n           *                      all server inserted HTML and flight data\n           */\n\n          // First we check if we have any dynamic holes in our HTML prerender\n          if (usedDynamicAPIs(prerenderState)) {\n            if (postponed != null) {\n              // This is the Dynamic HTML case.\n              metadata.postponed = JSON.stringify(\n                getDynamicHTMLPostponedState(postponed)\n              )\n            } else {\n              // This is the Dynamic Data case\n              metadata.postponed = JSON.stringify(\n                getDynamicDataPostponedState()\n              )\n            }\n            // Regardless of whether this is the Dynamic HTML or Dynamic Data case we need to ensure we include\n            // server inserted html in the static response because the html that is part of the prerender may depend on it\n            // It is possible in the set of stream transforms for Dynamic HTML vs Dynamic Data may differ but currently both states\n            // require the same set so we unify the code path here\n            return {\n              stream: await continueDynamicPrerender(stream, {\n                getServerInsertedHTML,\n              }),\n            }\n          } else {\n            // We may still be rendering the RSC stream even though the HTML is finished.\n            // We wait for the RSC stream to complete and check again if dynamic was used\n            const [original, flightSpy] = dataStream.tee()\n            dataStream = original\n\n            await flightRenderComplete(flightSpy)\n\n            if (usedDynamicAPIs(prerenderState)) {\n              // This is the same logic above just repeated after ensuring the RSC stream itself has completed\n              if (postponed != null) {\n                // This is the Dynamic HTML case.\n                metadata.postponed = JSON.stringify(\n                  getDynamicHTMLPostponedState(postponed)\n                )\n              } else {\n                // This is the Dynamic Data case\n                metadata.postponed = JSON.stringify(\n                  getDynamicDataPostponedState()\n                )\n              }\n              // Regardless of whether this is the Dynamic HTML or Dynamic Data case we need to ensure we include\n              // server inserted html in the static response because the html that is part of the prerender may depend on it\n              // It is possible in the set of stream transforms for Dynamic HTML vs Dynamic Data may differ but currently both states\n              // require the same set so we unify the code path here\n              return {\n                stream: await continueDynamicPrerender(stream, {\n                  getServerInsertedHTML,\n                }),\n              }\n            } else {\n              // This is the Static case\n              // We still have not used any dynamic APIs. At this point we can produce an entirely static prerender response\n              let renderedHTMLStream = stream\n\n              if (staticGenerationStore.forceDynamic) {\n                throw new StaticGenBailoutError(\n                  'Invariant: a Page with `dynamic = \"force-dynamic\"` did not trigger the dynamic pathway. This is a bug in Next.js'\n                )\n              }\n\n              if (postponed != null) {\n                // We postponed but nothing dynamic was used. We resume the render now and immediately abort it\n                // so we can set all the postponed boundaries to client render mode before we store the HTML response\n                const resumeRenderer = createStaticRenderer({\n                  isRoutePPREnabled,\n                  isStaticGeneration: false,\n                  postponed: getDynamicHTMLPostponedState(postponed),\n                  streamOptions: {\n                    signal: createPostponedAbortSignal(\n                      'static prerender resume'\n                    ),\n                    onError: htmlRendererErrorHandler,\n                    nonce,\n                  },\n                })\n\n                // We don't actually want to render anything so we just pass a stream\n                // that never resolves. The resume call is going to abort immediately anyway\n                const foreverStream = new ReadableStream<Uint8Array>()\n\n                const resumeChildren = (\n                  <HeadManagerContext.Provider\n                    value={{\n                      appDir: true,\n                      nonce,\n                    }}\n                  >\n                    <ServerInsertedHTMLProvider>\n                      <ReactServerEntrypoint\n                        reactServerStream={foreverStream}\n                        preinitScripts={() => {}}\n                        clientReferenceManifest={clientReferenceManifest}\n                        nonce={nonce}\n                      />\n                    </ServerInsertedHTMLProvider>\n                  </HeadManagerContext.Provider>\n                )\n\n                const { stream: resumeStream } =\n                  await resumeRenderer.render(resumeChildren)\n                // First we write everything from the prerender, then we write everything from the aborted resume render\n                renderedHTMLStream = chainStreams(stream, resumeStream)\n              }\n\n              return {\n                stream: await continueStaticPrerender(renderedHTMLStream, {\n                  inlinedDataStream: createInlinedDataReadableStream(\n                    dataStream,\n                    nonce,\n                    formState\n                  ),\n                  getServerInsertedHTML,\n                }),\n              }\n            }\n          }\n        } else if (renderOpts.postponed) {\n          // This is a continuation of either an Incomplete or Dynamic Data Prerender.\n          const inlinedDataStream = createInlinedDataReadableStream(\n            dataStream,\n            nonce,\n            formState\n          )\n          if (resumed) {\n            // We have new HTML to stream and we also need to include server inserted HTML\n            return {\n              stream: await continueDynamicHTMLResume(stream, {\n                inlinedDataStream,\n                getServerInsertedHTML,\n              }),\n            }\n          } else {\n            // We are continuing a Dynamic Data Prerender and simply need to append new inlined flight data\n            return {\n              stream: await continueDynamicDataResume(stream, {\n                inlinedDataStream,\n              }),\n            }\n          }\n        } else {\n          // This may be a static render or a dynamic render\n          // @TODO factor this further to make the render types more clearly defined and remove\n          // the deluge of optional params that passed to configure the various behaviors\n          return {\n            stream: await continueFizzStream(stream, {\n              inlinedDataStream: createInlinedDataReadableStream(\n                dataStream,\n                nonce,\n                formState\n              ),\n              isStaticGeneration: isStaticGeneration || generateStaticHTML,\n              getServerInsertedHTML,\n              serverInsertedHTMLToHead: true,\n              validateRootLayout,\n            }),\n          }\n        }\n      } catch (err) {\n        if (\n          isStaticGenBailoutError(err) ||\n          (typeof err === 'object' &&\n            err !== null &&\n            'message' in err &&\n            typeof err.message === 'string' &&\n            err.message.includes(\n              'https://nextjs.org/docs/advanced-features/static-html-export'\n            ))\n        ) {\n          // Ensure that \"next dev\" prints the red error overlay\n          throw err\n        }\n\n        // If this is a static generation error, we need to throw it so that it\n        // can be handled by the caller if we're in static generation mode.\n        if (isStaticGeneration && isDynamicServerError(err)) {\n          throw err\n        }\n\n        // If a bailout made it to this point, it means it wasn't wrapped inside\n        // a suspense boundary.\n        const shouldBailoutToCSR = isBailoutToCSRError(err)\n        if (shouldBailoutToCSR) {\n          const stack = getStackWithoutErrorMessage(err)\n          error(\n            `${err.reason} should be wrapped in a suspense boundary at page \"${pagePath}\". Read more: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout\\n${stack}`\n          )\n\n          throw err\n        }\n\n        if (isNotFoundError(err)) {\n          res.statusCode = 404\n        }\n        let hasRedirectError = false\n        if (isRedirectError(err)) {\n          hasRedirectError = true\n          res.statusCode = getRedirectStatusCodeFromError(err)\n          if (err.mutableCookies) {\n            const headers = new Headers()\n\n            // If there were mutable cookies set, we need to set them on the\n            // response.\n            if (appendMutableCookies(headers, err.mutableCookies)) {\n              setHeader('set-cookie', Array.from(headers.values()))\n            }\n          }\n          const redirectUrl = addPathPrefix(\n            getURLFromRedirectError(err),\n            renderOpts.basePath\n          )\n          setHeader('Location', redirectUrl)\n        }\n\n        const is404 = res.statusCode === 404\n        if (!is404 && !hasRedirectError && !shouldBailoutToCSR) {\n          res.statusCode = 500\n        }\n\n        const errorType = is404\n          ? 'not-found'\n          : hasRedirectError\n            ? 'redirect'\n            : undefined\n\n        const [errorPreinitScripts, errorBootstrapScript] = getRequiredScripts(\n          buildManifest,\n          assetPrefix,\n          renderOpts.crossOrigin,\n          subresourceIntegrityManifest,\n          getAssetQueryString(ctx, false),\n          nonce\n        )\n\n        const errorServerStream = ComponentMod.renderToReadableStream(\n          <ReactServerError tree={tree} ctx={ctx} errorType={errorType} />,\n          clientReferenceManifest.clientModules,\n          {\n            onError: serverComponentsErrorHandler,\n            nonce,\n          }\n        )\n\n        try {\n          const fizzStream = await renderToInitialFizzStream({\n            ReactDOMServer: require('react-dom/server.edge'),\n            element: (\n              <ReactServerEntrypoint\n                reactServerStream={errorServerStream}\n                preinitScripts={errorPreinitScripts}\n                clientReferenceManifest={clientReferenceManifest}\n                nonce={nonce}\n              />\n            ),\n            streamOptions: {\n              nonce,\n              // Include hydration scripts in the HTML\n              bootstrapScripts: [errorBootstrapScript],\n              formState,\n            },\n          })\n\n          return {\n            // Returning the error that was thrown so it can be used to handle\n            // the response in the caller.\n            err,\n            stream: await continueFizzStream(fizzStream, {\n              inlinedDataStream: createInlinedDataReadableStream(\n                // This is intentionally using the readable datastream from the\n                // main render rather than the flight data from the error page\n                // render\n                dataStream,\n                nonce,\n                formState\n              ),\n              isStaticGeneration,\n              getServerInsertedHTML: makeGetServerInsertedHTML({\n                polyfills,\n                renderServerInsertedHTML,\n                serverCapturedErrors: [],\n                basePath: renderOpts.basePath,\n                tracingMetadata: tracingMetadata,\n              }),\n              serverInsertedHTMLToHead: true,\n              validateRootLayout,\n            }),\n          }\n        } catch (finalErr: any) {\n          if (\n            process.env.NODE_ENV === 'development' &&\n            isNotFoundError(finalErr)\n          ) {\n            const bailOnNotFound: typeof import('../../client/components/dev-root-not-found-boundary').bailOnNotFound =\n              require('../../client/components/dev-root-not-found-boundary').bailOnNotFound\n            bailOnNotFound()\n          }\n          throw finalErr\n        }\n      }\n    }\n  )\n\n  // For action requests, we handle them differently with a special render result.\n  const actionRequestResult = await handleAction({\n    req,\n    res,\n    ComponentMod,\n    serverModuleMap,\n    generateFlight,\n    staticGenerationStore,\n    requestStore,\n    serverActions,\n    ctx,\n  })\n\n  let formState: null | any = null\n  if (actionRequestResult) {\n    if (actionRequestResult.type === 'not-found') {\n      const notFoundLoaderTree = createNotFoundLoaderTree(loaderTree)\n      const response = await renderToStream({\n        asNotFound: true,\n        tree: notFoundLoaderTree,\n        formState,\n      })\n\n      return new RenderResult(response.stream, { metadata })\n    } else if (actionRequestResult.type === 'done') {\n      if (actionRequestResult.result) {\n        actionRequestResult.result.assignMetadata(metadata)\n        return actionRequestResult.result\n      } else if (actionRequestResult.formState) {\n        formState = actionRequestResult.formState\n      }\n    }\n  }\n\n  const options: RenderResultOptions = {\n    metadata,\n  }\n\n  let response = await renderToStream({\n    asNotFound: isNotFoundPath,\n    tree: loaderTree,\n    formState,\n  })\n\n  // If we have pending revalidates, wait until they are all resolved.\n  if (staticGenerationStore.pendingRevalidates) {\n    options.waitUntil = Promise.all([\n      staticGenerationStore.incrementalCache?.revalidateTag(\n        staticGenerationStore.revalidatedTags || []\n      ),\n      ...Object.values(staticGenerationStore.pendingRevalidates || {}),\n    ])\n  }\n\n  addImplicitTags(staticGenerationStore)\n\n  if (staticGenerationStore.tags) {\n    metadata.fetchTags = staticGenerationStore.tags.join(',')\n  }\n\n  // Create the new render result for the response.\n  const result = new RenderResult(response.stream, options)\n\n  // If we aren't performing static generation, we can return the result now.\n  if (!isStaticGeneration) {\n    return result\n  }\n\n  // If this is static generation, we should read this in now rather than\n  // sending it back to be sent to the client.\n  response.stream = await result.toUnchunkedString(true)\n\n  const buildFailingError =\n    digestErrorsMap.size > 0 ? digestErrorsMap.values().next().value : null\n\n  // If we're debugging partial prerendering, print all the dynamic API accesses\n  // that occurred during the render.\n  if (\n    staticGenerationStore.prerenderState &&\n    usedDynamicAPIs(staticGenerationStore.prerenderState) &&\n    staticGenerationStore.prerenderState?.isDebugSkeleton\n  ) {\n    warn('The following dynamic usage was detected:')\n    for (const access of formatDynamicAPIAccesses(\n      staticGenerationStore.prerenderState\n    )) {\n      warn(access)\n    }\n  }\n\n  if (!flightDataResolver) {\n    throw new Error(\n      'Invariant: Flight data resolver is missing when generating static HTML'\n    )\n  }\n\n  // If we encountered any unexpected errors during build we fail the\n  // prerendering phase and the build.\n  if (buildFailingError) {\n    throw buildFailingError\n  }\n\n  // Wait for and collect the flight payload data if we don't have it\n  // already\n  const flightData = await flightDataResolver()\n  if (flightData) {\n    metadata.flightData = flightData\n  }\n\n  // If force static is specifically set to false, we should not revalidate\n  // the page.\n  if (staticGenerationStore.forceStatic === false) {\n    staticGenerationStore.revalidate = 0\n  }\n\n  // Copy the revalidation value onto the render result metadata.\n  metadata.revalidate =\n    staticGenerationStore.revalidate ?? ctx.defaultRevalidate\n\n  // provide bailout info for debugging\n  if (metadata.revalidate === 0) {\n    metadata.staticBailoutInfo = {\n      description: staticGenerationStore.dynamicUsageDescription,\n      stack: staticGenerationStore.dynamicUsageStack,\n    }\n  }\n\n  return new RenderResult(response.stream, options)\n}\n\nexport type AppPageRender = (\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  pagePath: string,\n  query: NextParsedUrlQuery,\n  renderOpts: RenderOpts\n) => Promise<RenderResult<AppPageRenderResultMetadata>>\n\nexport const renderToHTMLOrFlight: AppPageRender = (\n  req,\n  res,\n  pagePath,\n  query,\n  renderOpts\n) => {\n  // TODO: this includes query string, should it?\n  const pathname = validateURL(req.url)\n\n  return RequestAsyncStorageWrapper.wrap(\n    renderOpts.ComponentMod.requestAsyncStorage,\n    { req, res, renderOpts },\n    (requestStore) =>\n      StaticGenerationAsyncStorageWrapper.wrap(\n        renderOpts.ComponentMod.staticGenerationAsyncStorage,\n        {\n          urlPathname: pathname,\n          renderOpts,\n          requestEndedState: { ended: false },\n        },\n        (staticGenerationStore) =>\n          renderToHTMLOrFlightImpl(\n            req,\n            res,\n            pagePath,\n            query,\n            renderOpts,\n            {\n              requestStore,\n              staticGenerationStore,\n              componentMod: renderOpts.ComponentMod,\n              renderOpts,\n            },\n            staticGenerationStore.requestEndedState || {}\n          )\n      )\n  )\n}\n"],"names":["renderToHTMLOrFlight","createNotFoundLoaderTree","loaderTree","findDynamicParamFromRouterState","flightRouterState","segment","treeSegment","canSegmentBeOverridden","Array","isArray","param","value","type","parallelRouterState","Object","values","maybeDynamicParam","makeGetDynamicParamFromSegment","params","pagePath","getDynamicParamFromSegment","segmentParam","getSegmentParam","key","undefined","map","i","encodeURIComponent","isCatchall","isOptionalCatchall","dynamicParamType","dynamicParamTypes","split","slice","flatMap","pathSegment","parseParameter","join","getShortDynamicParamType","generateFlight","ctx","options","flightData","componentMod","tree","renderToReadableStream","createDynamicallyTrackedSearchParams","appUsingSizeAdjustment","staticGenerationStore","urlPathname","query","requestId","skipFlight","MetadataTree","MetadataOutlet","createMetadataComponents","pathname","trailingSlash","renderOpts","walkTreeWithFlightRouterState","createSegmentPath","child","loaderTreeToFilter","parentParams","isFirst","rscPayloadHead","injectedCSS","Set","injectedJS","injectedFontPreloadTags","rootLayoutIncluded","asNotFound","isNotFoundPath","metadataOutlet","path","buildIdFlightDataPair","buildId","flightReadableStream","actionResult","clientReferenceManifest","clientModules","onError","flightDataRendererErrorHandler","nonce","FlightRenderResult","createFlightDataResolver","promise","then","result","toUnchunkedString","catch","err","ReactServerApp","missingSlots","AppRouter","GlobalError","initialTree","createFlightRouterStateFromLoaderTree","errorType","seedData","styles","createComponentTree","firstItem","varyHeader","res","getHeader","couldBeIntercepted","includes","NEXT_URL","assetPrefix","initialCanonicalUrl","initialSeedData","initialHead","statusCode","meta","name","content","globalErrorComponent","ReactServerError","head","process","env","NODE_ENV","html","id","body","ReactServerEntrypoint","reactServerStream","preinitScripts","response","useFlightStream","React","use","renderToHTMLOrFlightImpl","req","baseCtx","requestEndedState","getTracer","requestTimestamp","Date","now","buildManifest","subresourceIntegrityManifest","serverActionsManifest","ComponentMod","dev","nextFontManifest","supportsDynamicHTML","serverActions","appDirDevErrorLogger","enableTainting","__next_app__","instrumented","wrapClientComponentLoader","globalThis","__next_require__","require","__next_chunk_load__","loadChunk","NEXT_RUNTIME","isNodeNextRequest","originalRequest","on","ended","metrics","getClientComponentLoaderMetrics","reset","startSpan","NextNodeServerSpan","clientComponentLoading","startTime","clientComponentLoadStart","attributes","clientComponentLoadCount","end","clientComponentLoadTimes","metadata","appUsingSizeAdjust","serverModuleMap","createServerModuleMap","pageName","page","setReferenceManifestsSingleton","digestErrorsMap","Map","allCapturedErrors","isNextExport","nextExport","requestStore","isStaticGeneration","setHeader","headers","bind","isRoutePPREnabled","experimental","silenceStaticGenerationErrors","serverComponentsErrorHandler","createErrorHandler","source","ErrorHandlerSource","serverComponents","errorLogger","silenceLogger","htmlRendererErrorHandler","patchFetch","after","patchCacheScopeSupportIntoReact","generateStaticHTML","taintObjectReference","fetchMetrics","stripInternalQueries","isRSCRequest","RSC_HEADER","toLowerCase","isPrefetchRSCRequest","NEXT_ROUTER_PREFETCH_HEADER","shouldProvideFlightRouterState","isInterceptionRouteAppPath","parsedFlightRouterState","parseAndValidateFlightRouterState","NEXT_ROUTER_STATE_TREE","crypto","randomUUID","nanoid","csp","getScriptNonceFromHeader","isPrefetch","defaultRevalidate","flightDataResolver","validateRootLayout","HeadManagerContext","ServerInsertedHTMLProvider","renderServerInsertedHTML","createServerInsertedHTML","getRootSpanAttributes","set","renderToStream","wrap","AppRenderSpan","getBodyResult","spanName","formState","tracingMetadata","getTracedMetadata","getTracePropagationData","clientTraceMetadata","polyfills","polyfillFiles","filter","polyfill","endsWith","src","getAssetQueryString","integrity","crossOrigin","noModule","bootstrapScript","getRequiredScripts","serverStream","renderStream","dataStream","tee","children","Provider","appDir","isResume","postponed","onHeaders","prerenderState","forEach","getServerInsertedHTML","makeGetServerInsertedHTML","serverCapturedErrors","basePath","renderer","createStaticRenderer","JSON","parse","streamOptions","maxHeadersLength","bootstrapScripts","stream","resumed","render","usedDynamicAPIs","stringify","getDynamicHTMLPostponedState","getDynamicDataPostponedState","continueDynamicPrerender","original","flightSpy","flightRenderComplete","renderedHTMLStream","forceDynamic","StaticGenBailoutError","resumeRenderer","signal","createPostponedAbortSignal","foreverStream","ReadableStream","resumeChildren","resumeStream","chainStreams","continueStaticPrerender","inlinedDataStream","createInlinedDataReadableStream","continueDynamicHTMLResume","continueDynamicDataResume","continueFizzStream","serverInsertedHTMLToHead","isStaticGenBailoutError","message","isDynamicServerError","shouldBailoutToCSR","isBailoutToCSRError","stack","getStackWithoutErrorMessage","error","reason","isNotFoundError","hasRedirectError","isRedirectError","getRedirectStatusCodeFromError","mutableCookies","Headers","appendMutableCookies","from","redirectUrl","addPathPrefix","getURLFromRedirectError","is404","errorPreinitScripts","errorBootstrapScript","errorServerStream","fizzStream","renderToInitialFizzStream","ReactDOMServer","element","finalErr","bailOnNotFound","actionRequestResult","handleAction","notFoundLoaderTree","RenderResult","assignMetadata","pendingRevalidates","waitUntil","Promise","all","incrementalCache","revalidateTag","revalidatedTags","addImplicitTags","tags","fetchTags","buildFailingError","size","next","isDebugSkeleton","warn","access","formatDynamicAPIAccesses","Error","forceStatic","revalidate","staticBailoutInfo","description","dynamicUsageDescription","dynamicUsageStack","validateURL","url","RequestAsyncStorageWrapper","requestAsyncStorage","StaticGenerationAsyncStorageWrapper","staticGenerationAsyncStorage"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":";;;;+BAq9CaA;;;eAAAA;;;;8DAj8CK;qEAMX;sCASA;+BACgC;+BACF;kCAM9B;0BACkC;4CACE;qDACS;0BACpB;0BAKzB;4BACyB;2BACkB;wBACxB;oCACS;oCAK5B;0CAIA;iCACyB;0CACS;mDACS;6BACtB;uDAC0B;+BACzB;8BACO;qBACR;gCACS;oCACI;iCACN;+BACL;2CAIvB;+CACuC;qCACV;qCACA;iCACW;gCAKxC;oCAC8B;mCAK9B;yCAIA;oCACoC;mCACC;kCAKrC;+CAIA;6BAC+B;yBACJ;4BACH;;;;;;AAwC/B,SAASC,yBAAyBC,UAAsB;IACtD,mEAAmE;IACnE,OAAO;QAAC;QAAI,CAAC;QAAGA,UAAU,CAAC,EAAE;KAAC;AAChC;AAEA;;;;;;CAMC,GACD,SAASC,gCACPC,iBAAgD,EAChDC,OAAe;IAOf,IAAI,CAACD,mBAAmB;QACtB,OAAO;IACT;IAEA,MAAME,cAAcF,iBAAiB,CAAC,EAAE;IAExC,IAAIG,IAAAA,qCAAsB,EAACF,SAASC,cAAc;QAChD,IAAI,CAACE,MAAMC,OAAO,CAACH,gBAAgBE,MAAMC,OAAO,CAACJ,UAAU;YACzD,OAAO;QACT;QAEA,OAAO;YACLK,OAAOJ,WAAW,CAAC,EAAE;YACrBK,OAAOL,WAAW,CAAC,EAAE;YACrBA,aAAaA;YACbM,MAAMN,WAAW,CAAC,EAAE;QACtB;IACF;IAEA,KAAK,MAAMO,uBAAuBC,OAAOC,MAAM,CAACX,iBAAiB,CAAC,EAAE,EAAG;QACrE,MAAMY,oBAAoBb,gCACxBU,qBACAR;QAEF,IAAIW,mBAAmB;YACrB,OAAOA;QACT;IACF;IAEA,OAAO;AACT;AAIA;;CAEC,GACD,SAASC,+BACPC,MAA8B,EAC9BC,QAAgB,EAChBf,iBAAgD;IAEhD,OAAO,SAASgB,2BACd,gCAAgC;IAChCf,OAAe;QAEf,MAAMgB,eAAeC,IAAAA,gCAAe,EAACjB;QACrC,IAAI,CAACgB,cAAc;YACjB,OAAO;QACT;QAEA,MAAME,MAAMF,aAAaX,KAAK;QAE9B,IAAIC,QAAQO,MAAM,CAACK,IAAI;QAEvB,wEAAwE;QACxE,IAAIZ,UAAU,wBAAwB;YACpCA,QAAQa;QACV;QAEA,IAAIhB,MAAMC,OAAO,CAACE,QAAQ;YACxBA,QAAQA,MAAMc,GAAG,CAAC,CAACC,IAAMC,mBAAmBD;QAC9C,OAAO,IAAI,OAAOf,UAAU,UAAU;YACpCA,QAAQgB,mBAAmBhB;QAC7B;QAEA,IAAI,CAACA,OAAO;YACV,MAAMiB,aAAaP,aAAaT,IAAI,KAAK;YACzC,MAAMiB,qBAAqBR,aAAaT,IAAI,KAAK;YAEjD,IAAIgB,cAAcC,oBAAoB;gBACpC,MAAMC,mBAAmBC,2CAAiB,CAACV,aAAaT,IAAI,CAAC;gBAC7D,oEAAoE;gBACpE,6DAA6D;gBAC7D,IAAIiB,oBAAoB;oBACtB,OAAO;wBACLnB,OAAOa;wBACPZ,OAAO;wBACPC,MAAMkB;wBACNxB,aAAa;4BAACiB;4BAAK;4BAAIO;yBAAiB;oBAC1C;gBACF;gBAEA,+EAA+E;gBAC/E,wFAAwF;gBACxFnB,QAAQQ,SACLa,KAAK,CAAC,IACP,gCAAgC;iBAC/BC,KAAK,CAAC,EACP,oDAAoD;iBACnDC,OAAO,CAAC,CAACC;oBACR,MAAMzB,QAAQ0B,IAAAA,0BAAc,EAACD;oBAC7B,yDAAyD;oBACzD,wDAAwD;oBACxD,OAAOjB,MAAM,CAACR,MAAMa,GAAG,CAAC,IAAIb,MAAMa,GAAG;gBACvC;gBAEF,OAAO;oBACLb,OAAOa;oBACPZ;oBACAC,MAAMkB;oBACN,wCAAwC;oBACxCxB,aAAa;wBAACiB;wBAAKZ,MAAM0B,IAAI,CAAC;wBAAMP;qBAAiB;gBACvD;YACF;YAEA,OAAO3B,gCAAgCC,mBAAmBC;QAC5D;QAEA,MAAMO,OAAO0B,IAAAA,kDAAwB,EAACjB,aAAaT,IAAI;QAEvD,OAAO;YACLF,OAAOa;YACP,yCAAyC;YACzCZ,OAAOA;YACP,iDAAiD;YACjDL,aAAa;gBAACiB;gBAAKf,MAAMC,OAAO,CAACE,SAASA,MAAM0B,IAAI,CAAC,OAAO1B;gBAAOC;aAAK;YACxEA,MAAMA;QACR;IACF;AACF;AAEA,+IAA+I;AAC/I,eAAe2B,eACbC,GAAqB,EACrBC,OAIC;IAED,yDAAyD;IACzD,0GAA0G;IAC1G,IAAIC,aAAgC;IAEpC,MAAM,EACJC,cAAc,EACZC,MAAM1C,UAAU,EAChB2C,sBAAsB,EACtBC,oCAAoC,EACrC,EACD1B,0BAA0B,EAC1B2B,sBAAsB,EACtBC,uBAAuB,EAAEC,WAAW,EAAE,EACtCC,KAAK,EACLC,SAAS,EACT/C,iBAAiB,EAClB,GAAGoC;IAEJ,IAAI,EAACC,2BAAAA,QAASW,UAAU,GAAE;QACxB,MAAM,CAACC,cAAcC,eAAe,GAAGC,IAAAA,kCAAwB,EAAC;YAC9DX,MAAM1C;YACNsD,UAAUP;YACVQ,eAAejB,IAAIkB,UAAU,CAACD,aAAa;YAC3CP;YACA9B;YACA2B;YACAD;QACF;QACAJ,aAAa,AACX,CAAA,MAAMiB,IAAAA,4DAA6B,EAAC;YAClCnB;YACAoB,mBAAmB,CAACC,QAAUA;YAC9BC,oBAAoB5D;YACpB6D,cAAc,CAAC;YACf3D;YACA4D,SAAS;YACT,+CAA+C;YAC/CC,gBACE,yEAAyE;0BACzE,qBAACZ,kBAAkBF;YAErBe,aAAa,IAAIC;YACjBC,YAAY,IAAID;YAChBE,yBAAyB,IAAIF;YAC7BG,oBAAoB;YACpBC,YAAY/B,IAAIgC,cAAc,KAAI/B,2BAAAA,QAAS8B,UAAU;YACrDE,8BAAgB,qBAACnB;QACnB,EAAC,EACD7B,GAAG,CAAC,CAACiD,OAASA,KAAKzC,KAAK,CAAC,IAAI,+BAA+B;;IAChE;IAEA,MAAM0C,wBAAwB;QAACnC,IAAIkB,UAAU,CAACkB,OAAO;QAAElC;KAAW;IAElE,0FAA0F;IAC1F,mCAAmC;IACnC,MAAMmC,uBAAuBhC,uBAC3BJ,UACI;QAACA,QAAQqC,YAAY;QAAEH;KAAsB,GAC7CA,uBACJnC,IAAIuC,uBAAuB,CAACC,aAAa,EACzC;QACEC,SAASzC,IAAI0C,8BAA8B;QAC3CC,OAAO3C,IAAI2C,KAAK;IAClB;IAGF,OAAO,IAAIC,sCAAkB,CAACP;AAChC;AAmBA;;;CAGC,GACD,SAASQ,yBAAyB7C,GAAqB;IACrD,4EAA4E;IAC5E,MAAM8C,UAAU/C,eAAeC,KAC5B+C,IAAI,CAAC,OAAOC,SAAY,CAAA;YACvB9C,YAAY,MAAM8C,OAAOC,iBAAiB,CAAC;QAC7C,CAAA,EACA,6CAA6C;KAC5CC,KAAK,CAAC,CAACC,MAAS,CAAA;YAAEA;QAAI,CAAA;IAEzB,OAAO;QACL,uDAAuD;QACvD,MAAMH,SAAS,MAAMF;QAErB,0EAA0E;QAC1E,QAAQ;QACR,IAAI,SAASE,QAAQ;YACnB,MAAMA,OAAOG,GAAG;QAClB;QAEA,qCAAqC;QACrC,OAAOH,OAAO9C,UAAU;IAC1B;AACF;AAOA,0DAA0D;AAC1D,eAAekD,eAAe,EAAEhD,IAAI,EAAEJ,GAAG,EAAE+B,UAAU,EAAuB;IAC1E,gDAAgD;IAChD,MAAML,cAAc,IAAIC;IACxB,MAAMC,aAAa,IAAID;IACvB,MAAME,0BAA0B,IAAIF;IACpC,MAAM0B,eAAe,IAAI1B;IACzB,MAAM,EACJ/C,0BAA0B,EAC1B8B,KAAK,EACLH,sBAAsB,EACtBJ,cAAc,EACZmD,SAAS,EACTC,WAAW,EACXjD,oCAAoC,EACrC,EACDE,uBAAuB,EAAEC,WAAW,EAAE,EACvC,GAAGT;IACJ,MAAMwD,cAAcC,IAAAA,4EAAqC,EACvDrD,MACAxB,4BACA8B;IAGF,MAAM,CAACG,cAAcC,eAAe,GAAGC,IAAAA,kCAAwB,EAAC;QAC9DX;QACAsD,WAAW3B,aAAa,cAAc/C;QACtCgC,UAAUP;QACVQ,eAAejB,IAAIkB,UAAU,CAACD,aAAa;QAC3CP;QACA9B,4BAA4BA;QAC5B2B,wBAAwBA;QACxBD;IACF;IAEA,MAAM,EAAEqD,QAAQ,EAAEC,MAAM,EAAE,GAAG,MAAMC,IAAAA,wCAAmB,EAAC;QACrD7D;QACAoB,mBAAmB,CAACC,QAAUA;QAC9B3D,YAAY0C;QACZmB,cAAc,CAAC;QACfuC,WAAW;QACXpC;QACAE;QACAC;QACAC,oBAAoB;QACpBC,YAAYA;QACZE,8BAAgB,qBAACnB;QACjBuC;IACF;IAEA,0FAA0F;IAC1F,6FAA6F;IAC7F,2FAA2F;IAC3F,MAAMU,aAAa/D,IAAIgE,GAAG,CAACC,SAAS,CAAC;IACrC,MAAMC,qBACJ,OAAOH,eAAe,YAAYA,WAAWI,QAAQ,CAACC,0BAAQ;IAEhE,qBACE;;YACGR;0BACD,qBAACN;gBACClB,SAASpC,IAAIkB,UAAU,CAACkB,OAAO;gBAC/BiC,aAAarE,IAAIqE,WAAW;gBAC5BC,qBAAqB7D;gBACrB,iCAAiC;gBACjC+C,aAAaA;gBACb,iEAAiE;gBACjEe,iBAAiBZ;gBACjBO,oBAAoBA;gBACpBM,2BACE;;wBACG,OAAOxE,IAAIgE,GAAG,CAACS,UAAU,KAAK,YAC7BzE,IAAIgE,GAAG,CAACS,UAAU,GAAG,qBACnB,qBAACC;4BAAKC,MAAK;4BAASC,SAAQ;;sCAGhC,qBAAC/D,kBAAkBb,IAAIW,SAAS;;;gBAGpCkE,sBAAsBtB;gBACtB,uEAAuE;gBACvE,0FAA0F;gBAC1FF,cAAcA;;;;AAItB;AAOA,0DAA0D;AAC1D,eAAeyB,iBAAiB,EAC9B1E,IAAI,EACJJ,GAAG,EACH0D,SAAS,EACa;IACtB,MAAM,EACJ9E,0BAA0B,EAC1B8B,KAAK,EACLH,sBAAsB,EACtBJ,cAAc,EACZmD,SAAS,EACTC,WAAW,EACXjD,oCAAoC,EACrC,EACDE,uBAAuB,EAAEC,WAAW,EAAE,EACtCE,SAAS,EACTqD,GAAG,EACJ,GAAGhE;IAEJ,MAAM,CAACa,aAAa,GAAGE,IAAAA,kCAAwB,EAAC;QAC9CX;QACAY,UAAUP;QACVQ,eAAejB,IAAIkB,UAAU,CAACD,aAAa;QAC3CyC;QACAhD;QACA9B;QACA2B;QACAD;IACF;IAEA,MAAMyE,qBACJ;;0BAEE,qBAAClE,kBAAkBF;YAClB,OAAOqD,IAAIS,UAAU,KAAK,YAAYT,IAAIS,UAAU,IAAI,qBACvD,qBAACC;gBAAKC,MAAK;gBAASC,SAAQ;;YAE7BI,QAAQC,GAAG,CAACC,QAAQ,KAAK,+BACxB,qBAACR;gBAAKC,MAAK;gBAAaC,SAAQ;;;;IAKtC,MAAMpB,cAAcC,IAAAA,4EAAqC,EACvDrD,MACAxB,4BACA8B;IAGF,0EAA0E;IAC1E,+CAA+C;IAC/C,MAAM6D,kBAAqC;QACzCf,WAAW,CAAC,EAAE;QACd,CAAC;sBACD,sBAAC2B;YAAKC,IAAG;;8BACP,qBAACL;8BACD,qBAACM;;;QAEH;KACD;IACD,qBACE,qBAAC/B;QACClB,SAASpC,IAAIkB,UAAU,CAACkB,OAAO;QAC/BiC,aAAarE,IAAIqE,WAAW;QAC5BC,qBAAqB7D;QACrB+C,aAAaA;QACbgB,aAAaO;QACbF,sBAAsBtB;QACtBgB,iBAAiBA;QACjBlB,cAAc,IAAI1B;;AAGxB;AAEA,mFAAmF;AACnF,SAAS2D,sBAAyB,EAChCC,iBAAiB,EACjBC,cAAc,EACdjD,uBAAuB,EACvBI,KAAK,EAMN;IACC6C;IACA,MAAMC,WAAWC,IAAAA,kCAAe,EAC9BH,mBACAhD,yBACAI;IAEF,OAAOgD,cAAK,CAACC,GAAG,CAACH;AACnB;AASA,eAAeI,yBACbC,GAAoB,EACpB9B,GAAqB,EACrBrF,QAAgB,EAChB+B,KAAyB,EACzBQ,UAAsB,EACtB6E,OAA6B,EAC7BC,iBAAsC;QAsRtCC,kCAihBEzF;IAryBF,MAAMwB,iBAAiBrD,aAAa;IAEpC,qEAAqE;IACrE,wEAAwE;IACxE,6EAA6E;IAC7E,+EAA+E;IAC/E,MAAMuH,mBAAmBC,KAAKC,GAAG;IAEjC,MAAM,EACJC,aAAa,EACbC,4BAA4B,EAC5BC,qBAAqB,EACrBC,YAAY,EACZC,GAAG,EACHC,gBAAgB,EAChBC,mBAAmB,EACnBC,aAAa,EACbC,oBAAoB,EACpBxC,cAAc,EAAE,EAChByC,cAAc,EACf,GAAG5F;IAEJ,2DAA2D;IAC3D,uEAAuE;IACvE,IAAIsF,aAAaO,YAAY,EAAE;QAC7B,MAAMC,eAAeC,IAAAA,wDAAyB,EAACT;QAC/C,aAAa;QACbU,WAAWC,gBAAgB,GAAGH,aAAaI,OAAO;QAClD,aAAa;QACbF,WAAWG,mBAAmB,GAAGL,aAAaM,SAAS;IACzD;IAEA,IACE,qEAAqE;IACrE,6DAA6D;IAC7DtC,QAAQC,GAAG,CAACsC,YAAY,KAAK,UAC7BC,IAAAA,0BAAiB,EAAC1B,MAClB;QACAA,IAAI2B,eAAe,CAACC,EAAE,CAAC,OAAO;YAC5B1B,kBAAkB2B,KAAK,GAAG;YAE1B,IAAI,iBAAiBT,YAAY;gBAC/B,MAAMU,UAAUC,IAAAA,8DAA+B,EAAC;oBAAEC,OAAO;gBAAK;gBAC9D,IAAIF,SAAS;oBACX3B,IAAAA,iBAAS,IACN8B,SAAS,CAACC,6BAAkB,CAACC,sBAAsB,EAAE;wBACpDC,WAAWN,QAAQO,wBAAwB;wBAC3CC,YAAY;4BACV,iCACER,QAAQS,wBAAwB;wBACpC;oBACF,GACCC,GAAG,CACFV,QAAQO,wBAAwB,GAC9BP,QAAQW,wBAAwB;gBAExC;YACF;QACF;IACF;IAEA,MAAMC,WAAwC,CAAC;IAE/C,MAAMjI,yBAAyB,CAAC,EAACmG,oCAAAA,iBAAkB+B,kBAAkB;IAErE,4BAA4B;IAC5B,MAAMlG,0BAA0BrB,WAAWqB,uBAAuB;IAElE,MAAMmG,kBAAkBC,IAAAA,kCAAqB,EAAC;QAC5CpC;QACAqC,UAAU1H,WAAW2H,IAAI;IAC3B;IAEAC,IAAAA,+CAA8B,EAAC;QAC7BvG;QACAgE;QACAmC;IACF;IAEA,MAAMK,kBAAsC,IAAIC;IAChD,MAAMC,oBAA6B,EAAE;IACrC,MAAMC,eAAe,CAAC,CAAChI,WAAWiI,UAAU;IAC5C,MAAM,EAAE3I,qBAAqB,EAAE4I,YAAY,EAAE,GAAGrD;IAChD,MAAM,EAAEsD,kBAAkB,EAAE,GAAG7I;IAE/B;;;;GAIC,GACD,MAAM8I,YAAYD,qBACd,CAAC1E,MAAcxG;QACb6F,IAAIsF,SAAS,CAAC3E,MAAMxG;QAEpBqK,SAASe,OAAO,KAAK,CAAC;QACtBf,SAASe,OAAO,CAAC5E,KAAK,GAAGX,IAAIC,SAAS,CAACU;QAEvC,OAAOX;IACT,IACAA,IAAIsF,SAAS,CAACE,IAAI,CAACxF;IAEvB,MAAMyF,oBAAoBvI,WAAWwI,YAAY,CAACD,iBAAiB,KAAK;IAExE,4EAA4E;IAC5E,sEAAsE;IACtE,WAAW;IACX,MAAME,gCAAgCF,qBAAqBJ;IAE3D,MAAMO,+BAA+BC,IAAAA,sCAAkB,EAAC;QACtDC,QAAQC,sCAAkB,CAACC,gBAAgB;QAC3CvD;QACAyC;QACAe,aAAapD;QACbkC;QACAmB,eAAeP;IACjB;IACA,MAAMjH,iCAAiCmH,IAAAA,sCAAkB,EAAC;QACxDC,QAAQC,sCAAkB,CAAC7J,UAAU;QACrCuG;QACAyC;QACAe,aAAapD;QACbkC;QACAmB,eAAeP;IACjB;IACA,MAAMQ,2BAA2BN,IAAAA,sCAAkB,EAAC;QAClDC,QAAQC,sCAAkB,CAAC5E,IAAI;QAC/BsB;QACAyC;QACAe,aAAapD;QACbkC;QACAE;QACAiB,eAAeP;IACjB;IAEAnD,aAAa4D,UAAU;IAEvB,IAAIlJ,WAAWwI,YAAY,CAACW,KAAK,EAAE;QACjC7D,aAAa8D,+BAA+B;IAC9C;IAEA;;;;;;;;;;;;GAYC,GACD,MAAMC,qBAAqB5D,wBAAwB;IAEnD,oDAAoD;IACpD,MAAM,EAAEvG,MAAM1C,UAAU,EAAE8M,oBAAoB,EAAE,GAAGhE;IAEnD,IAAIM,gBAAgB;QAClB0D,qBACE,kFACAxF,QAAQC,GAAG;IAEf;IAEAzE,sBAAsBiK,YAAY,GAAG,EAAE;IACvCjC,SAASiC,YAAY,GAAGjK,sBAAsBiK,YAAY;IAE1D,qCAAqC;IACrC/J,QAAQ;QAAE,GAAGA,KAAK;IAAC;IACnBgK,IAAAA,mCAAoB,EAAChK;IAErB,MAAMiK,eAAe7E,IAAIyD,OAAO,CAACqB,4BAAU,CAACC,WAAW,GAAG,KAAK7L;IAE/D,MAAM8L,uBACJH,gBACA7E,IAAIyD,OAAO,CAACwB,6CAA2B,CAACF,WAAW,GAAG,KAAK7L;IAE7D;;;;;;GAMC,GACD,MAAMgM,iCACJL,gBACC,CAAA,CAACG,wBACA,CAACrB,qBACD,qEAAqE;IACrE,0BAA0B;IAC1BwB,IAAAA,8CAA0B,EAACtM,SAAQ;IAEvC,MAAMuM,0BAA0BC,IAAAA,oEAAiC,EAC/DrF,IAAIyD,OAAO,CAAC6B,wCAAsB,CAACP,WAAW,GAAG;IAGnD;;;GAGC,GACD,IAAIlK;IAEJ,IAAIqE,QAAQC,GAAG,CAACsC,YAAY,KAAK,QAAQ;QACvC5G,YAAY0K,OAAOC,UAAU;IAC/B,OAAO;QACL3K,YAAYyG,QAAQ,6BAA6BmE,MAAM;IACzD;IAEA;;GAEC,GACD,MAAM7M,SAASwC,WAAWxC,MAAM,IAAI,CAAC;IAErC,MAAME,6BAA6BH,+BACjCC,QACAC,UACA,mFAAmF;IACnF,8EAA8E;IAC9EuM;IAGF,yDAAyD;IACzD,MAAMM,MACJ1F,IAAIyD,OAAO,CAAC,0BAA0B,IACtCzD,IAAIyD,OAAO,CAAC,sCAAsC;IACpD,IAAI5G;IACJ,IAAI6I,OAAO,OAAOA,QAAQ,UAAU;QAClC7I,QAAQ8I,IAAAA,kDAAwB,EAACD;IACnC;IAEA,MAAMxL,MAAwB;QAC5B,GAAG+F,OAAO;QACVnH;QACA8B;QACAgL,YAAYZ;QACZ5E;QACA3F;QACA3C,mBAAmBoN,iCACfE,0BACAlM;QACJ2B;QACAgL,mBAAmB;QACnBhN;QACA4D;QACA8B;QACA3B;QACAkH;QACA5H;QACAW;QACAqB;IACF;IAEA,IAAI2G,gBAAgB,CAACtB,oBAAoB;QACvC,OAAOtJ,eAAeC;IACxB;IAEA,yEAAyE;IACzE,2EAA2E;IAC3E,2EAA2E;IAC3E,uEAAuE;IACvE,gBAAgB;IAChB,MAAM4L,qBAAqBvC,qBACvBxG,yBAAyB7C,OACzB;IAEJ,MAAM6L,qBAAqBpF;IAE3B,MAAM,EAAEqF,kBAAkB,EAAE,GAC1B1E,QAAQ;IAEV,uEAAuE;IACvE,2DAA2D;IAC3D,MAAM,EAAE2E,0BAA0B,EAAEC,wBAAwB,EAAE,GAC5DC,IAAAA,4CAAwB;KAE1BhG,mCAAAA,IAAAA,iBAAS,IAAGiG,qBAAqB,uBAAjCjG,iCAAqCkG,GAAG,CAAC,cAAcxN;IAEvD,MAAMyN,iBAAiBnG,IAAAA,iBAAS,IAAGoG,IAAI,CACrCC,wBAAa,CAACC,aAAa,EAC3B;QACEC,UAAU,CAAC,mBAAmB,EAAE7N,SAAS,CAAC;QAC1CyJ,YAAY;YACV,cAAczJ;QAChB;IACF,GACA,OAAO,EACLoD,UAAU,EACV3B,IAAI,EACJqM,SAAS,EACa;QACtB,MAAMC,kBAAkBC,IAAAA,4CAAiB,EACvC1G,IAAAA,iBAAS,IAAG2G,uBAAuB,IACnC1L,WAAWwI,YAAY,CAACmD,mBAAmB;QAG7C,MAAMC,YACJzG,cAAc0G,aAAa,CACxBC,MAAM,CACL,CAACC,WACCA,SAASC,QAAQ,CAAC,UAAU,CAACD,SAASC,QAAQ,CAAC,eAElDjO,GAAG,CAAC,CAACgO,WAAc,CAAA;gBAClBE,KAAK,CAAC,EAAE9I,YAAY,OAAO,EAAE4I,SAAS,EAAEG,IAAAA,wCAAmB,EACzDpN,KACA,OACA,CAAC;gBACHqN,SAAS,EAAE/G,gDAAAA,4BAA8B,CAAC2G,SAAS;gBACnDK,aAAapM,WAAWoM,WAAW;gBACnCC,UAAU;gBACV5K;YACF,CAAA;QAEJ,MAAM,CAAC6C,gBAAgBgI,gBAAgB,GAAGC,IAAAA,mCAAkB,EAC1DpH,eACAhC,aACAnD,WAAWoM,WAAW,EACtBhH,8BACA8G,IAAAA,wCAAmB,EAACpN,KAAK,OACzB2C;QAGF,gGAAgG;QAChG,yFAAyF;QACzF,sEAAsE;QACtE,MAAM+K,eAAelH,aAAanG,sBAAsB,eACtD,qBAAC+C;YAAehD,MAAMA;YAAMJ,KAAKA;YAAK+B,YAAYA;YAClDQ,wBAAwBC,aAAa,EACrC;YACEC,SAASmH;YACTjH;QACF;QAGF,oFAAoF;QACpF,IAAI,CAACgL,cAAcC,WAAW,GAAGF,aAAaG,GAAG;QAEjD,MAAMC,yBACJ,qBAAChC,mBAAmBiC,QAAQ;YAC1B5P,OAAO;gBACL6P,QAAQ;gBACRrL;YACF;sBAEA,cAAA,qBAACoJ;0BACC,cAAA,qBAACzG;oBACCC,mBAAmBoI;oBACnBnI,gBAAgBA;oBAChBjD,yBAAyBA;oBACzBI,OAAOA;;;;QAMf,MAAMsL,WAAW,CAAC,CAAC/M,WAAWgN,SAAS;QAEvC,MAAMC,YACJ,sEAAsE;QACtE,gCAAgC;QAChC3N,sBAAsB4N,cAAc,IACpC,uDAAuD;QACvD,mEAAmE;QACnE,sEAAsE;QACtE,kEAAkE;QAClE,yDAAyD;QACxD,CAAC/E,sBAAsB,CAAC4E,WACrB,CAAC1E;YACCA,QAAQ8E,OAAO,CAAC,CAAClQ,OAAOY;gBACtBuK,UAAUvK,KAAKZ;YACjB;QACF,IACAa;QAEN,MAAMsP,wBAAwBC,IAAAA,oDAAyB,EAAC;YACtDzB;YACAd;YACAwC,sBAAsBvF;YACtBwF,UAAUvN,WAAWuN,QAAQ;YAC7B/B,iBAAiBA;QACnB;QAEA,MAAMgC,WAAWC,IAAAA,oCAAoB,EAAC;YACpClF;YACAJ;YACA,wEAAwE;YACxE,qBAAqB;YACrB6E,WACE,OAAOhN,WAAWgN,SAAS,KAAK,WAC5BU,KAAKC,KAAK,CAAC3N,WAAWgN,SAAS,IAC/B;YACNY,eAAe;gBACbrM,SAAS0H;gBACTgE;gBACAY,kBAAkB;gBAClBpM;gBACAqM,kBAAkB;oBAACxB;iBAAgB;gBACnCf;YACF;QACF;QAEA,IAAI;YACF,IAAI,EAAEwC,MAAM,EAAEf,SAAS,EAAEgB,OAAO,EAAE,GAAG,MAAMR,SAASS,MAAM,CAACrB;YAE3D,MAAMM,iBAAiB5N,sBAAsB4N,cAAc;YAC3D,IAAIA,gBAAgB;gBAClB;;;;;;;;;;;;;WAaC,GAED,oEAAoE;gBACpE,IAAIgB,IAAAA,iCAAe,EAAChB,iBAAiB;oBACnC,IAAIF,aAAa,MAAM;wBACrB,iCAAiC;wBACjC1F,SAAS0F,SAAS,GAAGU,KAAKS,SAAS,CACjCC,IAAAA,4CAA4B,EAACpB;oBAEjC,OAAO;wBACL,gCAAgC;wBAChC1F,SAAS0F,SAAS,GAAGU,KAAKS,SAAS,CACjCE,IAAAA,4CAA4B;oBAEhC;oBACA,mGAAmG;oBACnG,8GAA8G;oBAC9G,uHAAuH;oBACvH,sDAAsD;oBACtD,OAAO;wBACLN,QAAQ,MAAMO,IAAAA,8CAAwB,EAACP,QAAQ;4BAC7CX;wBACF;oBACF;gBACF,OAAO;oBACL,6EAA6E;oBAC7E,6EAA6E;oBAC7E,MAAM,CAACmB,UAAUC,UAAU,GAAG9B,WAAWC,GAAG;oBAC5CD,aAAa6B;oBAEb,MAAME,IAAAA,uCAAoB,EAACD;oBAE3B,IAAIN,IAAAA,iCAAe,EAAChB,iBAAiB;wBACnC,gGAAgG;wBAChG,IAAIF,aAAa,MAAM;4BACrB,iCAAiC;4BACjC1F,SAAS0F,SAAS,GAAGU,KAAKS,SAAS,CACjCC,IAAAA,4CAA4B,EAACpB;wBAEjC,OAAO;4BACL,gCAAgC;4BAChC1F,SAAS0F,SAAS,GAAGU,KAAKS,SAAS,CACjCE,IAAAA,4CAA4B;wBAEhC;wBACA,mGAAmG;wBACnG,8GAA8G;wBAC9G,uHAAuH;wBACvH,sDAAsD;wBACtD,OAAO;4BACLN,QAAQ,MAAMO,IAAAA,8CAAwB,EAACP,QAAQ;gCAC7CX;4BACF;wBACF;oBACF,OAAO;wBACL,0BAA0B;wBAC1B,8GAA8G;wBAC9G,IAAIsB,qBAAqBX;wBAEzB,IAAIzO,sBAAsBqP,YAAY,EAAE;4BACtC,MAAM,IAAIC,8CAAqB,CAC7B;wBAEJ;wBAEA,IAAI5B,aAAa,MAAM;4BACrB,+FAA+F;4BAC/F,qGAAqG;4BACrG,MAAM6B,iBAAiBpB,IAAAA,oCAAoB,EAAC;gCAC1ClF;gCACAJ,oBAAoB;gCACpB6E,WAAWoB,IAAAA,4CAA4B,EAACpB;gCACxCY,eAAe;oCACbkB,QAAQC,IAAAA,4CAA0B,EAChC;oCAEFxN,SAAS0H;oCACTxH;gCACF;4BACF;4BAEA,qEAAqE;4BACrE,4EAA4E;4BAC5E,MAAMuN,gBAAgB,IAAIC;4BAE1B,MAAMC,+BACJ,qBAACtE,mBAAmBiC,QAAQ;gCAC1B5P,OAAO;oCACL6P,QAAQ;oCACRrL;gCACF;0CAEA,cAAA,qBAACoJ;8CACC,cAAA,qBAACzG;wCACCC,mBAAmB2K;wCACnB1K,gBAAgB,KAAO;wCACvBjD,yBAAyBA;wCACzBI,OAAOA;;;;4BAMf,MAAM,EAAEsM,QAAQoB,YAAY,EAAE,GAC5B,MAAMN,eAAeZ,MAAM,CAACiB;4BAC9B,wGAAwG;4BACxGR,qBAAqBU,IAAAA,kCAAY,EAACrB,QAAQoB;wBAC5C;wBAEA,OAAO;4BACLpB,QAAQ,MAAMsB,IAAAA,6CAAuB,EAACX,oBAAoB;gCACxDY,mBAAmBC,IAAAA,kDAA+B,EAChD7C,YACAjL,OACA8J;gCAEF6B;4BACF;wBACF;oBACF;gBACF;YACF,OAAO,IAAIpN,WAAWgN,SAAS,EAAE;gBAC/B,4EAA4E;gBAC5E,MAAMsC,oBAAoBC,IAAAA,kDAA+B,EACvD7C,YACAjL,OACA8J;gBAEF,IAAIyC,SAAS;oBACX,8EAA8E;oBAC9E,OAAO;wBACLD,QAAQ,MAAMyB,IAAAA,+CAAyB,EAACzB,QAAQ;4BAC9CuB;4BACAlC;wBACF;oBACF;gBACF,OAAO;oBACL,+FAA+F;oBAC/F,OAAO;wBACLW,QAAQ,MAAM0B,IAAAA,+CAAyB,EAAC1B,QAAQ;4BAC9CuB;wBACF;oBACF;gBACF;YACF,OAAO;gBACL,kDAAkD;gBAClD,qFAAqF;gBACrF,+EAA+E;gBAC/E,OAAO;oBACLvB,QAAQ,MAAM2B,IAAAA,wCAAkB,EAAC3B,QAAQ;wBACvCuB,mBAAmBC,IAAAA,kDAA+B,EAChD7C,YACAjL,OACA8J;wBAEFpD,oBAAoBA,sBAAsBkB;wBAC1C+D;wBACAuC,0BAA0B;wBAC1BhF;oBACF;gBACF;YACF;QACF,EAAE,OAAO1I,KAAK;YACZ,IACE2N,IAAAA,gDAAuB,EAAC3N,QACvB,OAAOA,QAAQ,YACdA,QAAQ,QACR,aAAaA,OACb,OAAOA,IAAI4N,OAAO,KAAK,YACvB5N,IAAI4N,OAAO,CAAC5M,QAAQ,CAClB,iEAEJ;gBACA,sDAAsD;gBACtD,MAAMhB;YACR;YAEA,uEAAuE;YACvE,mEAAmE;YACnE,IAAIkG,sBAAsB2H,IAAAA,wCAAoB,EAAC7N,MAAM;gBACnD,MAAMA;YACR;YAEA,wEAAwE;YACxE,uBAAuB;YACvB,MAAM8N,qBAAqBC,IAAAA,iCAAmB,EAAC/N;YAC/C,IAAI8N,oBAAoB;gBACtB,MAAME,QAAQC,IAAAA,8CAA2B,EAACjO;gBAC1CkO,IAAAA,UAAK,EACH,CAAC,EAAElO,IAAImO,MAAM,CAAC,mDAAmD,EAAE3S,SAAS,kFAAkF,EAAEwS,MAAM,CAAC;gBAGzK,MAAMhO;YACR;YAEA,IAAIoO,IAAAA,yBAAe,EAACpO,MAAM;gBACxBa,IAAIS,UAAU,GAAG;YACnB;YACA,IAAI+M,mBAAmB;YACvB,IAAIC,IAAAA,yBAAe,EAACtO,MAAM;gBACxBqO,mBAAmB;gBACnBxN,IAAIS,UAAU,GAAGiN,IAAAA,wCAA8B,EAACvO;gBAChD,IAAIA,IAAIwO,cAAc,EAAE;oBACtB,MAAMpI,UAAU,IAAIqI;oBAEpB,gEAAgE;oBAChE,YAAY;oBACZ,IAAIC,IAAAA,oCAAoB,EAACtI,SAASpG,IAAIwO,cAAc,GAAG;wBACrDrI,UAAU,cAActL,MAAM8T,IAAI,CAACvI,QAAQhL,MAAM;oBACnD;gBACF;gBACA,MAAMwT,cAAcC,IAAAA,4BAAa,EAC/BC,IAAAA,iCAAuB,EAAC9O,MACxBjC,WAAWuN,QAAQ;gBAErBnF,UAAU,YAAYyI;YACxB;YAEA,MAAMG,QAAQlO,IAAIS,UAAU,KAAK;YACjC,IAAI,CAACyN,SAAS,CAACV,oBAAoB,CAACP,oBAAoB;gBACtDjN,IAAIS,UAAU,GAAG;YACnB;YAEA,MAAMf,YAAYwO,QACd,cACAV,mBACE,aACAxS;YAEN,MAAM,CAACmT,qBAAqBC,qBAAqB,GAAG3E,IAAAA,mCAAkB,EACpEpH,eACAhC,aACAnD,WAAWoM,WAAW,EACtBhH,8BACA8G,IAAAA,wCAAmB,EAACpN,KAAK,QACzB2C;YAGF,MAAM0P,oBAAoB7L,aAAanG,sBAAsB,eAC3D,qBAACyE;gBAAiB1E,MAAMA;gBAAMJ,KAAKA;gBAAK0D,WAAWA;gBACnDnB,wBAAwBC,aAAa,EACrC;gBACEC,SAASmH;gBACTjH;YACF;YAGF,IAAI;gBACF,MAAM2P,aAAa,MAAMC,IAAAA,+CAAyB,EAAC;oBACjDC,gBAAgBpL,QAAQ;oBACxBqL,uBACE,qBAACnN;wBACCC,mBAAmB8M;wBACnB7M,gBAAgB2M;wBAChB5P,yBAAyBA;wBACzBI,OAAOA;;oBAGXmM,eAAe;wBACbnM;wBACA,wCAAwC;wBACxCqM,kBAAkB;4BAACoD;yBAAqB;wBACxC3F;oBACF;gBACF;gBAEA,OAAO;oBACL,kEAAkE;oBAClE,8BAA8B;oBAC9BtJ;oBACA8L,QAAQ,MAAM2B,IAAAA,wCAAkB,EAAC0B,YAAY;wBAC3C9B,mBAAmBC,IAAAA,kDAA+B,EAChD,+DAA+D;wBAC/D,8DAA8D;wBAC9D,SAAS;wBACT7C,YACAjL,OACA8J;wBAEFpD;wBACAiF,uBAAuBC,IAAAA,oDAAyB,EAAC;4BAC/CzB;4BACAd;4BACAwC,sBAAsB,EAAE;4BACxBC,UAAUvN,WAAWuN,QAAQ;4BAC7B/B,iBAAiBA;wBACnB;wBACAmE,0BAA0B;wBAC1BhF;oBACF;gBACF;YACF,EAAE,OAAO6G,UAAe;gBACtB,IACE1N,QAAQC,GAAG,CAACC,QAAQ,KAAK,iBACzBqM,IAAAA,yBAAe,EAACmB,WAChB;oBACA,MAAMC,iBACJvL,QAAQ,uDAAuDuL,cAAc;oBAC/EA;gBACF;gBACA,MAAMD;YACR;QACF;IACF;IAGF,gFAAgF;IAChF,MAAME,sBAAsB,MAAMC,IAAAA,2BAAY,EAAC;QAC7C/M;QACA9B;QACAwC;QACAkC;QACA3I;QACAS;QACA4I;QACAxC;QACA5G;IACF;IAEA,IAAIyM,YAAwB;IAC5B,IAAImG,qBAAqB;QACvB,IAAIA,oBAAoBxU,IAAI,KAAK,aAAa;YAC5C,MAAM0U,qBAAqBrV,yBAAyBC;YACpD,MAAM+H,WAAW,MAAM2G,eAAe;gBACpCrK,YAAY;gBACZ3B,MAAM0S;gBACNrG;YACF;YAEA,OAAO,IAAIsG,qBAAY,CAACtN,SAASwJ,MAAM,EAAE;gBAAEzG;YAAS;QACtD,OAAO,IAAIoK,oBAAoBxU,IAAI,KAAK,QAAQ;YAC9C,IAAIwU,oBAAoB5P,MAAM,EAAE;gBAC9B4P,oBAAoB5P,MAAM,CAACgQ,cAAc,CAACxK;gBAC1C,OAAOoK,oBAAoB5P,MAAM;YACnC,OAAO,IAAI4P,oBAAoBnG,SAAS,EAAE;gBACxCA,YAAYmG,oBAAoBnG,SAAS;YAC3C;QACF;IACF;IAEA,MAAMxM,UAA+B;QACnCuI;IACF;IAEA,IAAI/C,WAAW,MAAM2G,eAAe;QAClCrK,YAAYC;QACZ5B,MAAM1C;QACN+O;IACF;IAEA,oEAAoE;IACpE,IAAIjM,sBAAsByS,kBAAkB,EAAE;YAE1CzS;QADFP,QAAQiT,SAAS,GAAGC,QAAQC,GAAG,CAAC;aAC9B5S,0CAAAA,sBAAsB6S,gBAAgB,qBAAtC7S,wCAAwC8S,aAAa,CACnD9S,sBAAsB+S,eAAe,IAAI,EAAE;eAE1CjV,OAAOC,MAAM,CAACiC,sBAAsByS,kBAAkB,IAAI,CAAC;SAC/D;IACH;IAEAO,IAAAA,2BAAe,EAAChT;IAEhB,IAAIA,sBAAsBiT,IAAI,EAAE;QAC9BjL,SAASkL,SAAS,GAAGlT,sBAAsBiT,IAAI,CAAC5T,IAAI,CAAC;IACvD;IAEA,iDAAiD;IACjD,MAAMmD,SAAS,IAAI+P,qBAAY,CAACtN,SAASwJ,MAAM,EAAEhP;IAEjD,2EAA2E;IAC3E,IAAI,CAACoJ,oBAAoB;QACvB,OAAOrG;IACT;IAEA,uEAAuE;IACvE,4CAA4C;IAC5CyC,SAASwJ,MAAM,GAAG,MAAMjM,OAAOC,iBAAiB,CAAC;IAEjD,MAAM0Q,oBACJ5K,gBAAgB6K,IAAI,GAAG,IAAI7K,gBAAgBxK,MAAM,GAAGsV,IAAI,GAAG1V,KAAK,GAAG;IAErE,8EAA8E;IAC9E,mCAAmC;IACnC,IACEqC,sBAAsB4N,cAAc,IACpCgB,IAAAA,iCAAe,EAAC5O,sBAAsB4N,cAAc,OACpD5N,wCAAAA,sBAAsB4N,cAAc,qBAApC5N,sCAAsCsT,eAAe,GACrD;QACAC,IAAAA,SAAI,EAAC;QACL,KAAK,MAAMC,UAAUC,IAAAA,0CAAwB,EAC3CzT,sBAAsB4N,cAAc,EACnC;YACD2F,IAAAA,SAAI,EAACC;QACP;IACF;IAEA,IAAI,CAACpI,oBAAoB;QACvB,MAAM,IAAIsI,MACR;IAEJ;IAEA,mEAAmE;IACnE,oCAAoC;IACpC,IAAIP,mBAAmB;QACrB,MAAMA;IACR;IAEA,mEAAmE;IACnE,UAAU;IACV,MAAMzT,aAAa,MAAM0L;IACzB,IAAI1L,YAAY;QACdsI,SAAStI,UAAU,GAAGA;IACxB;IAEA,yEAAyE;IACzE,YAAY;IACZ,IAAIM,sBAAsB2T,WAAW,KAAK,OAAO;QAC/C3T,sBAAsB4T,UAAU,GAAG;IACrC;IAEA,+DAA+D;IAC/D5L,SAAS4L,UAAU,GACjB5T,sBAAsB4T,UAAU,IAAIpU,IAAI2L,iBAAiB;IAE3D,qCAAqC;IACrC,IAAInD,SAAS4L,UAAU,KAAK,GAAG;QAC7B5L,SAAS6L,iBAAiB,GAAG;YAC3BC,aAAa9T,sBAAsB+T,uBAAuB;YAC1DpD,OAAO3Q,sBAAsBgU,iBAAiB;QAChD;IACF;IAEA,OAAO,IAAIzB,qBAAY,CAACtN,SAASwJ,MAAM,EAAEhP;AAC3C;AAUO,MAAMzC,uBAAsC,CACjDsI,KACA9B,KACArF,UACA+B,OACAQ;IAEA,+CAA+C;IAC/C,MAAMF,WAAWyT,IAAAA,wBAAW,EAAC3O,IAAI4O,GAAG;IAEpC,OAAOC,sDAA0B,CAACtI,IAAI,CACpCnL,WAAWsF,YAAY,CAACoO,mBAAmB,EAC3C;QAAE9O;QAAK9B;QAAK9C;IAAW,GACvB,CAACkI,eACCyL,wEAAmC,CAACxI,IAAI,CACtCnL,WAAWsF,YAAY,CAACsO,4BAA4B,EACpD;YACErU,aAAaO;YACbE;YACA8E,mBAAmB;gBAAE2B,OAAO;YAAM;QACpC,GACA,CAACnH,wBACCqF,yBACEC,KACA9B,KACArF,UACA+B,OACAQ,YACA;gBACEkI;gBACA5I;gBACAL,cAAce,WAAWsF,YAAY;gBACrCtF;YACF,GACAV,sBAAsBwF,iBAAiB,IAAI,CAAC;AAIxD"}