{"version":3,"sources":["../../src/server/base-server.ts"],"sourcesContent":["import type { __ApiPreviewProps } from './api-utils'\nimport type { FontManifest, FontConfig } from './font-utils'\nimport type { LoadComponentsReturnType } from './load-components'\nimport type { MiddlewareRouteMatch } from '../shared/lib/router/utils/middleware-route-matcher'\nimport type { Params } from '../shared/lib/router/utils/route-matcher'\nimport type { NextConfig, NextConfigComplete } from './config-shared'\nimport type {\n  NextParsedUrlQuery,\n  NextUrlWithParsedQuery,\n  RequestMeta,\n} from './request-meta'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { RenderOptsPartial as PagesRenderOptsPartial } from './render'\nimport type { RenderOptsPartial as AppRenderOptsPartial } from './app-render/types'\nimport type {\n  ResponseCacheBase,\n  ResponseCacheEntry,\n  ResponseGenerator,\n} from './response-cache'\nimport type { UrlWithParsedQuery } from 'url'\nimport {\n  NormalizeError,\n  DecodeError,\n  normalizeRepeatedSlashes,\n  MissingStaticPage,\n} from '../shared/lib/utils'\nimport type { PreviewData } from '../types'\nimport type { PagesManifest } from '../build/webpack/plugins/pages-manifest-plugin'\nimport type { BaseNextRequest, BaseNextResponse } from './base-http'\nimport type {\n  ManifestRewriteRoute,\n  ManifestRoute,\n  PrerenderManifest,\n} from '../build'\nimport type { ClientReferenceManifest } from '../build/webpack/plugins/flight-manifest-plugin'\nimport type { NextFontManifest } from '../build/webpack/plugins/next-font-manifest-plugin'\nimport type { AppPageRouteModule } from './future/route-modules/app-page/module'\nimport type { PagesAPIRouteMatch } from './future/route-matches/pages-api-route-match'\nimport type { AppRouteRouteHandlerContext } from './future/route-modules/app-route/module'\nimport type {\n  Server as HTTPServer,\n  IncomingMessage,\n  ServerResponse as HTTPServerResponse,\n} from 'http'\nimport type { MiddlewareMatcher } from '../build/analysis/get-page-static-info'\nimport type { TLSSocket } from 'tls'\nimport type { PathnameNormalizer } from './future/normalizers/request/pathname-normalizer'\n\nimport { format as formatUrl, parse as parseUrl } from 'url'\nimport { formatHostname } from './lib/format-hostname'\nimport { getRedirectStatus } from '../lib/redirect-status'\nimport { isEdgeRuntime } from '../lib/is-edge-runtime'\nimport {\n  APP_PATHS_MANIFEST,\n  NEXT_BUILTIN_DOCUMENT,\n  PAGES_MANIFEST,\n  STATIC_STATUS_PAGES,\n  UNDERSCORE_NOT_FOUND_ROUTE,\n  UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,\n} from '../shared/lib/constants'\nimport { isDynamicRoute } from '../shared/lib/router/utils'\nimport { checkIsOnDemandRevalidate } from './api-utils'\nimport { setConfig } from '../shared/lib/runtime-config.external'\nimport {\n  formatRevalidate,\n  type Revalidate,\n  type SwrDelta,\n} from './lib/revalidate'\nimport { execOnce } from '../shared/lib/utils'\nimport { isBlockedPage } from './utils'\nimport { isBot } from '../shared/lib/router/utils/is-bot'\nimport RenderResult from './render-result'\nimport { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'\nimport { denormalizePagePath } from '../shared/lib/page-path/denormalize-page-path'\nimport * as Log from '../build/output/log'\nimport escapePathDelimiters from '../shared/lib/router/utils/escape-path-delimiters'\nimport { getUtils } from './server-utils'\nimport isError, { getProperError } from '../lib/is-error'\nimport {\n  addRequestMeta,\n  getRequestMeta,\n  removeRequestMeta,\n  setRequestMeta,\n} from './request-meta'\nimport { removePathPrefix } from '../shared/lib/router/utils/remove-path-prefix'\nimport { normalizeAppPath } from '../shared/lib/router/utils/app-paths'\nimport { getHostname } from '../shared/lib/get-hostname'\nimport { parseUrl as parseUrlUtil } from '../shared/lib/router/utils/parse-url'\nimport { getNextPathnameInfo } from '../shared/lib/router/utils/get-next-pathname-info'\nimport {\n  RSC_HEADER,\n  NEXT_RSC_UNION_QUERY,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_DID_POSTPONE_HEADER,\n  NEXT_URL,\n  NEXT_ROUTER_STATE_TREE,\n} from '../client/components/app-router-headers'\nimport type {\n  MatchOptions,\n  RouteMatcherManager,\n} from './future/route-matcher-managers/route-matcher-manager'\nimport { LocaleRouteNormalizer } from './future/normalizers/locale-route-normalizer'\nimport { DefaultRouteMatcherManager } from './future/route-matcher-managers/default-route-matcher-manager'\nimport { AppPageRouteMatcherProvider } from './future/route-matcher-providers/app-page-route-matcher-provider'\nimport { AppRouteRouteMatcherProvider } from './future/route-matcher-providers/app-route-route-matcher-provider'\nimport { PagesAPIRouteMatcherProvider } from './future/route-matcher-providers/pages-api-route-matcher-provider'\nimport { PagesRouteMatcherProvider } from './future/route-matcher-providers/pages-route-matcher-provider'\nimport { ServerManifestLoader } from './future/route-matcher-providers/helpers/manifest-loaders/server-manifest-loader'\nimport { getTracer, isBubbledError, SpanKind } from './lib/trace/tracer'\nimport { BaseServerSpan } from './lib/trace/constants'\nimport { I18NProvider } from './future/helpers/i18n-provider'\nimport { sendResponse } from './send-response'\nimport {\n  handleBadRequestResponse,\n  handleInternalServerErrorResponse,\n} from './future/route-modules/helpers/response-handlers'\nimport {\n  fromNodeOutgoingHttpHeaders,\n  normalizeNextQueryParam,\n  toNodeOutgoingHttpHeaders,\n} from './web/utils'\nimport { CACHE_ONE_YEAR, NEXT_CACHE_TAGS_HEADER } from '../lib/constants'\nimport { normalizeLocalePath } from '../shared/lib/i18n/normalize-locale-path'\nimport {\n  NextRequestAdapter,\n  signalFromNodeResponse,\n} from './web/spec-extension/adapters/next-request'\nimport { matchNextDataPathname } from './lib/match-next-data-pathname'\nimport getRouteFromAssetPath from '../shared/lib/router/utils/get-route-from-asset-path'\nimport { stripInternalHeaders } from './internal-utils'\nimport { RSCPathnameNormalizer } from './future/normalizers/request/rsc'\nimport { PostponedPathnameNormalizer } from './future/normalizers/request/postponed'\nimport { ActionPathnameNormalizer } from './future/normalizers/request/action'\nimport { stripFlightHeaders } from './app-render/strip-flight-headers'\nimport {\n  isAppPageRouteModule,\n  isAppRouteRouteModule,\n  isPagesRouteModule,\n} from './future/route-modules/checks'\nimport { PrefetchRSCPathnameNormalizer } from './future/normalizers/request/prefetch-rsc'\nimport { NextDataPathnameNormalizer } from './future/normalizers/request/next-data'\nimport { getIsServerAction } from './lib/server-action-request-meta'\nimport { isInterceptionRouteAppPath } from './future/helpers/interception-routes'\nimport { toRoute } from './lib/to-route'\nimport type { DeepReadonly } from '../shared/lib/deep-readonly'\nimport { isNodeNextRequest, isNodeNextResponse } from './base-http/helpers'\nimport { patchSetHeaderWithCookieSupport } from './lib/patch-set-header'\nimport { checkIsAppPPREnabled } from './lib/experimental/ppr'\nimport {\n  getBuiltinRequestContext,\n  type WaitUntil,\n} from './after/builtin-request-context'\n\nexport type FindComponentsResult = {\n  components: LoadComponentsReturnType\n  query: NextParsedUrlQuery\n}\n\nexport interface MiddlewareRoutingItem {\n  page: string\n  match: MiddlewareRouteMatch\n  matchers?: MiddlewareMatcher[]\n}\n\nexport type RouteHandler<\n  ServerRequest extends BaseNextRequest = BaseNextRequest,\n  ServerResponse extends BaseNextResponse = BaseNextResponse,\n> = (\n  req: ServerRequest,\n  res: ServerResponse,\n  parsedUrl: NextUrlWithParsedQuery\n) => PromiseLike<boolean> | boolean\n\n/**\n * The normalized route manifest is the same as the route manifest, but with\n * the rewrites normalized to the object shape that the router expects.\n */\nexport type NormalizedRouteManifest = {\n  readonly dynamicRoutes: ReadonlyArray<ManifestRoute>\n  readonly rewrites: {\n    readonly beforeFiles: ReadonlyArray<ManifestRewriteRoute>\n    readonly afterFiles: ReadonlyArray<ManifestRewriteRoute>\n    readonly fallback: ReadonlyArray<ManifestRewriteRoute>\n  }\n}\n\nexport interface Options {\n  /**\n   * Object containing the configuration next.config.js\n   */\n  conf: NextConfig\n  /**\n   * Set to false when the server was created by Next.js\n   */\n  customServer?: boolean\n  /**\n   * Tells if Next.js is running in dev mode\n   */\n  dev?: boolean\n  /**\n   * Enables the experimental testing mode.\n   */\n  experimentalTestProxy?: boolean\n\n  /**\n   * Whether or not the dev server is running in experimental HTTPS mode\n   */\n  experimentalHttpsServer?: boolean\n  /**\n   * Where the Next project is located\n   */\n  dir?: string\n  /**\n   * Tells if Next.js is at the platform-level\n   */\n  minimalMode?: boolean\n  /**\n   * Hide error messages containing server information\n   */\n  quiet?: boolean\n  /**\n   * The hostname the server is running behind\n   */\n  hostname?: string\n  /**\n   * The port the server is running behind\n   */\n  port?: number\n  /**\n   * The HTTP Server that Next.js is running behind\n   */\n  httpServer?: HTTPServer\n\n  isNodeDebugging?: 'brk' | boolean\n}\n\nexport type RenderOpts = PagesRenderOptsPartial & AppRenderOptsPartial\n\nexport type LoadedRenderOpts = RenderOpts &\n  LoadComponentsReturnType &\n  RequestLifecycleOpts\n\nexport type RequestLifecycleOpts = {\n  waitUntil: ((promise: Promise<any>) => void) | undefined\n  onClose: ((callback: () => void) => void) | undefined\n}\n\ntype BaseRenderOpts = RenderOpts & {\n  poweredByHeader: boolean\n  generateEtags: boolean\n  previewProps: __ApiPreviewProps\n}\n\n/**\n * The public interface for rendering with the server programmatically. This\n * would typically only allow the base request or response to extend it, but\n * because this can be programmatically accessed, we assume that it could also\n * be the base Node.js request and response types.\n */\nexport interface BaseRequestHandler<\n  ServerRequest extends BaseNextRequest | IncomingMessage = BaseNextRequest,\n  ServerResponse extends\n    | BaseNextResponse\n    | HTTPServerResponse = BaseNextResponse,\n> {\n  (\n    req: ServerRequest,\n    res: ServerResponse,\n    parsedUrl?: NextUrlWithParsedQuery | undefined\n  ): Promise<void> | void\n}\n\nexport type RequestContext<\n  ServerRequest extends BaseNextRequest = BaseNextRequest,\n  ServerResponse extends BaseNextResponse = BaseNextResponse,\n> = {\n  req: ServerRequest\n  res: ServerResponse\n  pathname: string\n  query: NextParsedUrlQuery\n  renderOpts: RenderOpts\n}\n\nexport type FallbackMode = false | undefined | 'blocking' | 'static'\n\nexport class NoFallbackError extends Error {}\n\n// Internal wrapper around build errors at development\n// time, to prevent us from propagating or logging them\nexport class WrappedBuildError extends Error {\n  innerError: Error\n\n  constructor(innerError: Error) {\n    super()\n    this.innerError = innerError\n  }\n}\n\ntype ResponsePayload = {\n  type: 'html' | 'json' | 'rsc'\n  body: RenderResult\n  revalidate?: Revalidate\n}\n\nexport type NextEnabledDirectories = {\n  readonly pages: boolean\n  readonly app: boolean\n}\n\nexport default abstract class Server<\n  ServerOptions extends Options = Options,\n  ServerRequest extends BaseNextRequest = BaseNextRequest,\n  ServerResponse extends BaseNextResponse = BaseNextResponse,\n> {\n  public readonly hostname?: string\n  public readonly fetchHostname?: string\n  public readonly port?: number\n  protected readonly dir: string\n  protected readonly quiet: boolean\n  protected readonly nextConfig: NextConfigComplete\n  protected readonly distDir: string\n  protected readonly publicDir: string\n  protected readonly hasStaticDir: boolean\n  protected readonly pagesManifest?: PagesManifest\n  protected readonly appPathsManifest?: PagesManifest\n  protected readonly buildId: string\n  protected readonly minimalMode: boolean\n  protected readonly renderOpts: BaseRenderOpts\n  protected readonly serverOptions: Readonly<ServerOptions>\n  protected readonly appPathRoutes?: Record<string, string[]>\n  protected readonly clientReferenceManifest?: DeepReadonly<ClientReferenceManifest>\n  protected interceptionRoutePatterns: RegExp[]\n  protected nextFontManifest?: DeepReadonly<NextFontManifest>\n  private readonly responseCache: ResponseCacheBase\n\n  protected abstract getPublicDir(): string\n  protected abstract getHasStaticDir(): boolean\n  protected abstract getPagesManifest(): PagesManifest | undefined\n  protected abstract getAppPathsManifest(): PagesManifest | undefined\n  protected abstract getBuildId(): string\n  protected abstract getinterceptionRoutePatterns(): RegExp[]\n\n  protected readonly enabledDirectories: NextEnabledDirectories\n  protected abstract getEnabledDirectories(dev: boolean): NextEnabledDirectories\n\n  protected readonly experimentalTestProxy?: boolean\n\n  protected abstract findPageComponents(params: {\n    page: string\n    query: NextParsedUrlQuery\n    params: Params\n    isAppPath: boolean\n    // The following parameters are used in the development server's\n    // implementation.\n    sriEnabled?: boolean\n    appPaths?: ReadonlyArray<string> | null\n    shouldEnsure?: boolean\n    url?: string\n  }): Promise<FindComponentsResult | null>\n  protected abstract getFontManifest(): DeepReadonly<FontManifest> | undefined\n  protected abstract getPrerenderManifest(): DeepReadonly<PrerenderManifest>\n  protected abstract getNextFontManifest():\n    | DeepReadonly<NextFontManifest>\n    | undefined\n  protected abstract attachRequestMeta(\n    req: ServerRequest,\n    parsedUrl: NextUrlWithParsedQuery\n  ): void\n  protected abstract getFallback(page: string): Promise<string>\n  protected abstract hasPage(pathname: string): Promise<boolean>\n\n  protected abstract sendRenderResult(\n    req: ServerRequest,\n    res: ServerResponse,\n    options: {\n      result: RenderResult\n      type: 'html' | 'json' | 'rsc'\n      generateEtags: boolean\n      poweredByHeader: boolean\n      revalidate?: Revalidate\n      swrDelta?: SwrDelta\n    }\n  ): Promise<void>\n\n  protected abstract runApi(\n    req: ServerRequest,\n    res: ServerResponse,\n    query: ParsedUrlQuery,\n    match: PagesAPIRouteMatch\n  ): Promise<boolean>\n\n  protected abstract renderHTML(\n    req: ServerRequest,\n    res: ServerResponse,\n    pathname: string,\n    query: NextParsedUrlQuery,\n    renderOpts: LoadedRenderOpts\n  ): Promise<RenderResult>\n\n  protected abstract getPrefetchRsc(pathname: string): Promise<string | null>\n\n  protected abstract getIncrementalCache(options: {\n    requestHeaders: Record<string, undefined | string | string[]>\n    requestProtocol: 'http' | 'https'\n  }): Promise<import('./lib/incremental-cache').IncrementalCache>\n\n  protected abstract getResponseCache(options: {\n    dev: boolean\n  }): ResponseCacheBase\n\n  protected abstract loadEnvConfig(params: {\n    dev: boolean\n    forceReload?: boolean\n  }): void\n\n  // TODO-APP: (wyattjoh): Make protected again. Used for turbopack in route-resolver.ts right now.\n  public readonly matchers: RouteMatcherManager\n  protected readonly i18nProvider?: I18NProvider\n  protected readonly localeNormalizer?: LocaleRouteNormalizer\n\n  protected readonly normalizers: {\n    readonly action: ActionPathnameNormalizer | undefined\n    readonly postponed: PostponedPathnameNormalizer | undefined\n    readonly rsc: RSCPathnameNormalizer | undefined\n    readonly prefetchRSC: PrefetchRSCPathnameNormalizer | undefined\n    readonly data: NextDataPathnameNormalizer | undefined\n  }\n\n  public constructor(options: ServerOptions) {\n    const {\n      dir = '.',\n      quiet = false,\n      conf,\n      dev = false,\n      minimalMode = false,\n      customServer = true,\n      hostname,\n      port,\n      experimentalTestProxy,\n    } = options\n\n    this.experimentalTestProxy = experimentalTestProxy\n    this.serverOptions = options\n\n    this.dir =\n      process.env.NEXT_RUNTIME === 'edge' ? dir : require('path').resolve(dir)\n\n    this.quiet = quiet\n    this.loadEnvConfig({ dev })\n\n    // TODO: should conf be normalized to prevent missing\n    // values from causing issues as this can be user provided\n    this.nextConfig = conf as NextConfigComplete\n    this.hostname = hostname\n    if (this.hostname) {\n      // we format the hostname so that it can be fetched\n      this.fetchHostname = formatHostname(this.hostname)\n    }\n    this.port = port\n    this.distDir =\n      process.env.NEXT_RUNTIME === 'edge'\n        ? this.nextConfig.distDir\n        : require('path').join(this.dir, this.nextConfig.distDir)\n    this.publicDir = this.getPublicDir()\n    this.hasStaticDir = !minimalMode && this.getHasStaticDir()\n\n    this.i18nProvider = this.nextConfig.i18n?.locales\n      ? new I18NProvider(this.nextConfig.i18n)\n      : undefined\n\n    // Configure the locale normalizer, it's used for routes inside `pages/`.\n    this.localeNormalizer = this.i18nProvider\n      ? new LocaleRouteNormalizer(this.i18nProvider)\n      : undefined\n\n    // Only serverRuntimeConfig needs the default\n    // publicRuntimeConfig gets it's default in client/index.js\n    const {\n      serverRuntimeConfig = {},\n      publicRuntimeConfig,\n      assetPrefix,\n      generateEtags,\n    } = this.nextConfig\n\n    this.buildId = this.getBuildId()\n    // this is a hack to avoid Webpack knowing this is equal to this.minimalMode\n    // because we replace this.minimalMode to true in production bundles.\n    const minimalModeKey = 'minimalMode'\n    this[minimalModeKey] =\n      minimalMode || !!process.env.NEXT_PRIVATE_MINIMAL_MODE\n\n    this.enabledDirectories = this.getEnabledDirectories(dev)\n\n    const isAppPPREnabled =\n      this.enabledDirectories.app &&\n      checkIsAppPPREnabled(this.nextConfig.experimental.ppr)\n\n    this.normalizers = {\n      // We should normalize the pathname from the RSC prefix only in minimal\n      // mode as otherwise that route is not exposed external to the server as\n      // we instead only rely on the headers.\n      postponed:\n        isAppPPREnabled && this.minimalMode\n          ? new PostponedPathnameNormalizer()\n          : undefined,\n      rsc:\n        this.enabledDirectories.app && this.minimalMode\n          ? new RSCPathnameNormalizer()\n          : undefined,\n      prefetchRSC:\n        isAppPPREnabled && this.minimalMode\n          ? new PrefetchRSCPathnameNormalizer()\n          : undefined,\n      data: this.enabledDirectories.pages\n        ? new NextDataPathnameNormalizer(this.buildId)\n        : undefined,\n      action:\n        this.enabledDirectories.app && this.minimalMode\n          ? new ActionPathnameNormalizer()\n          : undefined,\n    }\n\n    this.nextFontManifest = this.getNextFontManifest()\n\n    if (process.env.NEXT_RUNTIME !== 'edge') {\n      process.env.NEXT_DEPLOYMENT_ID = this.nextConfig.deploymentId || ''\n    }\n\n    this.renderOpts = {\n      supportsDynamicHTML: true,\n      trailingSlash: this.nextConfig.trailingSlash,\n      deploymentId: this.nextConfig.deploymentId,\n      strictNextHead: this.nextConfig.experimental.strictNextHead ?? true,\n      poweredByHeader: this.nextConfig.poweredByHeader,\n      canonicalBase: this.nextConfig.amp.canonicalBase || '',\n      buildId: this.buildId,\n      generateEtags,\n      previewProps: this.getPrerenderManifest().preview,\n      customServer: customServer === true ? true : undefined,\n      ampOptimizerConfig: this.nextConfig.experimental.amp?.optimizer,\n      basePath: this.nextConfig.basePath,\n      images: this.nextConfig.images,\n      optimizeFonts: this.nextConfig.optimizeFonts as FontConfig,\n      fontManifest:\n        (this.nextConfig.optimizeFonts as FontConfig) && !dev\n          ? this.getFontManifest()\n          : undefined,\n      optimizeCss: this.nextConfig.experimental.optimizeCss,\n      nextConfigOutput: this.nextConfig.output,\n      nextScriptWorkers: this.nextConfig.experimental.nextScriptWorkers,\n      disableOptimizedLoading:\n        this.nextConfig.experimental.disableOptimizedLoading,\n      domainLocales: this.nextConfig.i18n?.domains,\n      distDir: this.distDir,\n      serverComponents: this.enabledDirectories.app,\n      enableTainting: this.nextConfig.experimental.taint,\n      crossOrigin: this.nextConfig.crossOrigin\n        ? this.nextConfig.crossOrigin\n        : undefined,\n      largePageDataBytes: this.nextConfig.experimental.largePageDataBytes,\n      // Only the `publicRuntimeConfig` key is exposed to the client side\n      // It'll be rendered as part of __NEXT_DATA__ on the client side\n      runtimeConfig:\n        Object.keys(publicRuntimeConfig).length > 0\n          ? publicRuntimeConfig\n          : undefined,\n\n      // @ts-expect-error internal field not publicly exposed\n      isExperimentalCompile: this.nextConfig.experimental.isExperimentalCompile,\n      experimental: {\n        isAppPPREnabled,\n        swrDelta: this.nextConfig.swrDelta,\n        clientTraceMetadata: this.nextConfig.experimental.clientTraceMetadata,\n        after: this.nextConfig.experimental.after ?? false,\n      },\n    }\n\n    // Initialize next/config with the environment configuration\n    setConfig({\n      serverRuntimeConfig,\n      publicRuntimeConfig,\n    })\n\n    this.pagesManifest = this.getPagesManifest()\n    this.appPathsManifest = this.getAppPathsManifest()\n    this.appPathRoutes = this.getAppPathRoutes()\n    this.interceptionRoutePatterns = this.getinterceptionRoutePatterns()\n\n    // Configure the routes.\n    this.matchers = this.getRouteMatchers()\n\n    // Start route compilation. We don't wait for the routes to finish loading\n    // because we use the `waitTillReady` promise below in `handleRequest` to\n    // wait. Also we can't `await` in the constructor.\n    void this.matchers.reload()\n\n    this.setAssetPrefix(assetPrefix)\n    this.responseCache = this.getResponseCache({ dev })\n  }\n\n  protected reloadMatchers() {\n    return this.matchers.reload()\n  }\n\n  private handleRSCRequest: RouteHandler<ServerRequest, ServerResponse> = (\n    req,\n    _res,\n    parsedUrl\n  ) => {\n    if (!parsedUrl.pathname) return false\n\n    if (this.normalizers.prefetchRSC?.match(parsedUrl.pathname)) {\n      parsedUrl.pathname = this.normalizers.prefetchRSC.normalize(\n        parsedUrl.pathname,\n        true\n      )\n\n      // Mark the request as a router prefetch request.\n      req.headers[RSC_HEADER.toLowerCase()] = '1'\n      req.headers[NEXT_ROUTER_PREFETCH_HEADER.toLowerCase()] = '1'\n      addRequestMeta(req, 'isRSCRequest', true)\n      addRequestMeta(req, 'isPrefetchRSCRequest', true)\n    } else if (this.normalizers.rsc?.match(parsedUrl.pathname)) {\n      parsedUrl.pathname = this.normalizers.rsc.normalize(\n        parsedUrl.pathname,\n        true\n      )\n\n      // Mark the request as a RSC request.\n      req.headers[RSC_HEADER.toLowerCase()] = '1'\n      addRequestMeta(req, 'isRSCRequest', true)\n    } else if (req.headers['x-now-route-matches']) {\n      // If we didn't match, return with the flight headers stripped. If in\n      // minimal mode we didn't match based on the path, this can't be a RSC\n      // request. This is because Vercel only sends this header during\n      // revalidation requests and we want the cache to instead depend on the\n      // request path for flight information.\n      stripFlightHeaders(req.headers)\n\n      return false\n    } else if (req.headers[RSC_HEADER.toLowerCase()] === '1') {\n      addRequestMeta(req, 'isRSCRequest', true)\n\n      if (req.headers[NEXT_ROUTER_PREFETCH_HEADER.toLowerCase()] === '1') {\n        addRequestMeta(req, 'isPrefetchRSCRequest', true)\n      }\n    } else {\n      // Otherwise just return without doing anything.\n      return false\n    }\n\n    // If we're here, this is a data request, as it didn't return and it matched\n    // either a RSC or a prefetch RSC request.\n    parsedUrl.query.__nextDataReq = '1'\n\n    if (req.url) {\n      const parsed = parseUrl(req.url)\n      parsed.pathname = parsedUrl.pathname\n      req.url = formatUrl(parsed)\n    }\n\n    return false\n  }\n\n  private handleNextDataRequest: RouteHandler<ServerRequest, ServerResponse> =\n    async (req, res, parsedUrl) => {\n      const middleware = this.getMiddleware()\n      const params = matchNextDataPathname(parsedUrl.pathname)\n\n      // ignore for non-next data URLs\n      if (!params || !params.path) {\n        return false\n      }\n\n      if (params.path[0] !== this.buildId) {\n        // Ignore if its a middleware request when we aren't on edge.\n        if (\n          process.env.NEXT_RUNTIME !== 'edge' &&\n          req.headers['x-middleware-invoke']\n        ) {\n          return false\n        }\n\n        // Make sure to 404 if the buildId isn't correct\n        await this.render404(req, res, parsedUrl)\n        return true\n      }\n\n      // remove buildId from URL\n      params.path.shift()\n\n      const lastParam = params.path[params.path.length - 1]\n\n      // show 404 if it doesn't end with .json\n      if (typeof lastParam !== 'string' || !lastParam.endsWith('.json')) {\n        await this.render404(req, res, parsedUrl)\n        return true\n      }\n\n      // re-create page's pathname\n      let pathname = `/${params.path.join('/')}`\n      pathname = getRouteFromAssetPath(pathname, '.json')\n\n      // ensure trailing slash is normalized per config\n      if (middleware) {\n        if (this.nextConfig.trailingSlash && !pathname.endsWith('/')) {\n          pathname += '/'\n        }\n        if (\n          !this.nextConfig.trailingSlash &&\n          pathname.length > 1 &&\n          pathname.endsWith('/')\n        ) {\n          pathname = pathname.substring(0, pathname.length - 1)\n        }\n      }\n\n      if (this.i18nProvider) {\n        // Remove the port from the hostname if present.\n        const hostname = req?.headers.host?.split(':', 1)[0].toLowerCase()\n\n        const domainLocale = this.i18nProvider.detectDomainLocale(hostname)\n        const defaultLocale =\n          domainLocale?.defaultLocale ?? this.i18nProvider.config.defaultLocale\n\n        const localePathResult = this.i18nProvider.analyze(pathname)\n\n        // If the locale is detected from the path, we need to remove it\n        // from the pathname.\n        if (localePathResult.detectedLocale) {\n          pathname = localePathResult.pathname\n        }\n\n        // Update the query with the detected locale and default locale.\n        parsedUrl.query.__nextLocale = localePathResult.detectedLocale\n        parsedUrl.query.__nextDefaultLocale = defaultLocale\n\n        // If the locale is not detected from the path, we need to mark that\n        // it was not inferred from default.\n        if (!localePathResult.detectedLocale) {\n          delete parsedUrl.query.__nextInferredLocaleFromDefault\n        }\n\n        // If no locale was detected and we don't have middleware, we need\n        // to render a 404 page.\n        if (!localePathResult.detectedLocale && !middleware) {\n          parsedUrl.query.__nextLocale = defaultLocale\n          await this.render404(req, res, parsedUrl)\n          return true\n        }\n      }\n\n      parsedUrl.pathname = pathname\n      parsedUrl.query.__nextDataReq = '1'\n\n      return false\n    }\n\n  protected handleNextImageRequest: RouteHandler<\n    ServerRequest,\n    ServerResponse\n  > = () => false\n\n  protected handleCatchallRenderRequest: RouteHandler<\n    ServerRequest,\n    ServerResponse\n  > = () => false\n\n  protected handleCatchallMiddlewareRequest: RouteHandler<\n    ServerRequest,\n    ServerResponse\n  > = () => false\n\n  protected getRouteMatchers(): RouteMatcherManager {\n    // Create a new manifest loader that get's the manifests from the server.\n    const manifestLoader = new ServerManifestLoader((name) => {\n      switch (name) {\n        case PAGES_MANIFEST:\n          return this.getPagesManifest() ?? null\n        case APP_PATHS_MANIFEST:\n          return this.getAppPathsManifest() ?? null\n        default:\n          return null\n      }\n    })\n\n    // Configure the matchers and handlers.\n    const matchers: RouteMatcherManager = new DefaultRouteMatcherManager()\n\n    // Match pages under `pages/`.\n    matchers.push(\n      new PagesRouteMatcherProvider(\n        this.distDir,\n        manifestLoader,\n        this.i18nProvider\n      )\n    )\n\n    // Match api routes under `pages/api/`.\n    matchers.push(\n      new PagesAPIRouteMatcherProvider(\n        this.distDir,\n        manifestLoader,\n        this.i18nProvider\n      )\n    )\n\n    // If the app directory is enabled, then add the app matchers and handlers.\n    if (this.enabledDirectories.app) {\n      // Match app pages under `app/`.\n      matchers.push(\n        new AppPageRouteMatcherProvider(this.distDir, manifestLoader)\n      )\n      matchers.push(\n        new AppRouteRouteMatcherProvider(this.distDir, manifestLoader)\n      )\n    }\n\n    return matchers\n  }\n\n  public logError(err: Error): void {\n    if (this.quiet) return\n    Log.error(err)\n  }\n\n  public async handleRequest(\n    req: ServerRequest,\n    res: ServerResponse,\n    parsedUrl?: NextUrlWithParsedQuery\n  ): Promise<void> {\n    await this.prepare()\n    const method = req.method.toUpperCase()\n\n    const tracer = getTracer()\n    return tracer.withPropagatedContext(req.headers, () => {\n      return tracer.trace(\n        BaseServerSpan.handleRequest,\n        {\n          spanName: `${method} ${req.url}`,\n          kind: SpanKind.SERVER,\n          attributes: {\n            'http.method': method,\n            'http.target': req.url,\n          },\n        },\n        async (span) =>\n          this.handleRequestImpl(req, res, parsedUrl).finally(() => {\n            if (!span) return\n\n            const isRSCRequest = isRSCRequestCheck(req) ?? false\n\n            span.setAttributes({\n              'http.status_code': res.statusCode,\n              'next.rsc': isRSCRequest,\n            })\n\n            const rootSpanAttributes = tracer.getRootSpanAttributes()\n            // We were unable to get attributes, probably OTEL is not enabled\n            if (!rootSpanAttributes) return\n\n            if (\n              rootSpanAttributes.get('next.span_type') !==\n              BaseServerSpan.handleRequest\n            ) {\n              console.warn(\n                `Unexpected root span type '${rootSpanAttributes.get(\n                  'next.span_type'\n                )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n              )\n              return\n            }\n\n            const route = rootSpanAttributes.get('next.route')\n            if (route) {\n              const name = isRSCRequest\n                ? `RSC ${method} ${route}`\n                : `${method} ${route}`\n\n              span.setAttributes({\n                'next.route': route,\n                'http.route': route,\n                'next.span_name': name,\n              })\n              span.updateName(name)\n            } else {\n              span.updateName(\n                isRSCRequest\n                  ? `RSC ${method} ${req.url}`\n                  : `${method} ${req.url}`\n              )\n            }\n          })\n      )\n    })\n  }\n\n  private async handleRequestImpl(\n    req: ServerRequest,\n    res: ServerResponse,\n    parsedUrl?: NextUrlWithParsedQuery\n  ): Promise<void> {\n    try {\n      // Wait for the matchers to be ready.\n      await this.matchers.waitTillReady()\n\n      // ensure cookies set in middleware are merged and\n      // not overridden by API routes/getServerSideProps\n      patchSetHeaderWithCookieSupport(\n        req,\n        isNodeNextResponse(res) ? res.originalResponse : res\n      )\n\n      const urlParts = (req.url || '').split('?', 1)\n      const urlNoQuery = urlParts[0]\n\n      // this normalizes repeated slashes in the path e.g. hello//world ->\n      // hello/world or backslashes to forward slashes, this does not\n      // handle trailing slash as that is handled the same as a next.config.js\n      // redirect\n      if (urlNoQuery?.match(/(\\\\|\\/\\/)/)) {\n        const cleanUrl = normalizeRepeatedSlashes(req.url!)\n        res.redirect(cleanUrl, 308).body(cleanUrl).send()\n        return\n      }\n\n      // Parse url if parsedUrl not provided\n      if (!parsedUrl || typeof parsedUrl !== 'object') {\n        if (!req.url) {\n          throw new Error('Invariant: url can not be undefined')\n        }\n\n        parsedUrl = parseUrl(req.url!, true)\n      }\n\n      if (!parsedUrl.pathname) {\n        throw new Error(\"Invariant: pathname can't be empty\")\n      }\n\n      // Parse the querystring ourselves if the user doesn't handle querystring parsing\n      if (typeof parsedUrl.query === 'string') {\n        parsedUrl.query = Object.fromEntries(\n          new URLSearchParams(parsedUrl.query)\n        )\n      }\n\n      const { originalRequest = null } = isNodeNextRequest(req) ? req : {}\n      const xForwardedProto = originalRequest?.headers['x-forwarded-proto']\n      const isHttps = xForwardedProto\n        ? xForwardedProto === 'https'\n        : !!(originalRequest?.socket as TLSSocket)?.encrypted\n\n      req.headers['x-forwarded-host'] ??= req.headers['host'] ?? this.hostname\n      req.headers['x-forwarded-port'] ??= this.port\n        ? this.port.toString()\n        : isHttps\n          ? '443'\n          : '80'\n      req.headers['x-forwarded-proto'] ??= isHttps ? 'https' : 'http'\n      req.headers['x-forwarded-for'] ??= originalRequest?.socket?.remoteAddress\n\n      // This should be done before any normalization of the pathname happens as\n      // it captures the initial URL.\n      this.attachRequestMeta(req, parsedUrl)\n\n      let finished = await this.handleRSCRequest(req, res, parsedUrl)\n      if (finished) return\n\n      const domainLocale = this.i18nProvider?.detectDomainLocale(\n        getHostname(parsedUrl, req.headers)\n      )\n\n      const defaultLocale =\n        domainLocale?.defaultLocale || this.nextConfig.i18n?.defaultLocale\n      parsedUrl.query.__nextDefaultLocale = defaultLocale\n\n      const url = parseUrlUtil(req.url.replace(/^\\/+/, '/'))\n      const pathnameInfo = getNextPathnameInfo(url.pathname, {\n        nextConfig: this.nextConfig,\n        i18nProvider: this.i18nProvider,\n      })\n      url.pathname = pathnameInfo.pathname\n\n      if (pathnameInfo.basePath) {\n        req.url = removePathPrefix(req.url!, this.nextConfig.basePath)\n      }\n\n      const useMatchedPathHeader =\n        this.minimalMode && typeof req.headers['x-matched-path'] === 'string'\n\n      // TODO: merge handling with x-invoke-path\n      if (useMatchedPathHeader) {\n        try {\n          if (this.enabledDirectories.app) {\n            // ensure /index path is normalized for prerender\n            // in minimal mode\n            if (req.url.match(/^\\/index($|\\?)/)) {\n              req.url = req.url.replace(/^\\/index/, '/')\n            }\n            parsedUrl.pathname =\n              parsedUrl.pathname === '/index' ? '/' : parsedUrl.pathname\n          }\n\n          // x-matched-path is the source of truth, it tells what page\n          // should be rendered because we don't process rewrites in minimalMode\n          let { pathname: matchedPath } = new URL(\n            req.headers['x-matched-path'] as string,\n            'http://localhost'\n          )\n\n          let { pathname: urlPathname } = new URL(req.url, 'http://localhost')\n\n          // For ISR the URL is normalized to the prerenderPath so if\n          // it's a data request the URL path will be the data URL,\n          // basePath is already stripped by this point\n          if (this.normalizers.data?.match(urlPathname)) {\n            parsedUrl.query.__nextDataReq = '1'\n          }\n          // In minimal mode, if PPR is enabled, then we should check to see if\n          // the matched path is a postponed path, and if it is, handle it.\n          else if (\n            this.normalizers.postponed?.match(matchedPath) &&\n            req.method === 'POST'\n          ) {\n            // Decode the postponed state from the request body, it will come as\n            // an array of buffers, so collect them and then concat them to form\n            // the string.\n            const body: Array<Buffer> = []\n            for await (const chunk of req.body) {\n              body.push(chunk)\n            }\n            const postponed = Buffer.concat(body).toString('utf8')\n\n            addRequestMeta(req, 'postponed', postponed)\n\n            // If the request does not have the `x-now-route-matches` header,\n            // it means that the request has it's exact path specified in the\n            // `x-matched-path` header. In this case, we should update the\n            // pathname to the matched path.\n            if (!req.headers['x-now-route-matches']) {\n              urlPathname = this.normalizers.postponed.normalize(\n                matchedPath,\n                true\n              )\n            }\n          }\n\n          matchedPath = this.normalize(matchedPath)\n          const normalizedUrlPath = this.stripNextDataPath(urlPathname)\n\n          // Perform locale detection and normalization.\n          const localeAnalysisResult = this.i18nProvider?.analyze(matchedPath, {\n            defaultLocale,\n          })\n\n          // The locale result will be defined even if the locale was not\n          // detected for the request because it will be inferred from the\n          // default locale.\n          if (localeAnalysisResult) {\n            parsedUrl.query.__nextLocale = localeAnalysisResult.detectedLocale\n\n            // If the detected locale was inferred from the default locale, we\n            // need to modify the metadata on the request to indicate that.\n            if (localeAnalysisResult.inferredFromDefault) {\n              parsedUrl.query.__nextInferredLocaleFromDefault = '1'\n            } else {\n              delete parsedUrl.query.__nextInferredLocaleFromDefault\n            }\n          }\n\n          // TODO: check if this is needed any more?\n          matchedPath = denormalizePagePath(matchedPath)\n\n          let srcPathname = matchedPath\n          let pageIsDynamic = isDynamicRoute(srcPathname)\n\n          if (!pageIsDynamic) {\n            const match = await this.matchers.match(srcPathname, {\n              i18n: localeAnalysisResult,\n            })\n\n            // Update the source pathname to the matched page's pathname.\n            if (match) {\n              srcPathname = match.definition.pathname\n              // The page is dynamic if the params are defined.\n              pageIsDynamic = typeof match.params !== 'undefined'\n            }\n          }\n\n          // The rest of this function can't handle i18n properly, so ensure we\n          // restore the pathname with the locale information stripped from it\n          // now that we're done matching if we're using i18n.\n          if (localeAnalysisResult) {\n            matchedPath = localeAnalysisResult.pathname\n          }\n\n          const utils = getUtils({\n            pageIsDynamic,\n            page: srcPathname,\n            i18n: this.nextConfig.i18n,\n            basePath: this.nextConfig.basePath,\n            rewrites: this.getRoutesManifest()?.rewrites || {\n              beforeFiles: [],\n              afterFiles: [],\n              fallback: [],\n            },\n            caseSensitive: !!this.nextConfig.experimental.caseSensitiveRoutes,\n          })\n\n          // Ensure parsedUrl.pathname includes locale before processing\n          // rewrites or they won't match correctly.\n          if (defaultLocale && !pathnameInfo.locale) {\n            parsedUrl.pathname = `/${defaultLocale}${parsedUrl.pathname}`\n          }\n\n          const pathnameBeforeRewrite = parsedUrl.pathname\n          const rewriteParams = utils.handleRewrites(req, parsedUrl)\n          const rewriteParamKeys = Object.keys(rewriteParams)\n          const didRewrite = pathnameBeforeRewrite !== parsedUrl.pathname\n\n          if (didRewrite && parsedUrl.pathname) {\n            addRequestMeta(req, 'rewroteURL', parsedUrl.pathname)\n          }\n          const routeParamKeys = new Set<string>()\n\n          for (const key of Object.keys(parsedUrl.query)) {\n            const value = parsedUrl.query[key]\n\n            normalizeNextQueryParam(key, (normalizedKey) => {\n              if (!parsedUrl) return // typeguard\n\n              parsedUrl.query[normalizedKey] = value\n              routeParamKeys.add(normalizedKey)\n              delete parsedUrl.query[key]\n            })\n          }\n\n          // interpolate dynamic params and normalize URL if needed\n          if (pageIsDynamic) {\n            let params: ParsedUrlQuery | false = {}\n\n            let paramsResult = utils.normalizeDynamicRouteParams(\n              parsedUrl.query\n            )\n\n            // for prerendered ISR paths we attempt parsing the route\n            // params from the URL directly as route-matches may not\n            // contain the correct values due to the filesystem path\n            // matching before the dynamic route has been matched\n            if (\n              !paramsResult.hasValidParams &&\n              pageIsDynamic &&\n              !isDynamicRoute(normalizedUrlPath)\n            ) {\n              let matcherParams = utils.dynamicRouteMatcher?.(normalizedUrlPath)\n\n              if (matcherParams) {\n                utils.normalizeDynamicRouteParams(matcherParams)\n                Object.assign(paramsResult.params, matcherParams)\n                paramsResult.hasValidParams = true\n              }\n            }\n\n            if (paramsResult.hasValidParams) {\n              params = paramsResult.params\n            }\n\n            if (\n              req.headers['x-now-route-matches'] &&\n              isDynamicRoute(matchedPath) &&\n              !paramsResult.hasValidParams\n            ) {\n              const opts: Record<string, string> = {}\n              const routeParams = utils.getParamsFromRouteMatches(\n                req,\n                opts,\n                parsedUrl.query.__nextLocale || ''\n              )\n\n              // If this returns a locale, it means that the locale was detected\n              // from the pathname.\n              if (opts.locale) {\n                parsedUrl.query.__nextLocale = opts.locale\n\n                // As the locale was parsed from the pathname, we should mark\n                // that the locale was not inferred as the default.\n                delete parsedUrl.query.__nextInferredLocaleFromDefault\n              }\n              paramsResult = utils.normalizeDynamicRouteParams(\n                routeParams,\n                true\n              )\n\n              if (paramsResult.hasValidParams) {\n                params = paramsResult.params\n              }\n            }\n\n            // handle the actual dynamic route name being requested\n            if (\n              pageIsDynamic &&\n              utils.defaultRouteMatches &&\n              normalizedUrlPath === srcPathname &&\n              !paramsResult.hasValidParams &&\n              !utils.normalizeDynamicRouteParams({ ...params }, true)\n                .hasValidParams\n            ) {\n              params = utils.defaultRouteMatches\n            }\n\n            if (params) {\n              matchedPath = utils.interpolateDynamicPath(srcPathname, params)\n              req.url = utils.interpolateDynamicPath(req.url!, params)\n            }\n          }\n\n          if (pageIsDynamic || didRewrite) {\n            utils.normalizeVercelUrl(req, true, [\n              ...rewriteParamKeys,\n              ...Object.keys(utils.defaultRouteRegex?.groups || {}),\n            ])\n          }\n          for (const key of routeParamKeys) {\n            delete parsedUrl.query[key]\n          }\n          parsedUrl.pathname = matchedPath\n          url.pathname = parsedUrl.pathname\n\n          finished = await this.normalizeAndAttachMetadata(req, res, parsedUrl)\n          if (finished) return\n        } catch (err) {\n          if (err instanceof DecodeError || err instanceof NormalizeError) {\n            res.statusCode = 400\n            return this.renderError(null, req, res, '/_error', {})\n          }\n          throw err\n        }\n      }\n\n      addRequestMeta(req, 'isLocaleDomain', Boolean(domainLocale))\n\n      if (pathnameInfo.locale) {\n        req.url = formatUrl(url)\n        addRequestMeta(req, 'didStripLocale', true)\n      }\n\n      // If we aren't in minimal mode or there is no locale in the query\n      // string, add the locale to the query string.\n      if (!this.minimalMode || !parsedUrl.query.__nextLocale) {\n        // If the locale is in the pathname, add it to the query string.\n        if (pathnameInfo.locale) {\n          parsedUrl.query.__nextLocale = pathnameInfo.locale\n        }\n        // If the default locale is available, add it to the query string and\n        // mark it as inferred rather than implicit.\n        else if (defaultLocale) {\n          parsedUrl.query.__nextLocale = defaultLocale\n          parsedUrl.query.__nextInferredLocaleFromDefault = '1'\n        }\n      }\n\n      // set incremental cache to request meta so it can\n      // be passed down for edge functions and the fetch disk\n      // cache can be leveraged locally\n      if (\n        !(this.serverOptions as any).webServerConfig &&\n        !getRequestMeta(req, 'incrementalCache')\n      ) {\n        let protocol: 'http:' | 'https:' = 'https:'\n\n        try {\n          const parsedFullUrl = new URL(\n            getRequestMeta(req, 'initURL') || '/',\n            'http://n'\n          )\n          protocol = parsedFullUrl.protocol as 'https:' | 'http:'\n        } catch {}\n\n        const incrementalCache = await this.getIncrementalCache({\n          requestHeaders: Object.assign({}, req.headers),\n          requestProtocol: protocol.substring(0, protocol.length - 1) as\n            | 'http'\n            | 'https',\n        })\n        incrementalCache.resetRequestCache()\n        addRequestMeta(req, 'incrementalCache', incrementalCache)\n        ;(globalThis as any).__incrementalCache = incrementalCache\n      }\n\n      // when x-invoke-path is specified we can short short circuit resolving\n      // we only honor this header if we are inside of a render worker to\n      // prevent external users coercing the routing path\n      const invokePath = req.headers['x-invoke-path'] as string\n      const useInvokePath =\n        !useMatchedPathHeader &&\n        process.env.NEXT_RUNTIME !== 'edge' &&\n        invokePath\n\n      if (useInvokePath) {\n        if (req.headers['x-invoke-status']) {\n          const invokeQuery = req.headers['x-invoke-query']\n\n          if (typeof invokeQuery === 'string') {\n            Object.assign(\n              parsedUrl.query,\n              JSON.parse(decodeURIComponent(invokeQuery))\n            )\n          }\n\n          res.statusCode = Number(req.headers['x-invoke-status'])\n          let err: Error | null = null\n\n          if (typeof req.headers['x-invoke-error'] === 'string') {\n            const invokeError = JSON.parse(\n              req.headers['x-invoke-error'] || '{}'\n            )\n            err = new Error(invokeError.message)\n          }\n\n          return this.renderError(err, req, res, '/_error', parsedUrl.query)\n        }\n\n        const parsedMatchedPath = new URL(invokePath || '/', 'http://n')\n        const invokePathnameInfo = getNextPathnameInfo(\n          parsedMatchedPath.pathname,\n          {\n            nextConfig: this.nextConfig,\n            parseData: false,\n          }\n        )\n\n        if (invokePathnameInfo.locale) {\n          parsedUrl.query.__nextLocale = invokePathnameInfo.locale\n        }\n\n        if (parsedUrl.pathname !== parsedMatchedPath.pathname) {\n          parsedUrl.pathname = parsedMatchedPath.pathname\n          addRequestMeta(req, 'rewroteURL', invokePathnameInfo.pathname)\n        }\n        const normalizeResult = normalizeLocalePath(\n          removePathPrefix(parsedUrl.pathname, this.nextConfig.basePath || ''),\n          this.nextConfig.i18n?.locales || []\n        )\n\n        if (normalizeResult.detectedLocale) {\n          parsedUrl.query.__nextLocale = normalizeResult.detectedLocale\n        }\n        parsedUrl.pathname = normalizeResult.pathname\n\n        for (const key of Object.keys(parsedUrl.query)) {\n          if (!key.startsWith('__next') && !key.startsWith('_next')) {\n            delete parsedUrl.query[key]\n          }\n        }\n        const invokeQuery = req.headers['x-invoke-query']\n\n        if (typeof invokeQuery === 'string') {\n          Object.assign(\n            parsedUrl.query,\n            JSON.parse(decodeURIComponent(invokeQuery))\n          )\n        }\n\n        finished = await this.normalizeAndAttachMetadata(req, res, parsedUrl)\n        if (finished) return\n\n        await this.handleCatchallRenderRequest(req, res, parsedUrl)\n        return\n      }\n\n      if (\n        process.env.NEXT_RUNTIME !== 'edge' &&\n        req.headers['x-middleware-invoke']\n      ) {\n        finished = await this.normalizeAndAttachMetadata(req, res, parsedUrl)\n        if (finished) return\n\n        finished = await this.handleCatchallMiddlewareRequest(\n          req,\n          res,\n          parsedUrl\n        )\n        if (finished) return\n\n        const err = new Error()\n        ;(err as any).result = {\n          response: new Response(null, {\n            headers: {\n              'x-middleware-next': '1',\n            },\n          }),\n        }\n        ;(err as any).bubble = true\n        throw err\n      }\n\n      // This wasn't a request via the matched path or the invoke path, so\n      // prepare for a legacy run by removing the base path.\n\n      // ensure we strip the basePath when not using an invoke header\n      if (!useMatchedPathHeader && pathnameInfo.basePath) {\n        parsedUrl.pathname = removePathPrefix(\n          parsedUrl.pathname,\n          pathnameInfo.basePath\n        )\n      }\n\n      res.statusCode = 200\n      return await this.run(req, res, parsedUrl)\n    } catch (err: any) {\n      if (err instanceof NoFallbackError) {\n        throw err\n      }\n\n      if (\n        (err && typeof err === 'object' && err.code === 'ERR_INVALID_URL') ||\n        err instanceof DecodeError ||\n        err instanceof NormalizeError\n      ) {\n        res.statusCode = 400\n        return this.renderError(null, req, res, '/_error', {})\n      }\n\n      if (\n        this.minimalMode ||\n        this.renderOpts.dev ||\n        (isBubbledError(err) && err.bubble)\n      ) {\n        throw err\n      }\n      this.logError(getProperError(err))\n      res.statusCode = 500\n      res.body('Internal Server Error').send()\n    }\n  }\n\n  /**\n   * Normalizes a pathname without attaching any metadata from any matched\n   * normalizer.\n   *\n   * @param pathname the pathname to normalize\n   * @returns the normalized pathname\n   */\n  private normalize = (pathname: string) => {\n    const normalizers: Array<PathnameNormalizer> = []\n\n    if (this.normalizers.data) {\n      normalizers.push(this.normalizers.data)\n    }\n\n    if (this.normalizers.postponed) {\n      normalizers.push(this.normalizers.postponed)\n    }\n\n    // We have to put the prefetch normalizer before the RSC normalizer\n    // because the RSC normalizer will match the prefetch RSC routes too.\n    if (this.normalizers.prefetchRSC) {\n      normalizers.push(this.normalizers.prefetchRSC)\n    }\n\n    if (this.normalizers.rsc) {\n      normalizers.push(this.normalizers.rsc)\n    }\n\n    if (this.normalizers.action) {\n      normalizers.push(this.normalizers.action)\n    }\n\n    for (const normalizer of normalizers) {\n      if (!normalizer.match(pathname)) continue\n\n      return normalizer.normalize(pathname, true)\n    }\n\n    return pathname\n  }\n\n  private normalizeAndAttachMetadata: RouteHandler<\n    ServerRequest,\n    ServerResponse\n  > = async (req, res, url) => {\n    let finished = await this.handleNextImageRequest(req, res, url)\n    if (finished) return true\n\n    if (this.enabledDirectories.pages) {\n      finished = await this.handleNextDataRequest(req, res, url)\n      if (finished) return true\n    }\n\n    return false\n  }\n\n  /**\n   * @internal - this method is internal to Next.js and should not be used directly by end-users\n   */\n  public getRequestHandlerWithMetadata(\n    meta: RequestMeta\n  ): BaseRequestHandler<ServerRequest, ServerResponse> {\n    const handler = this.getRequestHandler()\n    return (req, res, parsedUrl) => {\n      setRequestMeta(req, meta)\n      return handler(req, res, parsedUrl)\n    }\n  }\n\n  public getRequestHandler(): BaseRequestHandler<\n    ServerRequest,\n    ServerResponse\n  > {\n    return this.handleRequest.bind(this)\n  }\n\n  protected abstract handleUpgrade(\n    req: ServerRequest,\n    socket: any,\n    head?: any\n  ): Promise<void>\n\n  public setAssetPrefix(prefix?: string): void {\n    this.renderOpts.assetPrefix = prefix ? prefix.replace(/\\/$/, '') : ''\n  }\n\n  protected prepared: boolean = false\n  protected preparedPromise: Promise<void> | null = null\n  /**\n   * Runs async initialization of server.\n   * It is idempotent, won't fire underlying initialization more than once.\n   */\n  public async prepare(): Promise<void> {\n    if (this.prepared) return\n\n    if (this.preparedPromise === null) {\n      this.preparedPromise = this.prepareImpl().then(() => {\n        this.prepared = true\n        this.preparedPromise = null\n      })\n    }\n    return this.preparedPromise\n  }\n  protected async prepareImpl(): Promise<void> {}\n\n  // Backwards compatibility\n  protected async close(): Promise<void> {}\n\n  protected getAppPathRoutes(): Record<string, string[]> {\n    const appPathRoutes: Record<string, string[]> = {}\n\n    Object.keys(this.appPathsManifest || {}).forEach((entry) => {\n      const normalizedPath = normalizeAppPath(entry)\n      if (!appPathRoutes[normalizedPath]) {\n        appPathRoutes[normalizedPath] = []\n      }\n      appPathRoutes[normalizedPath].push(entry)\n    })\n    return appPathRoutes\n  }\n\n  protected async run(\n    req: ServerRequest,\n    res: ServerResponse,\n    parsedUrl: UrlWithParsedQuery\n  ): Promise<void> {\n    return getTracer().trace(BaseServerSpan.run, async () =>\n      this.runImpl(req, res, parsedUrl)\n    )\n  }\n\n  private async runImpl(\n    req: ServerRequest,\n    res: ServerResponse,\n    parsedUrl: UrlWithParsedQuery\n  ): Promise<void> {\n    await this.handleCatchallRenderRequest(req, res, parsedUrl)\n  }\n\n  private async pipe(\n    fn: (\n      ctx: RequestContext<ServerRequest, ServerResponse>\n    ) => Promise<ResponsePayload | null>,\n    partialContext: Omit<\n      RequestContext<ServerRequest, ServerResponse>,\n      'renderOpts'\n    >\n  ): Promise<void> {\n    return getTracer().trace(BaseServerSpan.pipe, async () =>\n      this.pipeImpl(fn, partialContext)\n    )\n  }\n\n  private async pipeImpl(\n    fn: (\n      ctx: RequestContext<ServerRequest, ServerResponse>\n    ) => Promise<ResponsePayload | null>,\n    partialContext: Omit<\n      RequestContext<ServerRequest, ServerResponse>,\n      'renderOpts'\n    >\n  ): Promise<void> {\n    const isBotRequest = isBot(partialContext.req.headers['user-agent'] || '')\n    const ctx: RequestContext<ServerRequest, ServerResponse> = {\n      ...partialContext,\n      renderOpts: {\n        ...this.renderOpts,\n        supportsDynamicHTML: !isBotRequest,\n        isBot: !!isBotRequest,\n      },\n    }\n    const payload = await fn(ctx)\n    if (payload === null) {\n      return\n    }\n    const { req, res } = ctx\n    const originalStatus = res.statusCode\n    const { body, type } = payload\n    let { revalidate } = payload\n    if (!res.sent) {\n      const { generateEtags, poweredByHeader, dev } = this.renderOpts\n\n      // In dev, we should not cache pages for any reason.\n      if (dev) {\n        res.setHeader('Cache-Control', 'no-store, must-revalidate')\n        revalidate = undefined\n      }\n\n      await this.sendRenderResult(req, res, {\n        result: body,\n        type,\n        generateEtags,\n        poweredByHeader,\n        revalidate,\n        swrDelta: this.nextConfig.swrDelta,\n      })\n      res.statusCode = originalStatus\n    }\n  }\n\n  private async getStaticHTML(\n    fn: (\n      ctx: RequestContext<ServerRequest, ServerResponse>\n    ) => Promise<ResponsePayload | null>,\n    partialContext: Omit<\n      RequestContext<ServerRequest, ServerResponse>,\n      'renderOpts'\n    >\n  ): Promise<string | null> {\n    const ctx: RequestContext<ServerRequest, ServerResponse> = {\n      ...partialContext,\n      renderOpts: {\n        ...this.renderOpts,\n        supportsDynamicHTML: false,\n      },\n    }\n    const payload = await fn(ctx)\n    if (payload === null) {\n      return null\n    }\n    return payload.body.toUnchunkedString()\n  }\n\n  public async render(\n    req: ServerRequest,\n    res: ServerResponse,\n    pathname: string,\n    query: NextParsedUrlQuery = {},\n    parsedUrl?: NextUrlWithParsedQuery,\n    internalRender = false\n  ): Promise<void> {\n    return getTracer().trace(BaseServerSpan.render, async () =>\n      this.renderImpl(req, res, pathname, query, parsedUrl, internalRender)\n    )\n  }\n\n  private getWaitUntil(): WaitUntil | undefined {\n    const builtinRequestContext = getBuiltinRequestContext()\n    if (builtinRequestContext) {\n      // the platform provided a request context.\n      // use the `waitUntil` from there, whether actually present or not --\n      // if not present, `unstable_after` will error.\n      return builtinRequestContext.waitUntil\n    }\n\n    if (process.env.__NEXT_TEST_MODE) {\n      // we're in a test, use a no-op.\n      return Server.noopWaitUntil\n    }\n\n    if (this.minimalMode || process.env.NEXT_RUNTIME === 'edge') {\n      // we're built for a serverless environment, and `waitUntil` is not available,\n      // but using a noop would likely lead to incorrect behavior,\n      // because we have no way of keeping the invocation alive.\n      // return nothing, and `unstable_after` will error if used.\n      return undefined\n    }\n\n    // we're in `next start` or `next dev`. noop is fine for both.\n    return Server.noopWaitUntil\n  }\n\n  private static noopWaitUntil(promise: Promise<any>) {\n    promise.catch((err: unknown) => {\n      console.error(err)\n    })\n  }\n\n  private async renderImpl(\n    req: ServerRequest,\n    res: ServerResponse,\n    pathname: string,\n    query: NextParsedUrlQuery = {},\n    parsedUrl?: NextUrlWithParsedQuery,\n    internalRender = false\n  ): Promise<void> {\n    if (!pathname.startsWith('/')) {\n      console.warn(\n        `Cannot render page with path \"${pathname}\", did you mean \"/${pathname}\"?. See more info here: https://nextjs.org/docs/messages/render-no-starting-slash`\n      )\n    }\n\n    if (\n      this.renderOpts.customServer &&\n      pathname === '/index' &&\n      !(await this.hasPage('/index'))\n    ) {\n      // maintain backwards compatibility for custom server\n      // (see custom-server integration tests)\n      pathname = '/'\n    }\n\n    // we allow custom servers to call render for all URLs\n    // so check if we need to serve a static _next file or not.\n    // we don't modify the URL for _next/data request but still\n    // call render so we special case this to prevent an infinite loop\n    if (\n      !internalRender &&\n      !this.minimalMode &&\n      !query.__nextDataReq &&\n      (req.url?.match(/^\\/_next\\//) ||\n        (this.hasStaticDir && req.url!.match(/^\\/static\\//)))\n    ) {\n      return this.handleRequest(req, res, parsedUrl)\n    }\n\n    if (isBlockedPage(pathname)) {\n      return this.render404(req, res, parsedUrl)\n    }\n\n    return this.pipe((ctx) => this.renderToResponse(ctx), {\n      req,\n      res,\n      pathname,\n      query,\n    })\n  }\n\n  protected async getStaticPaths({\n    pathname,\n  }: {\n    pathname: string\n    requestHeaders: import('./lib/incremental-cache').IncrementalCache['requestHeaders']\n    page: string\n    isAppPath: boolean\n  }): Promise<{\n    staticPaths?: string[]\n    fallbackMode?: 'static' | 'blocking' | false\n  }> {\n    // Read whether or not fallback should exist from the manifest.\n    const fallbackField =\n      this.getPrerenderManifest().dynamicRoutes[pathname]?.fallback\n\n    return {\n      // `staticPaths` is intentionally set to `undefined` as it should've\n      // been caught when checking disk data.\n      staticPaths: undefined,\n      fallbackMode:\n        typeof fallbackField === 'string'\n          ? 'static'\n          : fallbackField === null\n            ? 'blocking'\n            : fallbackField,\n    }\n  }\n\n  private async renderToResponseWithComponents(\n    requestContext: RequestContext<ServerRequest, ServerResponse>,\n    findComponentsResult: FindComponentsResult\n  ): Promise<ResponsePayload | null> {\n    return getTracer().trace(\n      BaseServerSpan.renderToResponseWithComponents,\n      async () =>\n        this.renderToResponseWithComponentsImpl(\n          requestContext,\n          findComponentsResult\n        )\n    )\n  }\n\n  protected stripInternalHeaders(req: ServerRequest): void {\n    // Skip stripping internal headers in test mode while the header stripping\n    // has been explicitly disabled. This allows tests to verify internal\n    // routing behavior.\n    if (\n      process.env.__NEXT_TEST_MODE &&\n      process.env.__NEXT_NO_STRIP_INTERNAL_HEADERS === '1'\n    ) {\n      return\n    }\n\n    // Strip the internal headers from both the request and the original\n    // request.\n    stripInternalHeaders(req.headers)\n\n    if (\n      // The type check here ensures that `req` is correctly typed, and the\n      // environment variable check provides dead code elimination.\n      process.env.NEXT_RUNTIME !== 'edge' &&\n      isNodeNextRequest(req)\n    ) {\n      stripInternalHeaders(req.originalRequest.headers)\n    }\n  }\n\n  protected pathCouldBeIntercepted(resolvedPathname: string): boolean {\n    return (\n      isInterceptionRouteAppPath(resolvedPathname) ||\n      this.interceptionRoutePatterns.some((regexp) => {\n        return regexp.test(resolvedPathname)\n      })\n    )\n  }\n\n  protected setVaryHeader(\n    req: ServerRequest,\n    res: ServerResponse,\n    isAppPath: boolean,\n    resolvedPathname: string\n  ): void {\n    const baseVaryHeader = `${RSC_HEADER}, ${NEXT_ROUTER_STATE_TREE}, ${NEXT_ROUTER_PREFETCH_HEADER}`\n    const isRSCRequest = isRSCRequestCheck(req)\n\n    let addedNextUrlToVary = false\n\n    if (isAppPath && this.pathCouldBeIntercepted(resolvedPathname)) {\n      // Interception route responses can vary based on the `Next-URL` header.\n      // We use the Vary header to signal this behavior to the client to properly cache the response.\n      res.setHeader('vary', `${baseVaryHeader}, ${NEXT_URL}`)\n      addedNextUrlToVary = true\n    } else if (isAppPath || isRSCRequest) {\n      // We don't need to include `Next-URL` in the Vary header for non-interception routes since it won't affect the response.\n      // We also set this header for pages to avoid caching issues when navigating between pages and app.\n      res.setHeader('vary', baseVaryHeader)\n    }\n\n    if (!addedNextUrlToVary) {\n      // Remove `Next-URL` from the request headers we determined it wasn't necessary to include in the Vary header.\n      // This is to avoid any dependency on the `Next-URL` header being present when preparing the response.\n      delete req.headers[NEXT_URL]\n    }\n  }\n\n  private async renderToResponseWithComponentsImpl(\n    {\n      req,\n      res,\n      pathname,\n      renderOpts: opts,\n    }: RequestContext<ServerRequest, ServerResponse>,\n    { components, query }: FindComponentsResult\n  ): Promise<ResponsePayload | null> {\n    if (pathname === UNDERSCORE_NOT_FOUND_ROUTE) {\n      pathname = '/404'\n    }\n    const is404Page = pathname === '/404'\n\n    // Strip the internal headers.\n    this.stripInternalHeaders(req)\n\n    const is500Page = pathname === '/500'\n    const isAppPath = components.isAppPath === true\n\n    const hasServerProps = !!components.getServerSideProps\n    let hasStaticPaths = !!components.getStaticPaths\n    const isServerAction = getIsServerAction(req)\n    const hasGetInitialProps = !!components.Component?.getInitialProps\n    let isSSG = !!components.getStaticProps\n\n    // Compute the iSSG cache key. We use the rewroteUrl since\n    // pages with fallback: false are allowed to be rewritten to\n    // and we need to look up the path by the rewritten path\n    let urlPathname = parseUrl(req.url || '').pathname || '/'\n\n    let resolvedUrlPathname = getRequestMeta(req, 'rewroteURL') || urlPathname\n\n    this.setVaryHeader(req, res, isAppPath, resolvedUrlPathname)\n\n    let staticPaths: string[] | undefined\n\n    let fallbackMode: FallbackMode\n    let hasFallback = false\n    const isDynamic = isDynamicRoute(components.page)\n\n    const prerenderManifest = this.getPrerenderManifest()\n\n    if (isAppPath && isDynamic) {\n      const pathsResult = await this.getStaticPaths({\n        pathname,\n        page: components.page,\n        isAppPath,\n        requestHeaders: req.headers,\n      })\n\n      staticPaths = pathsResult.staticPaths\n      fallbackMode = pathsResult.fallbackMode\n      hasFallback = typeof fallbackMode !== 'undefined'\n\n      if (this.nextConfig.output === 'export') {\n        const page = components.page\n\n        if (fallbackMode !== 'static') {\n          throw new Error(\n            `Page \"${page}\" is missing exported function \"generateStaticParams()\", which is required with \"output: export\" config.`\n          )\n        }\n        const resolvedWithoutSlash = removeTrailingSlash(resolvedUrlPathname)\n        if (!staticPaths?.includes(resolvedWithoutSlash)) {\n          throw new Error(\n            `Page \"${page}\" is missing param \"${resolvedWithoutSlash}\" in \"generateStaticParams()\", which is required with \"output: export\" config.`\n          )\n        }\n      }\n\n      if (hasFallback) {\n        hasStaticPaths = true\n      }\n    }\n\n    if (\n      hasFallback ||\n      staticPaths?.includes(resolvedUrlPathname) ||\n      // this signals revalidation in deploy environments\n      // TODO: make this more generic\n      req.headers['x-now-route-matches']\n    ) {\n      isSSG = true\n    } else if (!this.renderOpts.dev) {\n      isSSG ||= !!prerenderManifest.routes[toRoute(pathname)]\n    }\n\n    // Toggle whether or not this is a Data request\n    let isDataReq =\n      !!(\n        query.__nextDataReq ||\n        (req.headers['x-nextjs-data'] &&\n          (this.serverOptions as any).webServerConfig)\n      ) &&\n      (isSSG || hasServerProps)\n\n    /**\n     * If true, this indicates that the request being made is for an app\n     * prefetch request.\n     */\n    const isPrefetchRSCRequest =\n      (req.headers[NEXT_ROUTER_PREFETCH_HEADER.toLowerCase()] === '1' ||\n        getRequestMeta(req, 'isPrefetchRSCRequest')) ??\n      false\n\n    // when we are handling a middleware prefetch and it doesn't\n    // resolve to a static data route we bail early to avoid\n    // unexpected SSR invocations\n    if (\n      !isSSG &&\n      req.headers['x-middleware-prefetch'] &&\n      !(is404Page || pathname === '/_error')\n    ) {\n      res.setHeader('x-matched-path', pathname)\n      res.setHeader('x-middleware-skip', '1')\n      res.setHeader(\n        'cache-control',\n        'private, no-cache, no-store, max-age=0, must-revalidate'\n      )\n      res.body('{}').send()\n      return null\n    }\n\n    delete query.__nextDataReq\n\n    // normalize req.url for SSG paths as it is not exposed\n    // to getStaticProps and the asPath should not expose /_next/data\n    if (\n      isSSG &&\n      this.minimalMode &&\n      req.headers['x-matched-path'] &&\n      req.url.startsWith('/_next/data')\n    ) {\n      req.url = this.stripNextDataPath(req.url)\n    }\n\n    if (\n      !!req.headers['x-nextjs-data'] &&\n      (!res.statusCode || res.statusCode === 200)\n    ) {\n      res.setHeader(\n        'x-nextjs-matched-path',\n        `${query.__nextLocale ? `/${query.__nextLocale}` : ''}${pathname}`\n      )\n    }\n\n    // Don't delete headers[RSC] yet, it still needs to be used in renderToHTML later\n    const isRSCRequest = isRSCRequestCheck(req)\n\n    const { routeModule } = components\n\n    /**\n     * If the route being rendered is an app page, and the ppr feature has been\n     * enabled, then the given route _could_ support PPR.\n     */\n    const couldSupportPPR: boolean =\n      typeof routeModule !== 'undefined' &&\n      isAppPageRouteModule(routeModule) &&\n      this.renderOpts.experimental.isAppPPREnabled\n\n    // If this is a request that's rendering an app page that support's PPR,\n    // then if we're in development mode (or using the experimental test\n    // proxy) and the query parameter is set, then we should render the\n    // skeleton. We assume that if the page _could_ support it, we should\n    // show the skeleton in development. Ideally we would check the appConfig\n    // to see if this page has it enabled or not, but that would require\n    // plumbing the appConfig through to the server during development.\n    const isDebugPPRSkeleton =\n      query.__nextppronly &&\n      couldSupportPPR &&\n      (this.renderOpts.dev || this.experimentalTestProxy)\n        ? true\n        : false\n\n    // This page supports PPR if it has `experimentalPPR` set to `true` in the\n    // prerender manifest and this is an app page.\n    const isRoutePPREnabled: boolean =\n      couldSupportPPR &&\n      ((\n        prerenderManifest.routes[pathname] ??\n        prerenderManifest.dynamicRoutes[pathname]\n      )?.experimentalPPR === true ||\n        isDebugPPRSkeleton)\n\n    // If we're in minimal mode, then try to get the postponed information from\n    // the request metadata. If available, use it for resuming the postponed\n    // render.\n    const minimalPostponed = isRoutePPREnabled\n      ? getRequestMeta(req, 'postponed')\n      : undefined\n\n    // If PPR is enabled, and this is a RSC request (but not a prefetch), then\n    // we can use this fact to only generate the flight data for the request\n    // because we can't cache the HTML (as it's also dynamic).\n    const isDynamicRSCRequest =\n      isRoutePPREnabled && isRSCRequest && !isPrefetchRSCRequest\n\n    // we need to ensure the status code if /404 is visited directly\n    if (is404Page && !isDataReq && !isRSCRequest) {\n      res.statusCode = 404\n    }\n\n    // ensure correct status is set when visiting a status page\n    // directly e.g. /500\n    if (STATIC_STATUS_PAGES.includes(pathname)) {\n      res.statusCode = parseInt(pathname.slice(1), 10)\n    }\n\n    if (\n      // Server actions can use non-GET/HEAD methods.\n      !isServerAction &&\n      // Resume can use non-GET/HEAD methods.\n      !minimalPostponed &&\n      !is404Page &&\n      !is500Page &&\n      pathname !== '/_error' &&\n      req.method !== 'HEAD' &&\n      req.method !== 'GET' &&\n      (typeof components.Component === 'string' || isSSG)\n    ) {\n      res.statusCode = 405\n      res.setHeader('Allow', ['GET', 'HEAD'])\n      await this.renderError(null, req, res, pathname)\n      return null\n    }\n\n    // handle static page\n    if (typeof components.Component === 'string') {\n      return {\n        type: 'html',\n        // TODO: Static pages should be serialized as RenderResult\n        body: RenderResult.fromStatic(components.Component),\n      }\n    }\n\n    // Ensure that if the `amp` query parameter is falsy that we remove it from\n    // the query object. This ensures it won't be found by the `in` operator.\n    if ('amp' in query && !query.amp) delete query.amp\n\n    if (opts.supportsDynamicHTML === true) {\n      const isBotRequest = isBot(req.headers['user-agent'] || '')\n      const isSupportedDocument =\n        typeof components.Document?.getInitialProps !== 'function' ||\n        // The built-in `Document` component also supports dynamic HTML for concurrent mode.\n        NEXT_BUILTIN_DOCUMENT in components.Document\n\n      // Disable dynamic HTML in cases that we know it won't be generated,\n      // so that we can continue generating a cache key when possible.\n      // TODO-APP: should the first render for a dynamic app path\n      // be static so we can collect revalidate and populate the\n      // cache if there are no dynamic data requirements\n      opts.supportsDynamicHTML =\n        !isSSG && !isBotRequest && !query.amp && isSupportedDocument\n      opts.isBot = isBotRequest\n    }\n\n    // In development, we always want to generate dynamic HTML.\n    if (\n      !isDataReq &&\n      isAppPath &&\n      opts.dev &&\n      opts.supportsDynamicHTML === false\n    ) {\n      opts.supportsDynamicHTML = true\n    }\n\n    const defaultLocale = isSSG\n      ? this.nextConfig.i18n?.defaultLocale\n      : query.__nextDefaultLocale\n\n    const locale = query.__nextLocale\n    const locales = this.nextConfig.i18n?.locales\n\n    let previewData: PreviewData\n    let isPreviewMode = false\n\n    if (hasServerProps || isSSG || isAppPath) {\n      // For the edge runtime, we don't support preview mode in SSG.\n      if (process.env.NEXT_RUNTIME !== 'edge') {\n        const { tryGetPreviewData } =\n          require('./api-utils/node/try-get-preview-data') as typeof import('./api-utils/node/try-get-preview-data')\n        previewData = tryGetPreviewData(req, res, this.renderOpts.previewProps)\n        isPreviewMode = previewData !== false\n      }\n    }\n\n    if (isAppPath) {\n      if (!this.renderOpts.dev && !isPreviewMode && isSSG && isRSCRequest) {\n        // If this is an RSC request but we aren't in minimal mode, then we mark\n        // that this is a data request so that we can generate the flight data\n        // only.\n        if (!this.minimalMode) {\n          isDataReq = true\n        }\n\n        // If this is a dynamic RSC request, ensure that we don't purge the\n        // flight headers to ensure that we will only produce the RSC response.\n        // We only need to do this in non-edge environments (as edge doesn't\n        // support static generation).\n        if (\n          !isDynamicRSCRequest &&\n          (!isEdgeRuntime(opts.runtime) ||\n            (this.serverOptions as any).webServerConfig)\n        ) {\n          stripFlightHeaders(req.headers)\n        }\n      }\n    }\n\n    let isOnDemandRevalidate = false\n    let revalidateOnlyGenerated = false\n\n    if (isSSG) {\n      ;({ isOnDemandRevalidate, revalidateOnlyGenerated } =\n        checkIsOnDemandRevalidate(req, this.renderOpts.previewProps))\n    }\n\n    if (isSSG && this.minimalMode && req.headers['x-matched-path']) {\n      // the url value is already correct when the matched-path header is set\n      resolvedUrlPathname = urlPathname\n    }\n\n    urlPathname = removeTrailingSlash(urlPathname)\n    resolvedUrlPathname = removeTrailingSlash(resolvedUrlPathname)\n    if (this.localeNormalizer) {\n      resolvedUrlPathname = this.localeNormalizer.normalize(resolvedUrlPathname)\n    }\n\n    const handleRedirect = (pageData: any) => {\n      const redirect = {\n        destination: pageData.pageProps.__N_REDIRECT,\n        statusCode: pageData.pageProps.__N_REDIRECT_STATUS,\n        basePath: pageData.pageProps.__N_REDIRECT_BASE_PATH,\n      }\n      const statusCode = getRedirectStatus(redirect)\n      const { basePath } = this.nextConfig\n\n      if (\n        basePath &&\n        redirect.basePath !== false &&\n        redirect.destination.startsWith('/')\n      ) {\n        redirect.destination = `${basePath}${redirect.destination}`\n      }\n\n      if (redirect.destination.startsWith('/')) {\n        redirect.destination = normalizeRepeatedSlashes(redirect.destination)\n      }\n\n      res\n        .redirect(redirect.destination, statusCode)\n        .body(redirect.destination)\n        .send()\n    }\n\n    // remove /_next/data prefix from urlPathname so it matches\n    // for direct page visit and /_next/data visit\n    if (isDataReq) {\n      resolvedUrlPathname = this.stripNextDataPath(resolvedUrlPathname)\n      urlPathname = this.stripNextDataPath(urlPathname)\n    }\n\n    let ssgCacheKey: string | null = null\n    if (\n      !isPreviewMode &&\n      isSSG &&\n      !opts.supportsDynamicHTML &&\n      !isServerAction &&\n      !minimalPostponed &&\n      !isDynamicRSCRequest\n    ) {\n      ssgCacheKey = `${locale ? `/${locale}` : ''}${\n        (pathname === '/' || resolvedUrlPathname === '/') && locale\n          ? ''\n          : resolvedUrlPathname\n      }${query.amp ? '.amp' : ''}`\n    }\n\n    if ((is404Page || is500Page) && isSSG) {\n      ssgCacheKey = `${locale ? `/${locale}` : ''}${pathname}${\n        query.amp ? '.amp' : ''\n      }`\n    }\n\n    if (ssgCacheKey) {\n      // we only encode path delimiters for path segments from\n      // getStaticPaths so we need to attempt decoding the URL\n      // to match against and only escape the path delimiters\n      // this allows non-ascii values to be handled e.g. Japanese characters\n\n      // TODO: investigate adding this handling for non-SSG pages so\n      // non-ascii names work there also\n      ssgCacheKey = ssgCacheKey\n        .split('/')\n        .map((seg) => {\n          try {\n            seg = escapePathDelimiters(decodeURIComponent(seg), true)\n          } catch (_) {\n            // An improperly encoded URL was provided\n            throw new DecodeError('failed to decode param')\n          }\n          return seg\n        })\n        .join('/')\n\n      // ensure /index and / is normalized to one key\n      ssgCacheKey =\n        ssgCacheKey === '/index' && pathname === '/' ? '/' : ssgCacheKey\n    }\n    let protocol: 'http:' | 'https:' = 'https:'\n\n    try {\n      const parsedFullUrl = new URL(\n        getRequestMeta(req, 'initURL') || '/',\n        'http://n'\n      )\n      protocol = parsedFullUrl.protocol as 'https:' | 'http:'\n    } catch {}\n\n    // use existing incrementalCache instance if available\n    const incrementalCache =\n      (globalThis as any).__incrementalCache ||\n      (await this.getIncrementalCache({\n        requestHeaders: Object.assign({}, req.headers),\n        requestProtocol: protocol.substring(0, protocol.length - 1) as\n          | 'http'\n          | 'https',\n      }))\n\n    // TODO: investigate, this is not safe across multiple concurrent requests\n    incrementalCache?.resetRequestCache()\n\n    type Renderer = (context: {\n      /**\n       * The postponed data for this render. This is only provided when resuming\n       * a render that has been postponed.\n       */\n      postponed: string | undefined\n    }) => Promise<ResponseCacheEntry | null>\n\n    const doRender: Renderer = async ({ postponed }) => {\n      // In development, we always want to generate dynamic HTML.\n      let supportsDynamicHTML: boolean =\n        // If this isn't a data request and we're not in development, then we\n        // support dynamic HTML.\n        (!isDataReq && opts.dev === true) ||\n        // If this is not SSG or does not have static paths, then it supports\n        // dynamic HTML.\n        (!isSSG && !hasStaticPaths) ||\n        // If this request has provided postponed data, it supports dynamic\n        // HTML.\n        typeof postponed === 'string' ||\n        // If this is a dynamic RSC request, then this render supports dynamic\n        // HTML (it's dynamic).\n        isDynamicRSCRequest\n\n      const origQuery = parseUrl(req.url || '', true).query\n\n      // clear any dynamic route params so they aren't in\n      // the resolvedUrl\n      if (opts.params) {\n        Object.keys(opts.params).forEach((key) => {\n          delete origQuery[key]\n        })\n      }\n      const hadTrailingSlash =\n        urlPathname !== '/' && this.nextConfig.trailingSlash\n\n      const resolvedUrl = formatUrl({\n        pathname: `${resolvedUrlPathname}${hadTrailingSlash ? '/' : ''}`,\n        // make sure to only add query values from original URL\n        query: origQuery,\n      })\n      const renderOpts: LoadedRenderOpts = {\n        ...components,\n        ...opts,\n        ...(isAppPath\n          ? {\n              incrementalCache,\n              // This is a revalidation request if the request is for a static\n              // page and it is not being resumed from a postponed render and\n              // it is not a dynamic RSC request then it is a revalidation\n              // request.\n              isRevalidate: isSSG && !postponed && !isDynamicRSCRequest,\n              originalPathname: components.ComponentMod.originalPathname,\n              serverActions: this.nextConfig.experimental.serverActions,\n            }\n          : {}),\n        isDataReq,\n        resolvedUrl,\n        locale,\n        locales,\n        defaultLocale,\n        // For getServerSideProps and getInitialProps we need to ensure we use the original URL\n        // and not the resolved URL to prevent a hydration mismatch on\n        // asPath\n        resolvedAsPath:\n          hasServerProps || hasGetInitialProps\n            ? formatUrl({\n                // we use the original URL pathname less the _next/data prefix if\n                // present\n                pathname: `${urlPathname}${hadTrailingSlash ? '/' : ''}`,\n                query: origQuery,\n              })\n            : resolvedUrl,\n        experimental: {\n          ...opts.experimental,\n          isRoutePPREnabled,\n        },\n        supportsDynamicHTML,\n        isOnDemandRevalidate,\n        isDraftMode: isPreviewMode,\n        isServerAction,\n        postponed,\n        waitUntil: this.getWaitUntil(),\n        onClose: res.onClose.bind(res),\n      }\n\n      if (isDebugPPRSkeleton) {\n        supportsDynamicHTML = false\n        renderOpts.nextExport = true\n        renderOpts.supportsDynamicHTML = false\n        renderOpts.isStaticGeneration = true\n        renderOpts.isRevalidate = true\n        renderOpts.isDebugPPRSkeleton = true\n      }\n\n      // Legacy render methods will return a render result that needs to be\n      // served by the server.\n      let result: RenderResult\n\n      if (routeModule) {\n        if (isAppRouteRouteModule(routeModule)) {\n          if (\n            // The type check here ensures that `req` is correctly typed, and the\n            // environment variable check provides dead code elimination.\n            process.env.NEXT_RUNTIME === 'edge' ||\n            !isNodeNextRequest(req) ||\n            !isNodeNextResponse(res)\n          ) {\n            throw new Error(\n              'Invariant: App Route Route Modules cannot be used in the edge runtime'\n            )\n          }\n\n          const context: AppRouteRouteHandlerContext = {\n            params: opts.params,\n            prerenderManifest,\n            renderOpts: {\n              experimental: {\n                after: renderOpts.experimental.after,\n              },\n              originalPathname: components.ComponentMod.originalPathname,\n              supportsDynamicHTML,\n              incrementalCache,\n              isRevalidate: isSSG,\n              waitUntil: this.getWaitUntil(),\n              onClose: res.onClose.bind(res),\n            },\n          }\n\n          try {\n            const request = NextRequestAdapter.fromNodeNextRequest(\n              req,\n              signalFromNodeResponse(res.originalResponse)\n            )\n\n            const response = await routeModule.handle(request, context)\n\n            ;(req as any).fetchMetrics = (\n              context.renderOpts as any\n            ).fetchMetrics\n\n            const cacheTags = (context.renderOpts as any).fetchTags\n\n            // If the request is for a static response, we can cache it so long\n            // as it's not edge.\n            if (isSSG) {\n              const blob = await response.blob()\n\n              // Copy the headers from the response.\n              const headers = toNodeOutgoingHttpHeaders(response.headers)\n\n              if (cacheTags) {\n                headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n              }\n\n              if (!headers['content-type'] && blob.type) {\n                headers['content-type'] = blob.type\n              }\n\n              const revalidate = context.renderOpts.store?.revalidate ?? false\n\n              // Create the cache entry for the response.\n              const cacheEntry: ResponseCacheEntry = {\n                value: {\n                  kind: 'ROUTE',\n                  status: response.status,\n                  body: Buffer.from(await blob.arrayBuffer()),\n                  headers,\n                },\n                revalidate,\n              }\n\n              return cacheEntry\n            }\n\n            // Send the response now that we have copied it into the cache.\n            await sendResponse(\n              req,\n              res,\n              response,\n              context.renderOpts.pendingWaitUntil\n            )\n            return null\n          } catch (err) {\n            // If this is during static generation, throw the error again.\n            if (isSSG) throw err\n\n            Log.error(err)\n\n            // Otherwise, send a 500 response.\n            await sendResponse(req, res, handleInternalServerErrorResponse())\n\n            return null\n          }\n        } else if (\n          isPagesRouteModule(routeModule) ||\n          isAppPageRouteModule(routeModule)\n        ) {\n          // An OPTIONS request to a page handler is invalid.\n          if (req.method === 'OPTIONS' && !is404Page) {\n            await sendResponse(req, res, handleBadRequestResponse())\n            return null\n          }\n\n          if (isPagesRouteModule(routeModule)) {\n            // Due to the way we pass data by mutating `renderOpts`, we can't extend\n            // the object here but only updating its `clientReferenceManifest` and\n            // `nextFontManifest` properties.\n            // https://github.com/vercel/next.js/blob/df7cbd904c3bd85f399d1ce90680c0ecf92d2752/packages/next/server/render.tsx#L947-L952\n            renderOpts.nextFontManifest = this.nextFontManifest\n            renderOpts.clientReferenceManifest =\n              components.clientReferenceManifest\n\n            const request = isNodeNextRequest(req) ? req.originalRequest : req\n            const response = isNodeNextResponse(res)\n              ? res.originalResponse\n              : res\n\n            // Call the built-in render method on the module.\n            result = await routeModule.render(\n              // TODO: fix this type\n              // @ts-expect-error - preexisting accepted this\n              request,\n              response,\n              {\n                page: pathname,\n                params: opts.params,\n                query,\n                renderOpts,\n              }\n            )\n          } else {\n            const module = components.routeModule as AppPageRouteModule\n\n            // Due to the way we pass data by mutating `renderOpts`, we can't extend the\n            // object here but only updating its `nextFontManifest` field.\n            // https://github.com/vercel/next.js/blob/df7cbd904c3bd85f399d1ce90680c0ecf92d2752/packages/next/server/render.tsx#L947-L952\n            renderOpts.nextFontManifest = this.nextFontManifest\n\n            // Call the built-in render method on the module.\n            result = await module.render(req, res, {\n              page: is404Page ? '/404' : pathname,\n              params: opts.params,\n              query,\n              renderOpts,\n            })\n          }\n        } else {\n          throw new Error('Invariant: Unknown route module type')\n        }\n      } else {\n        // If we didn't match a page, we should fallback to using the legacy\n        // render method.\n        result = await this.renderHTML(req, res, pathname, query, renderOpts)\n      }\n\n      const { metadata } = result\n\n      const {\n        headers = {},\n        // Add any fetch tags that were on the page to the response headers.\n        fetchTags: cacheTags,\n      } = metadata\n\n      if (cacheTags) {\n        headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n      }\n\n      // Pull any fetch metrics from the render onto the request.\n      ;(req as any).fetchMetrics = metadata.fetchMetrics\n\n      // we don't throw static to dynamic errors in dev as isSSG\n      // is a best guess in dev since we don't have the prerender pass\n      // to know whether the path is actually static or not\n      if (\n        isAppPath &&\n        isSSG &&\n        metadata.revalidate === 0 &&\n        !this.renderOpts.dev &&\n        !isRoutePPREnabled\n      ) {\n        const staticBailoutInfo = metadata.staticBailoutInfo\n\n        const err = new Error(\n          `Page changed from static to dynamic at runtime ${urlPathname}${\n            staticBailoutInfo?.description\n              ? `, reason: ${staticBailoutInfo.description}`\n              : ``\n          }` +\n            `\\nsee more here https://nextjs.org/docs/messages/app-static-to-dynamic-error`\n        )\n\n        if (staticBailoutInfo?.stack) {\n          const stack = staticBailoutInfo.stack\n          err.stack = err.message + stack.substring(stack.indexOf('\\n'))\n        }\n\n        throw err\n      }\n\n      // Based on the metadata, we can determine what kind of cache result we\n      // should return.\n\n      // Handle `isNotFound`.\n      if ('isNotFound' in metadata && metadata.isNotFound) {\n        return { value: null, revalidate: metadata.revalidate }\n      }\n\n      // Handle `isRedirect`.\n      if (metadata.isRedirect) {\n        return {\n          value: {\n            kind: 'REDIRECT',\n            props: metadata.pageData ?? metadata.flightData,\n          },\n          revalidate: metadata.revalidate,\n        }\n      }\n\n      // Handle `isNull`.\n      if (result.isNull) {\n        return null\n      }\n\n      // We now have a valid HTML result that we can return to the user.\n      return {\n        value: {\n          kind: 'PAGE',\n          html: result,\n          pageData: metadata.pageData ?? metadata.flightData,\n          postponed: metadata.postponed,\n          headers,\n          status: isAppPath ? res.statusCode : undefined,\n        },\n        revalidate: metadata.revalidate,\n      }\n    }\n\n    const responseGenerator: ResponseGenerator = async (\n      hasResolved,\n      previousCacheEntry,\n      isRevalidating\n    ): Promise<ResponseCacheEntry | null> => {\n      const isProduction = !this.renderOpts.dev\n      const didRespond = hasResolved || res.sent\n\n      if (!staticPaths) {\n        ;({ staticPaths, fallbackMode } = hasStaticPaths\n          ? await this.getStaticPaths({\n              pathname,\n              requestHeaders: req.headers,\n              isAppPath,\n              page: components.page,\n            })\n          : { staticPaths: undefined, fallbackMode: false })\n      }\n\n      if (fallbackMode === 'static' && isBot(req.headers['user-agent'] || '')) {\n        fallbackMode = 'blocking'\n      }\n\n      // skip on-demand revalidate if cache is not present and\n      // revalidate-if-generated is set\n      if (\n        isOnDemandRevalidate &&\n        revalidateOnlyGenerated &&\n        !previousCacheEntry &&\n        !this.minimalMode\n      ) {\n        await this.render404(req, res)\n        return null\n      }\n\n      if (previousCacheEntry?.isStale === -1) {\n        isOnDemandRevalidate = true\n      }\n\n      // only allow on-demand revalidate for fallback: true/blocking\n      // or for prerendered fallback: false paths\n      if (\n        isOnDemandRevalidate &&\n        (fallbackMode !== false || previousCacheEntry)\n      ) {\n        fallbackMode = 'blocking'\n      }\n\n      // We use `ssgCacheKey` here as it is normalized to match the encoding\n      // from getStaticPaths along with including the locale.\n      //\n      // We use the `resolvedUrlPathname` for the development case when this\n      // is an app path since it doesn't include locale information.\n      let staticPathKey =\n        ssgCacheKey ?? (opts.dev && isAppPath ? resolvedUrlPathname : null)\n      if (staticPathKey && query.amp) {\n        staticPathKey = staticPathKey.replace(/\\.amp$/, '')\n      }\n\n      const isPageIncludedInStaticPaths =\n        staticPathKey && staticPaths?.includes(staticPathKey)\n\n      if ((this.nextConfig.experimental as any).isExperimentalCompile) {\n        fallbackMode = 'blocking'\n      }\n\n      // When we did not respond from cache, we need to choose to block on\n      // rendering or return a skeleton.\n      //\n      // - Data requests always block.\n      // - Blocking mode fallback always blocks.\n      // - Preview mode toggles all pages to be resolved in a blocking manner.\n      // - Non-dynamic pages should block (though this is an impossible\n      //   case in production).\n      // - Dynamic pages should return their skeleton if not defined in\n      //   getStaticPaths, then finish the data request on the client-side.\n      //\n      if (\n        process.env.NEXT_RUNTIME !== 'edge' &&\n        !this.minimalMode &&\n        fallbackMode !== 'blocking' &&\n        staticPathKey &&\n        !didRespond &&\n        !isPreviewMode &&\n        isDynamic &&\n        (isProduction || !staticPaths || !isPageIncludedInStaticPaths)\n      ) {\n        if (\n          // In development, fall through to render to handle missing\n          // getStaticPaths.\n          (isProduction || (staticPaths && staticPaths?.length > 0)) &&\n          // When fallback isn't present, abort this render so we 404\n          fallbackMode !== 'static'\n        ) {\n          throw new NoFallbackError()\n        }\n\n        if (!isDataReq) {\n          // Production already emitted the fallback as static HTML.\n          if (isProduction) {\n            const html = await this.getFallback(\n              locale ? `/${locale}${pathname}` : pathname\n            )\n\n            return {\n              value: {\n                kind: 'PAGE',\n                html: RenderResult.fromStatic(html),\n                postponed: undefined,\n                status: undefined,\n                headers: undefined,\n                pageData: {},\n              },\n            }\n          }\n          // We need to generate the fallback on-demand for development.\n          else {\n            query.__nextFallback = 'true'\n\n            // We pass `undefined` as there cannot be a postponed state in\n            // development.\n            const result = await doRender({ postponed: undefined })\n            if (!result) {\n              return null\n            }\n            // Prevent caching this result\n            delete result.revalidate\n            return result\n          }\n        }\n      }\n\n      const result = await doRender({\n        // Only requests that aren't revalidating can be resumed. If we have the\n        // minimal postponed data, then we should resume the render with it.\n        postponed:\n          !isOnDemandRevalidate && !isRevalidating && minimalPostponed\n            ? minimalPostponed\n            : undefined,\n      })\n      if (!result) {\n        return null\n      }\n\n      return {\n        ...result,\n        revalidate:\n          result.revalidate !== undefined\n            ? result.revalidate\n            : /* default to minimum revalidate (this should be an invariant) */ 1,\n      }\n    }\n\n    const cacheEntry = await this.responseCache.get(\n      ssgCacheKey,\n      responseGenerator,\n      {\n        routeKind: routeModule?.definition.kind,\n        incrementalCache,\n        isOnDemandRevalidate,\n        isPrefetch: req.headers.purpose === 'prefetch',\n      }\n    )\n\n    if (!cacheEntry) {\n      if (ssgCacheKey && !(isOnDemandRevalidate && revalidateOnlyGenerated)) {\n        // A cache entry might not be generated if a response is written\n        // in `getInitialProps` or `getServerSideProps`, but those shouldn't\n        // have a cache key. If we do have a cache key but we don't end up\n        // with a cache entry, then either Next.js or the application has a\n        // bug that needs fixing.\n        throw new Error('invariant: cache entry required but not generated')\n      }\n      return null\n    }\n\n    const didPostpone =\n      cacheEntry.value?.kind === 'PAGE' &&\n      typeof cacheEntry.value.postponed === 'string'\n\n    if (\n      isSSG &&\n      !this.minimalMode &&\n      // We don't want to send a cache header for requests that contain dynamic\n      // data. If this is a Dynamic RSC request or wasn't a Prefetch RSC\n      // request, then we should set the cache header.\n      !isDynamicRSCRequest &&\n      (!didPostpone || isPrefetchRSCRequest)\n    ) {\n      // set x-nextjs-cache header to match the header\n      // we set for the image-optimizer\n      res.setHeader(\n        'x-nextjs-cache',\n        isOnDemandRevalidate\n          ? 'REVALIDATED'\n          : cacheEntry.isMiss\n            ? 'MISS'\n            : cacheEntry.isStale\n              ? 'STALE'\n              : 'HIT'\n      )\n    }\n\n    const { value: cachedData } = cacheEntry\n\n    // If the cache value is an image, we should error early.\n    if (cachedData?.kind === 'IMAGE') {\n      throw new Error('invariant SSG should not return an image cache value')\n    }\n\n    // Coerce the revalidate parameter from the render.\n    let revalidate: Revalidate | undefined\n\n    // If this is a resume request in minimal mode it is streamed with dynamic\n    // content and should not be cached.\n    if (minimalPostponed) {\n      revalidate = 0\n    }\n\n    // If this is in minimal mode and this is a flight request that isn't a\n    // prefetch request while PPR is enabled, it cannot be cached as it contains\n    // dynamic content.\n    else if (\n      this.minimalMode &&\n      isRSCRequest &&\n      !isPrefetchRSCRequest &&\n      isRoutePPREnabled\n    ) {\n      revalidate = 0\n    } else if (\n      typeof cacheEntry.revalidate !== 'undefined' &&\n      (!this.renderOpts.dev || (hasServerProps && !isDataReq))\n    ) {\n      // If this is a preview mode request, we shouldn't cache it. We also don't\n      // cache 404 pages.\n      if (isPreviewMode || (is404Page && !isDataReq)) {\n        revalidate = 0\n      }\n\n      // If this isn't SSG, then we should set change the header only if it is\n      // not set already.\n      else if (!isSSG) {\n        if (!res.getHeader('Cache-Control')) {\n          revalidate = 0\n        }\n      }\n\n      // If the cache entry has a revalidate value that's a number, use it.\n      else if (typeof cacheEntry.revalidate === 'number') {\n        if (cacheEntry.revalidate < 1) {\n          throw new Error(\n            `Invariant: invalid Cache-Control duration provided: ${cacheEntry.revalidate} < 1`\n          )\n        }\n\n        revalidate = cacheEntry.revalidate\n      }\n      // Otherwise if the revalidate value is false, then we should use the cache\n      // time of one year.\n      else if (cacheEntry.revalidate === false) {\n        revalidate = CACHE_ONE_YEAR\n      }\n    }\n\n    cacheEntry.revalidate = revalidate\n\n    // If there's a callback for `onCacheEntry`, call it with the cache entry\n    // and the revalidate options.\n    const onCacheEntry = getRequestMeta(req, 'onCacheEntry')\n    if (onCacheEntry) {\n      const finished = await onCacheEntry(cacheEntry, {\n        url: getRequestMeta(req, 'initURL'),\n      })\n      if (finished) {\n        // TODO: maybe we have to end the request?\n        return null\n      }\n    }\n\n    if (!cachedData) {\n      if (cacheEntry.revalidate) {\n        res.setHeader(\n          'Cache-Control',\n          formatRevalidate({\n            revalidate: cacheEntry.revalidate,\n            swrDelta: this.nextConfig.swrDelta,\n          })\n        )\n      }\n      if (isDataReq) {\n        res.statusCode = 404\n        res.body('{\"notFound\":true}').send()\n        return null\n      }\n\n      if (this.renderOpts.dev) {\n        query.__nextNotFoundSrcPage = pathname\n      }\n\n      await this.render404(req, res, { pathname, query }, false)\n      return null\n    } else if (cachedData.kind === 'REDIRECT') {\n      if (cacheEntry.revalidate) {\n        res.setHeader(\n          'Cache-Control',\n          formatRevalidate({\n            revalidate: cacheEntry.revalidate,\n            swrDelta: this.nextConfig.swrDelta,\n          })\n        )\n      }\n\n      if (isDataReq) {\n        return {\n          type: 'json',\n          body: RenderResult.fromStatic(\n            // @TODO: Handle flight data.\n            JSON.stringify(cachedData.props)\n          ),\n          revalidate: cacheEntry.revalidate,\n        }\n      } else {\n        await handleRedirect(cachedData.props)\n        return null\n      }\n    } else if (cachedData.kind === 'ROUTE') {\n      const headers = { ...cachedData.headers }\n\n      if (!(this.minimalMode && isSSG)) {\n        delete headers[NEXT_CACHE_TAGS_HEADER]\n      }\n\n      await sendResponse(\n        req,\n        res,\n        new Response(cachedData.body, {\n          headers: fromNodeOutgoingHttpHeaders(headers),\n          status: cachedData.status || 200,\n        })\n      )\n      return null\n    } else if (isAppPath) {\n      // If the request has a postponed state and it's a resume request we\n      // should error.\n      if (cachedData.postponed && minimalPostponed) {\n        throw new Error(\n          'Invariant: postponed state should not be present on a resume request'\n        )\n      }\n\n      if (cachedData.headers) {\n        const headers = { ...cachedData.headers }\n\n        if (!this.minimalMode || !isSSG) {\n          delete headers[NEXT_CACHE_TAGS_HEADER]\n        }\n\n        for (let [key, value] of Object.entries(headers)) {\n          if (typeof value === 'undefined') continue\n\n          if (Array.isArray(value)) {\n            for (const v of value) {\n              res.appendHeader(key, v)\n            }\n          } else if (typeof value === 'number') {\n            value = value.toString()\n            res.appendHeader(key, value)\n          } else {\n            res.appendHeader(key, value)\n          }\n        }\n      }\n\n      if (\n        this.minimalMode &&\n        isSSG &&\n        cachedData.headers?.[NEXT_CACHE_TAGS_HEADER]\n      ) {\n        res.setHeader(\n          NEXT_CACHE_TAGS_HEADER,\n          cachedData.headers[NEXT_CACHE_TAGS_HEADER] as string\n        )\n      }\n\n      // If the request is a data request, then we shouldn't set the status code\n      // from the response because it should always be 200. This should be gated\n      // behind the experimental PPR flag.\n      if (cachedData.status && (!isDataReq || !isRoutePPREnabled)) {\n        res.statusCode = cachedData.status\n      }\n\n      // Mark that the request did postpone if this is a data request.\n      if (cachedData.postponed && isRSCRequest) {\n        res.setHeader(NEXT_DID_POSTPONE_HEADER, '1')\n      }\n\n      // we don't go through this block when preview mode is true\n      // as preview mode is a dynamic request (bypasses cache) and doesn't\n      // generate both HTML and payloads in the same request so continue to just\n      // return the generated payload\n      if (isDataReq && !isPreviewMode) {\n        // If this is a dynamic RSC request, then stream the response.\n        if (isDynamicRSCRequest) {\n          if (cachedData.pageData) {\n            throw new Error('Invariant: Expected pageData to be undefined')\n          }\n\n          if (cachedData.postponed) {\n            throw new Error('Invariant: Expected postponed to be undefined')\n          }\n\n          return {\n            type: 'rsc',\n            body: cachedData.html,\n            // Dynamic RSC responses cannot be cached, even if they're\n            // configured with `force-static` because we have no way of\n            // distinguishing between `force-static` and pages that have no\n            // postponed state.\n            // TODO: distinguish `force-static` from pages with no postponed state (static)\n            revalidate: 0,\n          }\n        }\n\n        if (typeof cachedData.pageData !== 'string') {\n          throw new Error(\n            `Invariant: expected pageData to be a string, got ${typeof cachedData.pageData}`\n          )\n        }\n\n        // As this isn't a prefetch request, we should serve the static flight\n        // data.\n        return {\n          type: 'rsc',\n          body: RenderResult.fromStatic(cachedData.pageData),\n          revalidate: cacheEntry.revalidate,\n        }\n      }\n\n      // This is a request for HTML data.\n      let body = cachedData.html\n\n      // If there's no postponed state, we should just serve the HTML. This\n      // should also be the case for a resume request because it's completed\n      // as a server render (rather than a static render).\n      if (!cachedData.postponed || this.minimalMode) {\n        return {\n          type: 'html',\n          body,\n          revalidate: cacheEntry.revalidate,\n        }\n      }\n\n      // If we're debugging the skeleton, we should just serve the HTML without\n      // resuming the render. The returned HTML will be the static shell.\n      if (isDebugPPRSkeleton) {\n        return { type: 'html', body, revalidate: 0 }\n      }\n\n      // This request has postponed, so let's create a new transformer that the\n      // dynamic data can pipe to that will attach the dynamic data to the end\n      // of the response.\n      const transformer = new TransformStream<Uint8Array, Uint8Array>()\n      body.chain(transformer.readable)\n\n      // Perform the render again, but this time, provide the postponed state.\n      // We don't await because we want the result to start streaming now, and\n      // we've already chained the transformer's readable to the render result.\n      doRender({ postponed: cachedData.postponed })\n        .then(async (result) => {\n          if (!result) {\n            throw new Error('Invariant: expected a result to be returned')\n          }\n\n          if (result.value?.kind !== 'PAGE') {\n            throw new Error(\n              `Invariant: expected a page response, got ${result.value?.kind}`\n            )\n          }\n\n          // Pipe the resume result to the transformer.\n          await result.value.html.pipeTo(transformer.writable)\n        })\n        .catch((err) => {\n          // An error occurred during piping or preparing the render, abort\n          // the transformers writer so we can terminate the stream.\n          transformer.writable.abort(err).catch((e) => {\n            console.error(\"couldn't abort transformer\", e)\n          })\n        })\n\n      return {\n        type: 'html',\n        body,\n        // We don't want to cache the response if it has postponed data because\n        // the response being sent to the client it's dynamic parts are streamed\n        // to the client on the same request.\n        revalidate: 0,\n      }\n    } else if (isDataReq) {\n      return {\n        type: 'json',\n        body: RenderResult.fromStatic(JSON.stringify(cachedData.pageData)),\n        revalidate: cacheEntry.revalidate,\n      }\n    } else {\n      return {\n        type: 'html',\n        body: cachedData.html,\n        revalidate: cacheEntry.revalidate,\n      }\n    }\n  }\n\n  private stripNextDataPath(path: string, stripLocale = true) {\n    if (path.includes(this.buildId)) {\n      const splitPath = path.substring(\n        path.indexOf(this.buildId) + this.buildId.length\n      )\n\n      path = denormalizePagePath(splitPath.replace(/\\.json$/, ''))\n    }\n\n    if (this.localeNormalizer && stripLocale) {\n      return this.localeNormalizer.normalize(path)\n    }\n    return path\n  }\n\n  // map the route to the actual bundle name\n  protected getOriginalAppPaths(route: string) {\n    if (this.enabledDirectories.app) {\n      const originalAppPath = this.appPathRoutes?.[route]\n\n      if (!originalAppPath) {\n        return null\n      }\n\n      return originalAppPath\n    }\n    return null\n  }\n\n  protected async renderPageComponent(\n    ctx: RequestContext<ServerRequest, ServerResponse>,\n    bubbleNoFallback: boolean\n  ) {\n    const { query, pathname } = ctx\n\n    const appPaths = this.getOriginalAppPaths(pathname)\n    const isAppPath = Array.isArray(appPaths)\n\n    let page = pathname\n    if (isAppPath) {\n      // the last item in the array is the root page, if there are parallel routes\n      page = appPaths[appPaths.length - 1]\n    }\n\n    const result = await this.findPageComponents({\n      page,\n      query,\n      params: ctx.renderOpts.params || {},\n      isAppPath,\n      sriEnabled: !!this.nextConfig.experimental.sri?.algorithm,\n      appPaths,\n      // Ensuring for loading page component routes is done via the matcher.\n      shouldEnsure: false,\n    })\n    if (result) {\n      getTracer().getRootSpanAttributes()?.set('next.route', pathname)\n      try {\n        return await this.renderToResponseWithComponents(ctx, result)\n      } catch (err) {\n        const isNoFallbackError = err instanceof NoFallbackError\n\n        if (!isNoFallbackError || (isNoFallbackError && bubbleNoFallback)) {\n          throw err\n        }\n      }\n    }\n    return false\n  }\n\n  private async renderToResponse(\n    ctx: RequestContext<ServerRequest, ServerResponse>\n  ): Promise<ResponsePayload | null> {\n    return getTracer().trace(\n      BaseServerSpan.renderToResponse,\n      {\n        spanName: `rendering page`,\n        attributes: {\n          'next.route': ctx.pathname,\n        },\n      },\n      async () => {\n        return this.renderToResponseImpl(ctx)\n      }\n    )\n  }\n\n  protected abstract getMiddleware(): MiddlewareRoutingItem | undefined\n  protected abstract getFallbackErrorComponents(\n    url?: string\n  ): Promise<LoadComponentsReturnType | null>\n  protected abstract getRoutesManifest(): NormalizedRouteManifest | undefined\n\n  private async renderToResponseImpl(\n    ctx: RequestContext<ServerRequest, ServerResponse>\n  ): Promise<ResponsePayload | null> {\n    const { res, query, pathname } = ctx\n    let page = pathname\n    const bubbleNoFallback = !!query._nextBubbleNoFallback\n    delete query[NEXT_RSC_UNION_QUERY]\n    delete query._nextBubbleNoFallback\n\n    const options: MatchOptions = {\n      i18n: this.i18nProvider?.fromQuery(pathname, query),\n    }\n\n    try {\n      for await (const match of this.matchers.matchAll(pathname, options)) {\n        // when a specific invoke-output is meant to be matched\n        // ensure a prior dynamic route/page doesn't take priority\n        const invokeOutput = ctx.req.headers['x-invoke-output']\n        if (\n          !this.minimalMode &&\n          typeof invokeOutput === 'string' &&\n          isDynamicRoute(invokeOutput || '') &&\n          invokeOutput !== match.definition.pathname\n        ) {\n          continue\n        }\n\n        const result = await this.renderPageComponent(\n          {\n            ...ctx,\n            pathname: match.definition.pathname,\n            renderOpts: {\n              ...ctx.renderOpts,\n              params: match.params,\n            },\n          },\n          bubbleNoFallback\n        )\n        if (result !== false) return result\n      }\n\n      // currently edge functions aren't receiving the x-matched-path\n      // header so we need to fallback to matching the current page\n      // when we weren't able to match via dynamic route to handle\n      // the rewrite case\n      // @ts-expect-error extended in child class web-server\n      if (this.serverOptions.webServerConfig) {\n        // @ts-expect-error extended in child class web-server\n        ctx.pathname = this.serverOptions.webServerConfig.page\n        const result = await this.renderPageComponent(ctx, bubbleNoFallback)\n        if (result !== false) return result\n      }\n    } catch (error) {\n      const err = getProperError(error)\n\n      if (error instanceof MissingStaticPage) {\n        console.error(\n          'Invariant: failed to load static page',\n          JSON.stringify(\n            {\n              page,\n              url: ctx.req.url,\n              matchedPath: ctx.req.headers['x-matched-path'],\n              initUrl: getRequestMeta(ctx.req, 'initURL'),\n              didRewrite: !!getRequestMeta(ctx.req, 'rewroteURL'),\n              rewroteUrl: getRequestMeta(ctx.req, 'rewroteURL'),\n            },\n            null,\n            2\n          )\n        )\n        throw err\n      }\n\n      if (err instanceof NoFallbackError && bubbleNoFallback) {\n        throw err\n      }\n      if (err instanceof DecodeError || err instanceof NormalizeError) {\n        res.statusCode = 400\n        return await this.renderErrorToResponse(ctx, err)\n      }\n\n      res.statusCode = 500\n\n      // if pages/500 is present we still need to trigger\n      // /_error `getInitialProps` to allow reporting error\n      if (await this.hasPage('/500')) {\n        ctx.query.__nextCustomErrorRender = '1'\n        await this.renderErrorToResponse(ctx, err)\n        delete ctx.query.__nextCustomErrorRender\n      }\n\n      const isWrappedError = err instanceof WrappedBuildError\n\n      if (!isWrappedError) {\n        if (\n          (this.minimalMode && process.env.NEXT_RUNTIME !== 'edge') ||\n          this.renderOpts.dev\n        ) {\n          if (isError(err)) err.page = page\n          throw err\n        }\n        this.logError(getProperError(err))\n      }\n      const response = await this.renderErrorToResponse(\n        ctx,\n        isWrappedError ? (err as WrappedBuildError).innerError : err\n      )\n      return response\n    }\n\n    if (\n      this.getMiddleware() &&\n      !!ctx.req.headers['x-nextjs-data'] &&\n      (!res.statusCode || res.statusCode === 200 || res.statusCode === 404)\n    ) {\n      res.setHeader(\n        'x-nextjs-matched-path',\n        `${query.__nextLocale ? `/${query.__nextLocale}` : ''}${pathname}`\n      )\n      res.statusCode = 200\n      res.setHeader('content-type', 'application/json')\n      res.body('{}')\n      res.send()\n      return null\n    }\n\n    res.statusCode = 404\n    return this.renderErrorToResponse(ctx, null)\n  }\n\n  public async renderToHTML(\n    req: ServerRequest,\n    res: ServerResponse,\n    pathname: string,\n    query: ParsedUrlQuery = {}\n  ): Promise<string | null> {\n    return getTracer().trace(BaseServerSpan.renderToHTML, async () => {\n      return this.renderToHTMLImpl(req, res, pathname, query)\n    })\n  }\n\n  private async renderToHTMLImpl(\n    req: ServerRequest,\n    res: ServerResponse,\n    pathname: string,\n    query: ParsedUrlQuery = {}\n  ): Promise<string | null> {\n    return this.getStaticHTML((ctx) => this.renderToResponse(ctx), {\n      req,\n      res,\n      pathname,\n      query,\n    })\n  }\n\n  public async renderError(\n    err: Error | null,\n    req: ServerRequest,\n    res: ServerResponse,\n    pathname: string,\n    query: NextParsedUrlQuery = {},\n    setHeaders = true\n  ): Promise<void> {\n    return getTracer().trace(BaseServerSpan.renderError, async () => {\n      return this.renderErrorImpl(err, req, res, pathname, query, setHeaders)\n    })\n  }\n\n  private async renderErrorImpl(\n    err: Error | null,\n    req: ServerRequest,\n    res: ServerResponse,\n    pathname: string,\n    query: NextParsedUrlQuery = {},\n    setHeaders = true\n  ): Promise<void> {\n    if (setHeaders) {\n      res.setHeader(\n        'Cache-Control',\n        'no-cache, no-store, max-age=0, must-revalidate'\n      )\n    }\n\n    return this.pipe(\n      async (ctx) => {\n        const response = await this.renderErrorToResponse(ctx, err)\n        if (this.minimalMode && res.statusCode === 500) {\n          throw err\n        }\n        return response\n      },\n      { req, res, pathname, query }\n    )\n  }\n\n  private customErrorNo404Warn = execOnce(() => {\n    Log.warn(\n      `You have added a custom /_error page without a custom /404 page. This prevents the 404 page from being auto statically optimized.\\nSee here for info: https://nextjs.org/docs/messages/custom-error-no-custom-404`\n    )\n  })\n\n  private async renderErrorToResponse(\n    ctx: RequestContext<ServerRequest, ServerResponse>,\n    err: Error | null\n  ): Promise<ResponsePayload | null> {\n    return getTracer().trace(BaseServerSpan.renderErrorToResponse, async () => {\n      return this.renderErrorToResponseImpl(ctx, err)\n    })\n  }\n\n  protected async renderErrorToResponseImpl(\n    ctx: RequestContext<ServerRequest, ServerResponse>,\n    err: Error | null\n  ): Promise<ResponsePayload | null> {\n    // Short-circuit favicon.ico in development to avoid compiling 404 page when the app has no favicon.ico.\n    // Since favicon.ico is automatically requested by the browser.\n    if (this.renderOpts.dev && ctx.pathname === '/favicon.ico') {\n      return {\n        type: 'html',\n        body: RenderResult.fromStatic(''),\n      }\n    }\n    const { res, query } = ctx\n\n    try {\n      let result: null | FindComponentsResult = null\n\n      const is404 = res.statusCode === 404\n      let using404Page = false\n\n      if (is404) {\n        if (this.enabledDirectories.app) {\n          // Use the not-found entry in app directory\n          result = await this.findPageComponents({\n            page: UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,\n            query,\n            params: {},\n            isAppPath: true,\n            shouldEnsure: true,\n            url: ctx.req.url,\n          })\n          using404Page = result !== null\n        }\n\n        if (!result && (await this.hasPage('/404'))) {\n          result = await this.findPageComponents({\n            page: '/404',\n            query,\n            params: {},\n            isAppPath: false,\n            // Ensuring can't be done here because you never \"match\" a 404 route.\n            shouldEnsure: true,\n            url: ctx.req.url,\n          })\n          using404Page = result !== null\n        }\n      }\n      let statusPage = `/${res.statusCode}`\n\n      if (\n        !ctx.query.__nextCustomErrorRender &&\n        !result &&\n        STATIC_STATUS_PAGES.includes(statusPage)\n      ) {\n        // skip ensuring /500 in dev mode as it isn't used and the\n        // dev overlay is used instead\n        if (statusPage !== '/500' || !this.renderOpts.dev) {\n          result = await this.findPageComponents({\n            page: statusPage,\n            query,\n            params: {},\n            isAppPath: false,\n            // Ensuring can't be done here because you never \"match\" a 500\n            // route.\n            shouldEnsure: true,\n            url: ctx.req.url,\n          })\n        }\n      }\n\n      if (!result) {\n        result = await this.findPageComponents({\n          page: '/_error',\n          query,\n          params: {},\n          isAppPath: false,\n          // Ensuring can't be done here because you never \"match\" an error\n          // route.\n          shouldEnsure: true,\n          url: ctx.req.url,\n        })\n        statusPage = '/_error'\n      }\n\n      if (\n        process.env.NODE_ENV !== 'production' &&\n        !using404Page &&\n        (await this.hasPage('/_error')) &&\n        !(await this.hasPage('/404'))\n      ) {\n        this.customErrorNo404Warn()\n      }\n\n      if (!result) {\n        // this can occur when a project directory has been moved/deleted\n        // which is handled in the parent process in development\n        if (this.renderOpts.dev) {\n          return {\n            type: 'html',\n            // wait for dev-server to restart before refreshing\n            body: RenderResult.fromStatic(\n              `\n              <pre>missing required error components, refreshing...</pre>\n              <script>\n                async function check() {\n                  const res = await fetch(location.href).catch(() => ({}))\n\n                  if (res.status === 200) {\n                    location.reload()\n                  } else {\n                    setTimeout(check, 1000)\n                  }\n                }\n                check()\n              </script>`\n            ),\n          }\n        }\n\n        throw new WrappedBuildError(\n          new Error('missing required error components')\n        )\n      }\n\n      // If the page has a route module, use it for the new match. If it doesn't\n      // have a route module, remove the match.\n      if (result.components.routeModule) {\n        addRequestMeta(ctx.req, 'match', {\n          definition: result.components.routeModule.definition,\n          params: undefined,\n        })\n      } else {\n        removeRequestMeta(ctx.req, 'match')\n      }\n\n      try {\n        return await this.renderToResponseWithComponents(\n          {\n            ...ctx,\n            pathname: statusPage,\n            renderOpts: {\n              ...ctx.renderOpts,\n              err,\n            },\n          },\n          result\n        )\n      } catch (maybeFallbackError) {\n        if (maybeFallbackError instanceof NoFallbackError) {\n          throw new Error('invariant: failed to render error page')\n        }\n        throw maybeFallbackError\n      }\n    } catch (error) {\n      const renderToHtmlError = getProperError(error)\n      const isWrappedError = renderToHtmlError instanceof WrappedBuildError\n      if (!isWrappedError) {\n        this.logError(renderToHtmlError)\n      }\n      res.statusCode = 500\n      const fallbackComponents = await this.getFallbackErrorComponents(\n        ctx.req.url\n      )\n\n      if (fallbackComponents) {\n        // There was an error, so use it's definition from the route module\n        // to add the match to the request.\n        addRequestMeta(ctx.req, 'match', {\n          definition: fallbackComponents.routeModule!.definition,\n          params: undefined,\n        })\n\n        return this.renderToResponseWithComponents(\n          {\n            ...ctx,\n            pathname: '/_error',\n            renderOpts: {\n              ...ctx.renderOpts,\n              // We render `renderToHtmlError` here because `err` is\n              // already captured in the stacktrace.\n              err: isWrappedError\n                ? renderToHtmlError.innerError\n                : renderToHtmlError,\n            },\n          },\n          {\n            query,\n            components: fallbackComponents,\n          }\n        )\n      }\n      return {\n        type: 'html',\n        body: RenderResult.fromStatic('Internal Server Error'),\n      }\n    }\n  }\n\n  public async renderErrorToHTML(\n    err: Error | null,\n    req: ServerRequest,\n    res: ServerResponse,\n    pathname: string,\n    query: ParsedUrlQuery = {}\n  ): Promise<string | null> {\n    return this.getStaticHTML((ctx) => this.renderErrorToResponse(ctx, err), {\n      req,\n      res,\n      pathname,\n      query,\n    })\n  }\n\n  public async render404(\n    req: ServerRequest,\n    res: ServerResponse,\n    parsedUrl?: Pick<NextUrlWithParsedQuery, 'pathname' | 'query'>,\n    setHeaders = true\n  ): Promise<void> {\n    const { pathname, query } = parsedUrl ? parsedUrl : parseUrl(req.url!, true)\n\n    if (this.nextConfig.i18n) {\n      query.__nextLocale ||= this.nextConfig.i18n.defaultLocale\n      query.__nextDefaultLocale ||= this.nextConfig.i18n.defaultLocale\n    }\n\n    res.statusCode = 404\n    return this.renderError(null, req, res, pathname!, query, setHeaders)\n  }\n}\n\nexport function isRSCRequestCheck(req: BaseNextRequest): boolean {\n  return getRequestMeta(req, 'isRSCRequest') === true\n}\n"],"names":["NoFallbackError","WrappedBuildError","Server","isRSCRequestCheck","Error","constructor","innerError","options","handleRSCRequest","req","_res","parsedUrl","pathname","normalizers","prefetchRSC","match","normalize","headers","RSC_HEADER","toLowerCase","NEXT_ROUTER_PREFETCH_HEADER","addRequestMeta","rsc","stripFlightHeaders","query","__nextDataReq","url","parsed","parseUrl","formatUrl","handleNextDataRequest","res","middleware","getMiddleware","params","matchNextDataPathname","path","buildId","process","env","NEXT_RUNTIME","render404","shift","lastParam","length","endsWith","join","getRouteFromAssetPath","nextConfig","trailingSlash","substring","i18nProvider","hostname","host","split","domainLocale","detectDomainLocale","defaultLocale","config","localePathResult","analyze","detectedLocale","__nextLocale","__nextDefaultLocale","__nextInferredLocaleFromDefault","handleNextImageRequest","handleCatchallRenderRequest","handleCatchallMiddlewareRequest","data","push","postponed","action","normalizer","normalizeAndAttachMetadata","finished","enabledDirectories","pages","prepared","preparedPromise","customErrorNo404Warn","execOnce","Log","warn","dir","quiet","conf","dev","minimalMode","customServer","port","experimentalTestProxy","serverOptions","require","resolve","loadEnvConfig","fetchHostname","formatHostname","distDir","publicDir","getPublicDir","hasStaticDir","getHasStaticDir","i18n","locales","I18NProvider","undefined","localeNormalizer","LocaleRouteNormalizer","serverRuntimeConfig","publicRuntimeConfig","assetPrefix","generateEtags","getBuildId","minimalModeKey","NEXT_PRIVATE_MINIMAL_MODE","getEnabledDirectories","isAppPPREnabled","app","checkIsAppPPREnabled","experimental","ppr","PostponedPathnameNormalizer","RSCPathnameNormalizer","PrefetchRSCPathnameNormalizer","NextDataPathnameNormalizer","ActionPathnameNormalizer","nextFontManifest","getNextFontManifest","NEXT_DEPLOYMENT_ID","deploymentId","renderOpts","supportsDynamicHTML","strictNextHead","poweredByHeader","canonicalBase","amp","previewProps","getPrerenderManifest","preview","ampOptimizerConfig","optimizer","basePath","images","optimizeFonts","fontManifest","getFontManifest","optimizeCss","nextConfigOutput","output","nextScriptWorkers","disableOptimizedLoading","domainLocales","domains","serverComponents","enableTainting","taint","crossOrigin","largePageDataBytes","runtimeConfig","Object","keys","isExperimentalCompile","swrDelta","clientTraceMetadata","after","setConfig","pagesManifest","getPagesManifest","appPathsManifest","getAppPathsManifest","appPathRoutes","getAppPathRoutes","interceptionRoutePatterns","getinterceptionRoutePatterns","matchers","getRouteMatchers","reload","setAssetPrefix","responseCache","getResponseCache","reloadMatchers","manifestLoader","ServerManifestLoader","name","PAGES_MANIFEST","APP_PATHS_MANIFEST","DefaultRouteMatcherManager","PagesRouteMatcherProvider","PagesAPIRouteMatcherProvider","AppPageRouteMatcherProvider","AppRouteRouteMatcherProvider","logError","err","error","handleRequest","prepare","method","toUpperCase","tracer","getTracer","withPropagatedContext","trace","BaseServerSpan","spanName","kind","SpanKind","SERVER","attributes","span","handleRequestImpl","finally","isRSCRequest","setAttributes","statusCode","rootSpanAttributes","getRootSpanAttributes","get","console","route","updateName","originalRequest","waitTillReady","patchSetHeaderWithCookieSupport","isNodeNextResponse","originalResponse","urlParts","urlNoQuery","cleanUrl","normalizeRepeatedSlashes","redirect","body","send","fromEntries","URLSearchParams","isNodeNextRequest","xForwardedProto","isHttps","socket","encrypted","toString","remoteAddress","attachRequestMeta","getHostname","parseUrlUtil","replace","pathnameInfo","getNextPathnameInfo","removePathPrefix","useMatchedPathHeader","matchedPath","URL","urlPathname","chunk","Buffer","concat","normalizedUrlPath","stripNextDataPath","localeAnalysisResult","inferredFromDefault","denormalizePagePath","srcPathname","pageIsDynamic","isDynamicRoute","definition","utils","getUtils","page","rewrites","getRoutesManifest","beforeFiles","afterFiles","fallback","caseSensitive","caseSensitiveRoutes","locale","pathnameBeforeRewrite","rewriteParams","handleRewrites","rewriteParamKeys","didRewrite","routeParamKeys","Set","key","value","normalizeNextQueryParam","normalizedKey","add","paramsResult","normalizeDynamicRouteParams","hasValidParams","matcherParams","dynamicRouteMatcher","assign","opts","routeParams","getParamsFromRouteMatches","defaultRouteMatches","interpolateDynamicPath","normalizeVercelUrl","defaultRouteRegex","groups","DecodeError","NormalizeError","renderError","Boolean","webServerConfig","getRequestMeta","protocol","parsedFullUrl","incrementalCache","getIncrementalCache","requestHeaders","requestProtocol","resetRequestCache","globalThis","__incrementalCache","invokePath","useInvokePath","invokeQuery","JSON","parse","decodeURIComponent","Number","invokeError","message","parsedMatchedPath","invokePathnameInfo","parseData","normalizeResult","normalizeLocalePath","startsWith","result","response","Response","bubble","run","code","isBubbledError","getProperError","getRequestHandlerWithMetadata","meta","handler","getRequestHandler","setRequestMeta","bind","prefix","prepareImpl","then","close","forEach","entry","normalizedPath","normalizeAppPath","runImpl","pipe","fn","partialContext","pipeImpl","isBotRequest","isBot","ctx","payload","originalStatus","type","revalidate","sent","setHeader","sendRenderResult","getStaticHTML","toUnchunkedString","render","internalRender","renderImpl","getWaitUntil","builtinRequestContext","getBuiltinRequestContext","waitUntil","__NEXT_TEST_MODE","noopWaitUntil","promise","catch","hasPage","isBlockedPage","renderToResponse","getStaticPaths","fallbackField","dynamicRoutes","staticPaths","fallbackMode","renderToResponseWithComponents","requestContext","findComponentsResult","renderToResponseWithComponentsImpl","stripInternalHeaders","__NEXT_NO_STRIP_INTERNAL_HEADERS","pathCouldBeIntercepted","resolvedPathname","isInterceptionRouteAppPath","some","regexp","test","setVaryHeader","isAppPath","baseVaryHeader","NEXT_ROUTER_STATE_TREE","addedNextUrlToVary","NEXT_URL","components","prerenderManifest","cacheEntry","UNDERSCORE_NOT_FOUND_ROUTE","is404Page","is500Page","hasServerProps","getServerSideProps","hasStaticPaths","isServerAction","getIsServerAction","hasGetInitialProps","Component","getInitialProps","isSSG","getStaticProps","resolvedUrlPathname","hasFallback","isDynamic","pathsResult","resolvedWithoutSlash","removeTrailingSlash","includes","routes","toRoute","isDataReq","isPrefetchRSCRequest","routeModule","couldSupportPPR","isAppPageRouteModule","isDebugPPRSkeleton","__nextppronly","isRoutePPREnabled","experimentalPPR","minimalPostponed","isDynamicRSCRequest","STATIC_STATUS_PAGES","parseInt","slice","RenderResult","fromStatic","isSupportedDocument","Document","NEXT_BUILTIN_DOCUMENT","previewData","isPreviewMode","tryGetPreviewData","isEdgeRuntime","runtime","isOnDemandRevalidate","revalidateOnlyGenerated","checkIsOnDemandRevalidate","handleRedirect","pageData","destination","pageProps","__N_REDIRECT","__N_REDIRECT_STATUS","__N_REDIRECT_BASE_PATH","getRedirectStatus","ssgCacheKey","map","seg","escapePathDelimiters","_","doRender","origQuery","hadTrailingSlash","resolvedUrl","isRevalidate","originalPathname","ComponentMod","serverActions","resolvedAsPath","isDraftMode","onClose","nextExport","isStaticGeneration","isAppRouteRouteModule","context","request","NextRequestAdapter","fromNodeNextRequest","signalFromNodeResponse","handle","fetchMetrics","cacheTags","fetchTags","blob","toNodeOutgoingHttpHeaders","NEXT_CACHE_TAGS_HEADER","store","status","from","arrayBuffer","sendResponse","pendingWaitUntil","handleInternalServerErrorResponse","isPagesRouteModule","handleBadRequestResponse","clientReferenceManifest","module","renderHTML","metadata","staticBailoutInfo","description","stack","indexOf","isNotFound","isRedirect","props","flightData","isNull","html","responseGenerator","hasResolved","previousCacheEntry","isRevalidating","isProduction","didRespond","isStale","staticPathKey","isPageIncludedInStaticPaths","getFallback","__nextFallback","routeKind","isPrefetch","purpose","didPostpone","isMiss","cachedData","getHeader","CACHE_ONE_YEAR","onCacheEntry","formatRevalidate","__nextNotFoundSrcPage","stringify","fromNodeOutgoingHttpHeaders","entries","Array","isArray","v","appendHeader","NEXT_DID_POSTPONE_HEADER","transformer","TransformStream","chain","readable","pipeTo","writable","abort","e","stripLocale","splitPath","getOriginalAppPaths","originalAppPath","renderPageComponent","bubbleNoFallback","appPaths","findPageComponents","sriEnabled","sri","algorithm","shouldEnsure","set","isNoFallbackError","renderToResponseImpl","_nextBubbleNoFallback","NEXT_RSC_UNION_QUERY","fromQuery","matchAll","invokeOutput","MissingStaticPage","initUrl","rewroteUrl","renderErrorToResponse","__nextCustomErrorRender","isWrappedError","isError","renderToHTML","renderToHTMLImpl","setHeaders","renderErrorImpl","renderErrorToResponseImpl","is404","using404Page","UNDERSCORE_NOT_FOUND_ROUTE_ENTRY","statusPage","NODE_ENV","removeRequestMeta","maybeFallbackError","renderToHtmlError","fallbackComponents","getFallbackErrorComponents","renderErrorToHTML"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}