{"version":3,"sources":["../../../../src/server/lib/server-ipc/index.ts"],"sourcesContent":["import type NextServer from '../../next-server'\nimport { errorToJSON } from '../../render'\nimport crypto from 'crypto'\nimport isError from '../../../lib/is-error'\nimport { deserializeErr } from './request-utils'\n\n// we can't use process.send as jest-worker relies on\n// it already and can cause unexpected message errors\n// so we create an IPC server for communicating\nexport async function createIpcServer(\n  server: InstanceType<typeof NextServer>\n): Promise<{\n  ipcPort: number\n  ipcServer: import('http').Server\n  ipcValidationKey: string\n}> {\n  // Generate a random key in memory to validate messages from other processes.\n  // This is just a simple guard against other processes attempting to send\n  // traffic to the IPC server.\n  const ipcValidationKey = crypto.randomBytes(32).toString('hex')\n\n  const ipcServer = (require('http') as typeof import('http')).createServer(\n    async (req, res) => {\n      try {\n        const url = new URL(req.url || '/', 'http://n')\n        const key = url.searchParams.get('key')\n\n        if (key !== ipcValidationKey) {\n          return res.end()\n        }\n\n        const method = url.searchParams.get('method')\n        let body = await new Promise<string>((resolve, reject) => {\n          let str = ''\n          req.on('data', (chunk) => {\n            str += chunk\n          })\n          req.on('end', () => {\n            resolve(str)\n          })\n          req.on('error', (err) => {\n            reject(err)\n          })\n          res.on('close', function () {\n            let aborted = !res.writableFinished\n            if (aborted) {\n              reject(new Error('ipc request aborted'))\n            }\n          })\n        })\n        const args: any[] = JSON.parse(body || '[]')\n\n        if (!method || !Array.isArray(args)) {\n          return res.end()\n        }\n\n        if (typeof (server as any)[method] === 'function') {\n          if (method === 'logErrorWithOriginalStack' && args[0]?.stack) {\n            args[0] = deserializeErr(args[0])\n          }\n          let result = await (server as any)[method](...args)\n\n          if (result && typeof result === 'object' && result.stack) {\n            result = errorToJSON(result)\n          }\n          res.end(JSON.stringify(result || ''))\n        }\n      } catch (err: any) {\n        if (isError(err) && err.code !== 'ENOENT') {\n          console.error(err)\n        }\n        res.end(\n          JSON.stringify({\n            err: { name: err.name, message: err.message, stack: err.stack },\n          })\n        )\n      }\n    }\n  )\n\n  const ipcPort = await new Promise<number>((resolveIpc) => {\n    ipcServer.listen(0, server.hostname, () => {\n      const addr = ipcServer.address()\n\n      if (addr && typeof addr === 'object') {\n        resolveIpc(addr.port)\n      }\n    })\n  })\n\n  return {\n    ipcPort,\n    ipcServer,\n    ipcValidationKey,\n  }\n}\n"],"names":["createIpcServer","server","ipcValidationKey","crypto","randomBytes","toString","ipcServer","require","createServer","req","res","url","URL","key","searchParams","get","end","method","body","Promise","resolve","reject","str","on","chunk","err","aborted","writableFinished","Error","args","JSON","parse","Array","isArray","stack","deserializeErr","result","errorToJSON","stringify","isError","code","console","error","name","message","ipcPort","resolveIpc","listen","hostname","addr","address","port"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":";;;;+BASsBA;;;eAAAA;;;wBARM;+DACT;gEACC;8BACW;;;;;;AAKxB,eAAeA,gBACpBC,MAAuC;IAMvC,6EAA6E;IAC7E,yEAAyE;IACzE,6BAA6B;IAC7B,MAAMC,mBAAmBC,eAAM,CAACC,WAAW,CAAC,IAAIC,QAAQ,CAAC;IAEzD,MAAMC,YAAY,AAACC,QAAQ,QAAkCC,YAAY,CACvE,OAAOC,KAAKC;QACV,IAAI;YACF,MAAMC,MAAM,IAAIC,IAAIH,IAAIE,GAAG,IAAI,KAAK;YACpC,MAAME,MAAMF,IAAIG,YAAY,CAACC,GAAG,CAAC;YAEjC,IAAIF,QAAQX,kBAAkB;gBAC5B,OAAOQ,IAAIM,GAAG;YAChB;YAEA,MAAMC,SAASN,IAAIG,YAAY,CAACC,GAAG,CAAC;YACpC,IAAIG,OAAO,MAAM,IAAIC,QAAgB,CAACC,SAASC;gBAC7C,IAAIC,MAAM;gBACVb,IAAIc,EAAE,CAAC,QAAQ,CAACC;oBACdF,OAAOE;gBACT;gBACAf,IAAIc,EAAE,CAAC,OAAO;oBACZH,QAAQE;gBACV;gBACAb,IAAIc,EAAE,CAAC,SAAS,CAACE;oBACfJ,OAAOI;gBACT;gBACAf,IAAIa,EAAE,CAAC,SAAS;oBACd,IAAIG,UAAU,CAAChB,IAAIiB,gBAAgB;oBACnC,IAAID,SAAS;wBACXL,OAAO,IAAIO,MAAM;oBACnB;gBACF;YACF;YACA,MAAMC,OAAcC,KAAKC,KAAK,CAACb,QAAQ;YAEvC,IAAI,CAACD,UAAU,CAACe,MAAMC,OAAO,CAACJ,OAAO;gBACnC,OAAOnB,IAAIM,GAAG;YAChB;YAEA,IAAI,OAAO,AAACf,MAAc,CAACgB,OAAO,KAAK,YAAY;oBACHY;gBAA9C,IAAIZ,WAAW,iCAA+BY,SAAAA,IAAI,CAAC,EAAE,qBAAPA,OAASK,KAAK,GAAE;oBAC5DL,IAAI,CAAC,EAAE,GAAGM,IAAAA,4BAAc,EAACN,IAAI,CAAC,EAAE;gBAClC;gBACA,IAAIO,SAAS,MAAM,AAACnC,MAAc,CAACgB,OAAO,IAAIY;gBAE9C,IAAIO,UAAU,OAAOA,WAAW,YAAYA,OAAOF,KAAK,EAAE;oBACxDE,SAASC,IAAAA,mBAAW,EAACD;gBACvB;gBACA1B,IAAIM,GAAG,CAACc,KAAKQ,SAAS,CAACF,UAAU;YACnC;QACF,EAAE,OAAOX,KAAU;YACjB,IAAIc,IAAAA,gBAAO,EAACd,QAAQA,IAAIe,IAAI,KAAK,UAAU;gBACzCC,QAAQC,KAAK,CAACjB;YAChB;YACAf,IAAIM,GAAG,CACLc,KAAKQ,SAAS,CAAC;gBACbb,KAAK;oBAAEkB,MAAMlB,IAAIkB,IAAI;oBAAEC,SAASnB,IAAImB,OAAO;oBAAEV,OAAOT,IAAIS,KAAK;gBAAC;YAChE;QAEJ;IACF;IAGF,MAAMW,UAAU,MAAM,IAAI1B,QAAgB,CAAC2B;QACzCxC,UAAUyC,MAAM,CAAC,GAAG9C,OAAO+C,QAAQ,EAAE;YACnC,MAAMC,OAAO3C,UAAU4C,OAAO;YAE9B,IAAID,QAAQ,OAAOA,SAAS,UAAU;gBACpCH,WAAWG,KAAKE,IAAI;YACtB;QACF;IACF;IAEA,OAAO;QACLN;QACAvC;QACAJ;IACF;AACF"}