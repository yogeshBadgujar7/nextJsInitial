{"version":3,"sources":["../../../src/server/async-storage/static-generation-async-storage-wrapper.ts"],"sourcesContent":["import type { AsyncStorageWrapper } from './async-storage-wrapper'\nimport type { StaticGenerationStore } from '../../client/components/static-generation-async-storage.external'\nimport type { AsyncLocalStorage } from 'async_hooks'\nimport type { IncrementalCache } from '../lib/incremental-cache'\nimport type { RenderOptsPartial } from '../app-render/types'\n\nimport { createPrerenderState } from '../../server/app-render/dynamic-rendering'\nimport type { FetchMetric } from '../base-http'\nimport type { RequestLifecycleOpts } from '../base-server'\n\nexport type StaticGenerationContext = {\n  urlPathname: string\n  requestEndedState?: { ended?: boolean }\n  renderOpts: {\n    incrementalCache?: IncrementalCache\n    isOnDemandRevalidate?: boolean\n    fetchCache?: StaticGenerationStore['fetchCache']\n    isServerAction?: boolean\n    pendingWaitUntil?: Promise<any>\n    experimental: Pick<\n      RenderOptsPartial['experimental'],\n      'isRoutePPREnabled' | 'after'\n    >\n\n    /**\n     * Fetch metrics attached in patch-fetch.ts\n     **/\n    fetchMetrics?: FetchMetric[]\n\n    /**\n     * A hack around accessing the store value outside the context of the\n     * request.\n     *\n     * @internal\n     * @deprecated should only be used as a temporary workaround\n     */\n    // TODO: remove this when we resolve accessing the store outside the execution context\n    store?: StaticGenerationStore\n  } & Pick<\n    // Pull some properties from RenderOptsPartial so that the docs are also\n    // mirrored.\n    RenderOptsPartial,\n    | 'originalPathname'\n    | 'supportsDynamicHTML'\n    | 'isRevalidate'\n    | 'nextExport'\n    | 'isDraftMode'\n    | 'isDebugPPRSkeleton'\n  > &\n    Partial<RequestLifecycleOpts>\n}\n\nexport const StaticGenerationAsyncStorageWrapper: AsyncStorageWrapper<\n  StaticGenerationStore,\n  StaticGenerationContext\n> = {\n  wrap<Result>(\n    storage: AsyncLocalStorage<StaticGenerationStore>,\n    { urlPathname, renderOpts, requestEndedState }: StaticGenerationContext,\n    callback: (store: StaticGenerationStore) => Result\n  ): Result {\n    /**\n     * Rules of Static & Dynamic HTML:\n     *\n     *    1.) We must generate static HTML unless the caller explicitly opts\n     *        in to dynamic HTML support.\n     *\n     *    2.) If dynamic HTML support is requested, we must honor that request\n     *        or throw an error. It is the sole responsibility of the caller to\n     *        ensure they aren't e.g. requesting dynamic HTML for an AMP page.\n     *\n     *    3.) If the request is in draft mode, we must generate dynamic HTML.\n     *\n     *    4.) If the request is a server action, we must generate dynamic HTML.\n     *\n     * These rules help ensure that other existing features like request caching,\n     * coalescing, and ISR continue working as intended.\n     */\n    const isStaticGeneration =\n      !renderOpts.supportsDynamicHTML &&\n      !renderOpts.isDraftMode &&\n      !renderOpts.isServerAction\n\n    const prerenderState: StaticGenerationStore['prerenderState'] =\n      isStaticGeneration && renderOpts.experimental?.isRoutePPREnabled\n        ? createPrerenderState(renderOpts.isDebugPPRSkeleton)\n        : null\n\n    const store: StaticGenerationStore = {\n      isStaticGeneration,\n      urlPathname,\n      pagePath: renderOpts.originalPathname,\n      incrementalCache:\n        // we fallback to a global incremental cache for edge-runtime locally\n        // so that it can access the fs cache without mocks\n        renderOpts.incrementalCache || (globalThis as any).__incrementalCache,\n      isRevalidate: renderOpts.isRevalidate,\n      isPrerendering: renderOpts.nextExport,\n      fetchCache: renderOpts.fetchCache,\n      isOnDemandRevalidate: renderOpts.isOnDemandRevalidate,\n\n      isDraftMode: renderOpts.isDraftMode,\n\n      prerenderState,\n      requestEndedState,\n    }\n\n    // TODO: remove this when we resolve accessing the store outside the execution context\n    renderOpts.store = store\n\n    return storage.run(store, callback, store)\n  },\n}\n"],"names":["StaticGenerationAsyncStorageWrapper","wrap","storage","urlPathname","renderOpts","requestEndedState","callback","isStaticGeneration","supportsDynamicHTML","isDraftMode","isServerAction","prerenderState","experimental","isRoutePPREnabled","createPrerenderState","isDebugPPRSkeleton","store","pagePath","originalPathname","incrementalCache","globalThis","__incrementalCache","isRevalidate","isPrerendering","nextExport","fetchCache","isOnDemandRevalidate","run"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":";;;;+BAoDaA;;;eAAAA;;;kCA9CwB;AA8C9B,MAAMA,sCAGT;IACFC,MACEC,OAAiD,EACjD,EAAEC,WAAW,EAAEC,UAAU,EAAEC,iBAAiB,EAA2B,EACvEC,QAAkD;YAyB1BF;QAvBxB;;;;;;;;;;;;;;;;KAgBC,GACD,MAAMG,qBACJ,CAACH,WAAWI,mBAAmB,IAC/B,CAACJ,WAAWK,WAAW,IACvB,CAACL,WAAWM,cAAc;QAE5B,MAAMC,iBACJJ,wBAAsBH,2BAAAA,WAAWQ,YAAY,qBAAvBR,yBAAyBS,iBAAiB,IAC5DC,IAAAA,sCAAoB,EAACV,WAAWW,kBAAkB,IAClD;QAEN,MAAMC,QAA+B;YACnCT;YACAJ;YACAc,UAAUb,WAAWc,gBAAgB;YACrCC,kBACE,qEAAqE;YACrE,mDAAmD;YACnDf,WAAWe,gBAAgB,IAAI,AAACC,WAAmBC,kBAAkB;YACvEC,cAAclB,WAAWkB,YAAY;YACrCC,gBAAgBnB,WAAWoB,UAAU;YACrCC,YAAYrB,WAAWqB,UAAU;YACjCC,sBAAsBtB,WAAWsB,oBAAoB;YAErDjB,aAAaL,WAAWK,WAAW;YAEnCE;YACAN;QACF;QAEA,sFAAsF;QACtFD,WAAWY,KAAK,GAAGA;QAEnB,OAAOd,QAAQyB,GAAG,CAACX,OAAOV,UAAUU;IACtC;AACF"}