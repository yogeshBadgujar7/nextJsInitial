{"version":3,"sources":["../../../src/server/web/edge-route-module-wrapper.ts"],"sourcesContent":["import type { NextRequest } from './spec-extension/request'\nimport type {\n  AppRouteRouteHandlerContext,\n  AppRouteRouteModule,\n} from '../future/route-modules/app-route/module'\nimport type { PrerenderManifest } from '../../build'\n\nimport './globals'\n\nimport { adapter, type AdapterOptions } from './adapter'\nimport { IncrementalCache } from '../lib/incremental-cache'\nimport { RouteMatcher } from '../future/route-matchers/route-matcher'\nimport type { NextFetchEvent } from './spec-extension/fetch-event'\nimport { internal_getCurrentFunctionWaitUntil } from './internal-edge-wait-until'\nimport { getUtils } from '../server-utils'\nimport { searchParamsToUrlQuery } from '../../shared/lib/router/utils/querystring'\nimport type { RequestLifecycleOpts } from '../base-server'\nimport { CloseController, trackStreamConsumed } from './web-on-close'\n\ntype WrapOptions = Partial<Pick<AdapterOptions, 'page'>>\n\n/**\n * EdgeRouteModuleWrapper is a wrapper around a route module.\n *\n * Note that this class should only be used in the edge runtime.\n */\nexport class EdgeRouteModuleWrapper {\n  private readonly matcher: RouteMatcher\n\n  /**\n   * The constructor is wrapped with private to ensure that it can only be\n   * constructed by the static wrap method.\n   *\n   * @param routeModule the route module to wrap\n   */\n  private constructor(private readonly routeModule: AppRouteRouteModule) {\n    // TODO: (wyattjoh) possibly allow the module to define it's own matcher\n    this.matcher = new RouteMatcher(routeModule.definition)\n  }\n\n  /**\n   * This will wrap a module with the EdgeModuleWrapper and return a function\n   * that can be used as a handler for the edge runtime.\n   *\n   * @param module the module to wrap\n   * @param options any options that should be passed to the adapter and\n   *                override the ones passed from the runtime\n   * @returns a function that can be used as a handler for the edge runtime\n   */\n  public static wrap(\n    routeModule: AppRouteRouteModule,\n    options: WrapOptions = {}\n  ) {\n    // Create the module wrapper.\n    const wrapper = new EdgeRouteModuleWrapper(routeModule)\n\n    // Return the wrapping function.\n    return (opts: AdapterOptions) => {\n      return adapter({\n        ...opts,\n        ...options,\n        IncrementalCache,\n        // Bind the handler method to the wrapper so it still has context.\n        handler: wrapper.handler.bind(wrapper),\n      })\n    }\n  }\n\n  private async handler(\n    request: NextRequest,\n    evt: NextFetchEvent\n  ): Promise<Response> {\n    const utils = getUtils({\n      pageIsDynamic: this.matcher.isDynamic,\n      page: this.matcher.definition.pathname,\n      basePath: request.nextUrl.basePath,\n      // We don't need the `handleRewrite` util, so can just pass an empty object\n      rewrites: {},\n      // only used for rewrites, so setting an arbitrary default value here\n      caseSensitive: false,\n    })\n\n    const { params } = utils.normalizeDynamicRouteParams(\n      searchParamsToUrlQuery(request.nextUrl.searchParams)\n    )\n\n    const prerenderManifest: PrerenderManifest | undefined =\n      typeof self.__PRERENDER_MANIFEST === 'string'\n        ? JSON.parse(self.__PRERENDER_MANIFEST)\n        : undefined\n\n    const isAfterEnabled = !!process.env.__NEXT_AFTER\n\n    let waitUntil: RequestLifecycleOpts['waitUntil'] = undefined\n    let closeController: CloseController | undefined\n\n    if (isAfterEnabled) {\n      waitUntil = evt.waitUntil.bind(evt)\n      closeController = new CloseController()\n    }\n\n    // Create the context for the handler. This contains the params from the\n    // match (if any).\n    const context: AppRouteRouteHandlerContext = {\n      params,\n      prerenderManifest: {\n        version: 4,\n        routes: {},\n        dynamicRoutes: {},\n        preview: prerenderManifest?.preview || {\n          previewModeEncryptionKey: '',\n          previewModeId: 'development-id',\n          previewModeSigningKey: '',\n        },\n        notFoundRoutes: [],\n      },\n      renderOpts: {\n        supportsDynamicHTML: true,\n        waitUntil,\n        onClose: closeController\n          ? closeController.onClose.bind(closeController)\n          : undefined,\n        experimental: {\n          after: isAfterEnabled,\n        },\n      },\n    }\n\n    // Get the response from the handler.\n    let res = await this.routeModule.handle(request, context)\n\n    const waitUntilPromises = [internal_getCurrentFunctionWaitUntil()]\n    if (context.renderOpts.pendingWaitUntil) {\n      waitUntilPromises.push(context.renderOpts.pendingWaitUntil)\n    }\n    evt.waitUntil(Promise.all(waitUntilPromises))\n\n    if (closeController) {\n      const _closeController = closeController // TS annoyance - \"possibly undefined\" in callbacks\n\n      if (!res.body) {\n        // we can delay running it until a bit later --\n        // if it's needed, we'll have a `waitUntil` lock anyway.\n        setTimeout(() => _closeController.dispatchClose(), 0)\n      } else {\n        // NOTE: if this is a streaming response, onClose may be called later,\n        // so we can't rely on `closeController.listeners` -- it might be 0 at this point.\n        const trackedBody = trackStreamConsumed(res.body, () =>\n          _closeController.dispatchClose()\n        )\n        res = new Response(trackedBody, {\n          status: res.status,\n          statusText: res.statusText,\n          headers: res.headers,\n        })\n      }\n    }\n\n    return res\n  }\n}\n"],"names":["EdgeRouteModuleWrapper","routeModule","matcher","RouteMatcher","definition","wrap","options","wrapper","opts","adapter","IncrementalCache","handler","bind","request","evt","utils","getUtils","pageIsDynamic","isDynamic","page","pathname","basePath","nextUrl","rewrites","caseSensitive","params","normalizeDynamicRouteParams","searchParamsToUrlQuery","searchParams","prerenderManifest","self","__PRERENDER_MANIFEST","JSON","parse","undefined","isAfterEnabled","process","env","__NEXT_AFTER","waitUntil","closeController","CloseController","context","version","routes","dynamicRoutes","preview","previewModeEncryptionKey","previewModeId","previewModeSigningKey","notFoundRoutes","renderOpts","supportsDynamicHTML","onClose","experimental","after","res","handle","waitUntilPromises","internal_getCurrentFunctionWaitUntil","pendingWaitUntil","push","Promise","all","_closeController","body","setTimeout","dispatchClose","trackedBody","trackStreamConsumed","Response","status","statusText","headers"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}